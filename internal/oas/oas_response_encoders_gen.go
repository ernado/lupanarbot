// Code generated by ogen, DO NOT EDIT.

package oas

import (
	"net/http"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
)

func encodeAccountV1GetActiveRegionResponse(response AccountV1GetActiveRegionRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AccountV1AccountRegionDTO:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *AccountV1GetActiveRegionBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *AccountV1GetActiveRegionUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *AccountV1GetActiveRegionForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *AccountV1GetActiveRegionNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *AccountV1GetActiveRegionMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *AccountV1GetActiveRegionUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *AccountV1GetActiveRegionTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *AccountV1GetActiveRegionInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *AccountV1GetActiveRegionBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *AccountV1GetActiveRegionServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *AccountV1GetActiveRegionGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeAccountV1GetActiveShardResponse(response AccountV1GetActiveShardRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AccountV1ActiveShardDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *AccountV1GetActiveShardBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *AccountV1GetActiveShardUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *AccountV1GetActiveShardForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *AccountV1GetActiveShardNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *AccountV1GetActiveShardMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *AccountV1GetActiveShardUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *AccountV1GetActiveShardTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *AccountV1GetActiveShardInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *AccountV1GetActiveShardBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *AccountV1GetActiveShardServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *AccountV1GetActiveShardGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeAccountV1GetByAccessTokenResponse(response AccountV1GetByAccessTokenRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AccountV1AccountDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *AccountV1GetByAccessTokenBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *AccountV1GetByAccessTokenUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *AccountV1GetByAccessTokenForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *AccountV1GetByAccessTokenNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *AccountV1GetByAccessTokenMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *AccountV1GetByAccessTokenUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *AccountV1GetByAccessTokenTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *AccountV1GetByAccessTokenInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *AccountV1GetByAccessTokenBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *AccountV1GetByAccessTokenServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *AccountV1GetByAccessTokenGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeAccountV1GetByPuuidResponse(response AccountV1GetByPuuidRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AccountV1AccountDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *AccountV1GetByPuuidBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *AccountV1GetByPuuidUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *AccountV1GetByPuuidForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *AccountV1GetByPuuidNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *AccountV1GetByPuuidMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *AccountV1GetByPuuidUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *AccountV1GetByPuuidTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *AccountV1GetByPuuidInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *AccountV1GetByPuuidBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *AccountV1GetByPuuidServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *AccountV1GetByPuuidGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeAccountV1GetByRiotIdResponse(response AccountV1GetByRiotIdRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *AccountV1AccountDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *AccountV1GetByRiotIdBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *AccountV1GetByRiotIdUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *AccountV1GetByRiotIdForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *AccountV1GetByRiotIdNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *AccountV1GetByRiotIdMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *AccountV1GetByRiotIdUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *AccountV1GetByRiotIdTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *AccountV1GetByRiotIdInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *AccountV1GetByRiotIdBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *AccountV1GetByRiotIdServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *AccountV1GetByRiotIdGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeChampionMasteryV4GetAllChampionMasteriesByPUUIDResponse(response ChampionMasteryV4GetAllChampionMasteriesByPUUIDRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ChampionMasteryV4GetAllChampionMasteriesByPUUIDOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ChampionMasteryV4GetAllChampionMasteriesByPUUIDBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *ChampionMasteryV4GetAllChampionMasteriesByPUUIDUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *ChampionMasteryV4GetAllChampionMasteriesByPUUIDForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *ChampionMasteryV4GetAllChampionMasteriesByPUUIDNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *ChampionMasteryV4GetAllChampionMasteriesByPUUIDMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *ChampionMasteryV4GetAllChampionMasteriesByPUUIDUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *ChampionMasteryV4GetAllChampionMasteriesByPUUIDTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *ChampionMasteryV4GetAllChampionMasteriesByPUUIDInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *ChampionMasteryV4GetAllChampionMasteriesByPUUIDBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *ChampionMasteryV4GetAllChampionMasteriesByPUUIDServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *ChampionMasteryV4GetAllChampionMasteriesByPUUIDGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeChampionMasteryV4GetChampionMasteryByPUUIDResponse(response ChampionMasteryV4GetChampionMasteryByPUUIDRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ChampionMasteryV4ChampionMasteryDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ChampionMasteryV4GetChampionMasteryByPUUIDBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *ChampionMasteryV4GetChampionMasteryByPUUIDUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *ChampionMasteryV4GetChampionMasteryByPUUIDForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *ChampionMasteryV4GetChampionMasteryByPUUIDNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *ChampionMasteryV4GetChampionMasteryByPUUIDMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *ChampionMasteryV4GetChampionMasteryByPUUIDUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *ChampionMasteryV4GetChampionMasteryByPUUIDTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *ChampionMasteryV4GetChampionMasteryByPUUIDInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *ChampionMasteryV4GetChampionMasteryByPUUIDBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *ChampionMasteryV4GetChampionMasteryByPUUIDServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *ChampionMasteryV4GetChampionMasteryByPUUIDGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeChampionMasteryV4GetChampionMasteryScoreByPUUIDResponse(response ChampionMasteryV4GetChampionMasteryScoreByPUUIDRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ChampionMasteryV4GetChampionMasteryScoreByPUUIDOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ChampionMasteryV4GetChampionMasteryScoreByPUUIDBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *ChampionMasteryV4GetChampionMasteryScoreByPUUIDUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *ChampionMasteryV4GetChampionMasteryScoreByPUUIDForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *ChampionMasteryV4GetChampionMasteryScoreByPUUIDNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *ChampionMasteryV4GetChampionMasteryScoreByPUUIDMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *ChampionMasteryV4GetChampionMasteryScoreByPUUIDUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *ChampionMasteryV4GetChampionMasteryScoreByPUUIDTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *ChampionMasteryV4GetChampionMasteryScoreByPUUIDInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *ChampionMasteryV4GetChampionMasteryScoreByPUUIDBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *ChampionMasteryV4GetChampionMasteryScoreByPUUIDServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *ChampionMasteryV4GetChampionMasteryScoreByPUUIDGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeChampionMasteryV4GetTopChampionMasteriesByPUUIDResponse(response ChampionMasteryV4GetTopChampionMasteriesByPUUIDRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ChampionMasteryV4GetTopChampionMasteriesByPUUIDOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ChampionMasteryV4GetTopChampionMasteriesByPUUIDBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *ChampionMasteryV4GetTopChampionMasteriesByPUUIDUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *ChampionMasteryV4GetTopChampionMasteriesByPUUIDForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *ChampionMasteryV4GetTopChampionMasteriesByPUUIDNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *ChampionMasteryV4GetTopChampionMasteriesByPUUIDMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *ChampionMasteryV4GetTopChampionMasteriesByPUUIDUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *ChampionMasteryV4GetTopChampionMasteriesByPUUIDTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *ChampionMasteryV4GetTopChampionMasteriesByPUUIDInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *ChampionMasteryV4GetTopChampionMasteriesByPUUIDBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *ChampionMasteryV4GetTopChampionMasteriesByPUUIDServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *ChampionMasteryV4GetTopChampionMasteriesByPUUIDGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeChampionV3GetChampionInfoResponse(response ChampionV3GetChampionInfoRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ChampionV3ChampionInfo:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ChampionV3GetChampionInfoBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *ChampionV3GetChampionInfoUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *ChampionV3GetChampionInfoForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *ChampionV3GetChampionInfoNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *ChampionV3GetChampionInfoMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *ChampionV3GetChampionInfoUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *ChampionV3GetChampionInfoTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *ChampionV3GetChampionInfoInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *ChampionV3GetChampionInfoBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *ChampionV3GetChampionInfoServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *ChampionV3GetChampionInfoGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeClashV1GetPlayersByPUUIDResponse(response ClashV1GetPlayersByPUUIDRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ClashV1GetPlayersByPUUIDOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ClashV1GetPlayersByPUUIDBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *ClashV1GetPlayersByPUUIDUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *ClashV1GetPlayersByPUUIDForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *ClashV1GetPlayersByPUUIDNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *ClashV1GetPlayersByPUUIDMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *ClashV1GetPlayersByPUUIDUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *ClashV1GetPlayersByPUUIDTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *ClashV1GetPlayersByPUUIDInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *ClashV1GetPlayersByPUUIDBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *ClashV1GetPlayersByPUUIDServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *ClashV1GetPlayersByPUUIDGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeClashV1GetTeamByIdResponse(response ClashV1GetTeamByIdRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ClashV1TeamDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ClashV1GetTeamByIdBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *ClashV1GetTeamByIdUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *ClashV1GetTeamByIdForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *ClashV1GetTeamByIdNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *ClashV1GetTeamByIdMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *ClashV1GetTeamByIdUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *ClashV1GetTeamByIdTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *ClashV1GetTeamByIdInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *ClashV1GetTeamByIdBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *ClashV1GetTeamByIdServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *ClashV1GetTeamByIdGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeClashV1GetTournamentByIdResponse(response ClashV1GetTournamentByIdRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ClashV1TournamentDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ClashV1GetTournamentByIdBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *ClashV1GetTournamentByIdUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *ClashV1GetTournamentByIdForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *ClashV1GetTournamentByIdNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *ClashV1GetTournamentByIdMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *ClashV1GetTournamentByIdUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *ClashV1GetTournamentByIdTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *ClashV1GetTournamentByIdInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *ClashV1GetTournamentByIdBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *ClashV1GetTournamentByIdServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *ClashV1GetTournamentByIdGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeClashV1GetTournamentByTeamResponse(response ClashV1GetTournamentByTeamRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ClashV1TournamentDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ClashV1GetTournamentByTeamBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *ClashV1GetTournamentByTeamUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *ClashV1GetTournamentByTeamForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *ClashV1GetTournamentByTeamNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *ClashV1GetTournamentByTeamMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *ClashV1GetTournamentByTeamUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *ClashV1GetTournamentByTeamTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *ClashV1GetTournamentByTeamInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *ClashV1GetTournamentByTeamBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *ClashV1GetTournamentByTeamServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *ClashV1GetTournamentByTeamGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeClashV1GetTournamentsResponse(response ClashV1GetTournamentsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ClashV1GetTournamentsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ClashV1GetTournamentsBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *ClashV1GetTournamentsUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *ClashV1GetTournamentsForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *ClashV1GetTournamentsNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *ClashV1GetTournamentsMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *ClashV1GetTournamentsUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *ClashV1GetTournamentsTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *ClashV1GetTournamentsInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *ClashV1GetTournamentsBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *ClashV1GetTournamentsServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *ClashV1GetTournamentsGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLeagueExpV4GetLeagueEntriesResponse(response LeagueExpV4GetLeagueEntriesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LeagueExpV4GetLeagueEntriesOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LeagueExpV4GetLeagueEntriesBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LeagueExpV4GetLeagueEntriesUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LeagueExpV4GetLeagueEntriesForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LeagueExpV4GetLeagueEntriesNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LeagueExpV4GetLeagueEntriesMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LeagueExpV4GetLeagueEntriesUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LeagueExpV4GetLeagueEntriesTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LeagueExpV4GetLeagueEntriesInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LeagueExpV4GetLeagueEntriesBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LeagueExpV4GetLeagueEntriesServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LeagueExpV4GetLeagueEntriesGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLeagueV4GetChallengerLeagueResponse(response LeagueV4GetChallengerLeagueRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LeagueV4LeagueListDTO:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LeagueV4GetChallengerLeagueBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LeagueV4GetChallengerLeagueUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LeagueV4GetChallengerLeagueForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LeagueV4GetChallengerLeagueNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LeagueV4GetChallengerLeagueMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LeagueV4GetChallengerLeagueUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LeagueV4GetChallengerLeagueTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LeagueV4GetChallengerLeagueInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LeagueV4GetChallengerLeagueBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LeagueV4GetChallengerLeagueServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LeagueV4GetChallengerLeagueGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLeagueV4GetGrandmasterLeagueResponse(response LeagueV4GetGrandmasterLeagueRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LeagueV4LeagueListDTO:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LeagueV4GetGrandmasterLeagueBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LeagueV4GetGrandmasterLeagueUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LeagueV4GetGrandmasterLeagueForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LeagueV4GetGrandmasterLeagueNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LeagueV4GetGrandmasterLeagueMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LeagueV4GetGrandmasterLeagueUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LeagueV4GetGrandmasterLeagueTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LeagueV4GetGrandmasterLeagueInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LeagueV4GetGrandmasterLeagueBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LeagueV4GetGrandmasterLeagueServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LeagueV4GetGrandmasterLeagueGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLeagueV4GetLeagueByIdResponse(response LeagueV4GetLeagueByIdRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LeagueV4LeagueListDTO:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LeagueV4GetLeagueByIdBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LeagueV4GetLeagueByIdUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LeagueV4GetLeagueByIdForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LeagueV4GetLeagueByIdNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LeagueV4GetLeagueByIdMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LeagueV4GetLeagueByIdUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LeagueV4GetLeagueByIdTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LeagueV4GetLeagueByIdInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LeagueV4GetLeagueByIdBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LeagueV4GetLeagueByIdServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LeagueV4GetLeagueByIdGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLeagueV4GetLeagueEntriesResponse(response LeagueV4GetLeagueEntriesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LeagueV4GetLeagueEntriesOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LeagueV4GetLeagueEntriesBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LeagueV4GetLeagueEntriesUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LeagueV4GetLeagueEntriesForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LeagueV4GetLeagueEntriesNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LeagueV4GetLeagueEntriesMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LeagueV4GetLeagueEntriesUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LeagueV4GetLeagueEntriesTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LeagueV4GetLeagueEntriesInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LeagueV4GetLeagueEntriesBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LeagueV4GetLeagueEntriesServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LeagueV4GetLeagueEntriesGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLeagueV4GetLeagueEntriesByPUUIDResponse(response LeagueV4GetLeagueEntriesByPUUIDRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LeagueV4GetLeagueEntriesByPUUIDOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LeagueV4GetLeagueEntriesByPUUIDBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LeagueV4GetLeagueEntriesByPUUIDUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LeagueV4GetLeagueEntriesByPUUIDForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LeagueV4GetLeagueEntriesByPUUIDNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LeagueV4GetLeagueEntriesByPUUIDMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LeagueV4GetLeagueEntriesByPUUIDUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LeagueV4GetLeagueEntriesByPUUIDTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LeagueV4GetLeagueEntriesByPUUIDInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LeagueV4GetLeagueEntriesByPUUIDBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LeagueV4GetLeagueEntriesByPUUIDServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LeagueV4GetLeagueEntriesByPUUIDGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLeagueV4GetMasterLeagueResponse(response LeagueV4GetMasterLeagueRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LeagueV4LeagueListDTO:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LeagueV4GetMasterLeagueBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LeagueV4GetMasterLeagueUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LeagueV4GetMasterLeagueForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LeagueV4GetMasterLeagueNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LeagueV4GetMasterLeagueMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LeagueV4GetMasterLeagueUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LeagueV4GetMasterLeagueTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LeagueV4GetMasterLeagueInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LeagueV4GetMasterLeagueBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LeagueV4GetMasterLeagueServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LeagueV4GetMasterLeagueGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLolChallengesV1GetAllChallengeConfigsResponse(response LolChallengesV1GetAllChallengeConfigsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LolChallengesV1GetAllChallengeConfigsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LolChallengesV1GetAllChallengeConfigsBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LolChallengesV1GetAllChallengeConfigsUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LolChallengesV1GetAllChallengeConfigsForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LolChallengesV1GetAllChallengeConfigsNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LolChallengesV1GetAllChallengeConfigsMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LolChallengesV1GetAllChallengeConfigsUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LolChallengesV1GetAllChallengeConfigsTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LolChallengesV1GetAllChallengeConfigsInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LolChallengesV1GetAllChallengeConfigsBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LolChallengesV1GetAllChallengeConfigsServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LolChallengesV1GetAllChallengeConfigsGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLolChallengesV1GetAllChallengePercentilesResponse(response LolChallengesV1GetAllChallengePercentilesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LolChallengesV1GetAllChallengePercentilesOK:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LolChallengesV1GetAllChallengePercentilesBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LolChallengesV1GetAllChallengePercentilesUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LolChallengesV1GetAllChallengePercentilesForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LolChallengesV1GetAllChallengePercentilesNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LolChallengesV1GetAllChallengePercentilesMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LolChallengesV1GetAllChallengePercentilesUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LolChallengesV1GetAllChallengePercentilesTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LolChallengesV1GetAllChallengePercentilesInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LolChallengesV1GetAllChallengePercentilesBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LolChallengesV1GetAllChallengePercentilesServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LolChallengesV1GetAllChallengePercentilesGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLolChallengesV1GetChallengeConfigsResponse(response LolChallengesV1GetChallengeConfigsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LolChallengesV1ChallengeConfigInfoDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LolChallengesV1GetChallengeConfigsBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LolChallengesV1GetChallengeConfigsUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LolChallengesV1GetChallengeConfigsForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LolChallengesV1GetChallengeConfigsNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LolChallengesV1GetChallengeConfigsMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LolChallengesV1GetChallengeConfigsUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LolChallengesV1GetChallengeConfigsTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LolChallengesV1GetChallengeConfigsInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LolChallengesV1GetChallengeConfigsBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LolChallengesV1GetChallengeConfigsServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LolChallengesV1GetChallengeConfigsGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLolChallengesV1GetChallengeLeaderboardsResponse(response LolChallengesV1GetChallengeLeaderboardsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LolChallengesV1GetChallengeLeaderboardsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LolChallengesV1GetChallengeLeaderboardsBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LolChallengesV1GetChallengeLeaderboardsUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LolChallengesV1GetChallengeLeaderboardsForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LolChallengesV1GetChallengeLeaderboardsNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LolChallengesV1GetChallengeLeaderboardsMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LolChallengesV1GetChallengeLeaderboardsUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LolChallengesV1GetChallengeLeaderboardsTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LolChallengesV1GetChallengeLeaderboardsInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LolChallengesV1GetChallengeLeaderboardsBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LolChallengesV1GetChallengeLeaderboardsServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LolChallengesV1GetChallengeLeaderboardsGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLolChallengesV1GetChallengePercentilesResponse(response LolChallengesV1GetChallengePercentilesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LolChallengesV1GetChallengePercentilesOK:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LolChallengesV1GetChallengePercentilesBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LolChallengesV1GetChallengePercentilesUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LolChallengesV1GetChallengePercentilesForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LolChallengesV1GetChallengePercentilesNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LolChallengesV1GetChallengePercentilesMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LolChallengesV1GetChallengePercentilesUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LolChallengesV1GetChallengePercentilesTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LolChallengesV1GetChallengePercentilesInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LolChallengesV1GetChallengePercentilesBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LolChallengesV1GetChallengePercentilesServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LolChallengesV1GetChallengePercentilesGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLolChallengesV1GetPlayerDataResponse(response LolChallengesV1GetPlayerDataRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LolChallengesV1PlayerInfoDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LolChallengesV1GetPlayerDataBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LolChallengesV1GetPlayerDataUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LolChallengesV1GetPlayerDataForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LolChallengesV1GetPlayerDataNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LolChallengesV1GetPlayerDataMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LolChallengesV1GetPlayerDataUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LolChallengesV1GetPlayerDataTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LolChallengesV1GetPlayerDataInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LolChallengesV1GetPlayerDataBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LolChallengesV1GetPlayerDataServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LolChallengesV1GetPlayerDataGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLolRsoMatchV1GetMatchResponse(response LolRsoMatchV1GetMatchRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *MatchV5MatchDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LolRsoMatchV1GetMatchBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LolRsoMatchV1GetMatchUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LolRsoMatchV1GetMatchForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LolRsoMatchV1GetMatchNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LolRsoMatchV1GetMatchMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LolRsoMatchV1GetMatchUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LolRsoMatchV1GetMatchTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LolRsoMatchV1GetMatchInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LolRsoMatchV1GetMatchBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LolRsoMatchV1GetMatchServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LolRsoMatchV1GetMatchGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLolRsoMatchV1GetMatchIdsResponse(response LolRsoMatchV1GetMatchIdsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LolRsoMatchV1GetMatchIdsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LolRsoMatchV1GetMatchIdsBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LolRsoMatchV1GetMatchIdsUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LolRsoMatchV1GetMatchIdsForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LolRsoMatchV1GetMatchIdsNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LolRsoMatchV1GetMatchIdsMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LolRsoMatchV1GetMatchIdsUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LolRsoMatchV1GetMatchIdsTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LolRsoMatchV1GetMatchIdsInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LolRsoMatchV1GetMatchIdsBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LolRsoMatchV1GetMatchIdsServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LolRsoMatchV1GetMatchIdsGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLolRsoMatchV1GetTimelineResponse(response LolRsoMatchV1GetTimelineRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *MatchV5TimelineDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LolRsoMatchV1GetTimelineBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LolRsoMatchV1GetTimelineUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LolRsoMatchV1GetTimelineForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LolRsoMatchV1GetTimelineNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LolRsoMatchV1GetTimelineMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LolRsoMatchV1GetTimelineUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LolRsoMatchV1GetTimelineTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LolRsoMatchV1GetTimelineInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LolRsoMatchV1GetTimelineBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LolRsoMatchV1GetTimelineServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LolRsoMatchV1GetTimelineGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLolStatusV4GetPlatformDataResponse(response LolStatusV4GetPlatformDataRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LolStatusV4PlatformDataDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LolStatusV4GetPlatformDataBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LolStatusV4GetPlatformDataUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LolStatusV4GetPlatformDataForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LolStatusV4GetPlatformDataNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LolStatusV4GetPlatformDataMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LolStatusV4GetPlatformDataUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LolStatusV4GetPlatformDataTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LolStatusV4GetPlatformDataInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LolStatusV4GetPlatformDataBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LolStatusV4GetPlatformDataServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LolStatusV4GetPlatformDataGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLorDeckV1CreateDeckResponse(response LorDeckV1CreateDeckRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LorDeckV1CreateDeckOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LorDeckV1CreateDeckBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LorDeckV1CreateDeckUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LorDeckV1CreateDeckForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LorDeckV1CreateDeckNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LorDeckV1CreateDeckMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LorDeckV1CreateDeckUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LorDeckV1CreateDeckTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LorDeckV1CreateDeckInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LorDeckV1CreateDeckBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LorDeckV1CreateDeckServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LorDeckV1CreateDeckGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLorDeckV1GetDecksResponse(response LorDeckV1GetDecksRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LorDeckV1GetDecksOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LorDeckV1GetDecksBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LorDeckV1GetDecksUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LorDeckV1GetDecksForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LorDeckV1GetDecksNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LorDeckV1GetDecksMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LorDeckV1GetDecksUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LorDeckV1GetDecksTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LorDeckV1GetDecksInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LorDeckV1GetDecksBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LorDeckV1GetDecksServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LorDeckV1GetDecksGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLorInventoryV1GetCardsResponse(response LorInventoryV1GetCardsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LorInventoryV1GetCardsOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LorInventoryV1GetCardsBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LorInventoryV1GetCardsUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LorInventoryV1GetCardsForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LorInventoryV1GetCardsNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LorInventoryV1GetCardsMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LorInventoryV1GetCardsUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LorInventoryV1GetCardsTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LorInventoryV1GetCardsInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LorInventoryV1GetCardsBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LorInventoryV1GetCardsServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LorInventoryV1GetCardsGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLorMatchV1GetMatchResponse(response LorMatchV1GetMatchRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LorMatchV1MatchDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LorMatchV1GetMatchBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LorMatchV1GetMatchUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LorMatchV1GetMatchForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LorMatchV1GetMatchNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LorMatchV1GetMatchMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LorMatchV1GetMatchUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LorMatchV1GetMatchTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LorMatchV1GetMatchInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LorMatchV1GetMatchBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LorMatchV1GetMatchServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LorMatchV1GetMatchGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLorMatchV1GetMatchIdsByPUUIDResponse(response LorMatchV1GetMatchIdsByPUUIDRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LorMatchV1GetMatchIdsByPUUIDOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LorMatchV1GetMatchIdsByPUUIDBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LorMatchV1GetMatchIdsByPUUIDUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LorMatchV1GetMatchIdsByPUUIDForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LorMatchV1GetMatchIdsByPUUIDNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LorMatchV1GetMatchIdsByPUUIDMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LorMatchV1GetMatchIdsByPUUIDUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LorMatchV1GetMatchIdsByPUUIDTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LorMatchV1GetMatchIdsByPUUIDInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LorMatchV1GetMatchIdsByPUUIDBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LorMatchV1GetMatchIdsByPUUIDServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LorMatchV1GetMatchIdsByPUUIDGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLorRankedV1GetLeaderboardsResponse(response LorRankedV1GetLeaderboardsRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LorRankedV1LeaderboardDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LorRankedV1GetLeaderboardsBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LorRankedV1GetLeaderboardsUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LorRankedV1GetLeaderboardsForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LorRankedV1GetLeaderboardsNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LorRankedV1GetLeaderboardsMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LorRankedV1GetLeaderboardsUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LorRankedV1GetLeaderboardsTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LorRankedV1GetLeaderboardsInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LorRankedV1GetLeaderboardsBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LorRankedV1GetLeaderboardsServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LorRankedV1GetLeaderboardsGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeLorStatusV1GetPlatformDataResponse(response LorStatusV1GetPlatformDataRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *LorStatusV1PlatformDataDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *LorStatusV1GetPlatformDataBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *LorStatusV1GetPlatformDataUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *LorStatusV1GetPlatformDataForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *LorStatusV1GetPlatformDataNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *LorStatusV1GetPlatformDataMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *LorStatusV1GetPlatformDataUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *LorStatusV1GetPlatformDataTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *LorStatusV1GetPlatformDataInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *LorStatusV1GetPlatformDataBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *LorStatusV1GetPlatformDataServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *LorStatusV1GetPlatformDataGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeMatchV5GetMatchResponse(response MatchV5GetMatchRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *MatchV5MatchDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *MatchV5GetMatchBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *MatchV5GetMatchUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *MatchV5GetMatchForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *MatchV5GetMatchNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *MatchV5GetMatchMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *MatchV5GetMatchUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *MatchV5GetMatchTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *MatchV5GetMatchInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *MatchV5GetMatchBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *MatchV5GetMatchServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *MatchV5GetMatchGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeMatchV5GetMatchIdsByPUUIDResponse(response MatchV5GetMatchIdsByPUUIDRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *MatchV5GetMatchIdsByPUUIDOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *MatchV5GetMatchIdsByPUUIDBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *MatchV5GetMatchIdsByPUUIDUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *MatchV5GetMatchIdsByPUUIDForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *MatchV5GetMatchIdsByPUUIDNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *MatchV5GetMatchIdsByPUUIDMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *MatchV5GetMatchIdsByPUUIDUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *MatchV5GetMatchIdsByPUUIDTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *MatchV5GetMatchIdsByPUUIDInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *MatchV5GetMatchIdsByPUUIDBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *MatchV5GetMatchIdsByPUUIDServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *MatchV5GetMatchIdsByPUUIDGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeMatchV5GetTimelineResponse(response MatchV5GetTimelineRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *MatchV5TimelineDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *MatchV5GetTimelineBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *MatchV5GetTimelineUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *MatchV5GetTimelineForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *MatchV5GetTimelineNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *MatchV5GetTimelineMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *MatchV5GetTimelineUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *MatchV5GetTimelineTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *MatchV5GetTimelineInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *MatchV5GetTimelineBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *MatchV5GetTimelineServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *MatchV5GetTimelineGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeSpectatorTftV5GetCurrentGameInfoByPuuidResponse(response SpectatorTftV5GetCurrentGameInfoByPuuidRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *SpectatorTftV5CurrentGameInfo:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *SpectatorTftV5GetCurrentGameInfoByPuuidBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *SpectatorTftV5GetCurrentGameInfoByPuuidUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *SpectatorTftV5GetCurrentGameInfoByPuuidForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *SpectatorTftV5GetCurrentGameInfoByPuuidNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *SpectatorTftV5GetCurrentGameInfoByPuuidMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *SpectatorTftV5GetCurrentGameInfoByPuuidUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *SpectatorTftV5GetCurrentGameInfoByPuuidTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *SpectatorTftV5GetCurrentGameInfoByPuuidInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *SpectatorTftV5GetCurrentGameInfoByPuuidBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *SpectatorTftV5GetCurrentGameInfoByPuuidServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *SpectatorTftV5GetCurrentGameInfoByPuuidGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeSpectatorTftV5GetFeaturedGamesResponse(response SpectatorTftV5GetFeaturedGamesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *SpectatorTftV5FeaturedGames:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *SpectatorTftV5GetFeaturedGamesBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *SpectatorTftV5GetFeaturedGamesUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *SpectatorTftV5GetFeaturedGamesForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *SpectatorTftV5GetFeaturedGamesNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *SpectatorTftV5GetFeaturedGamesMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *SpectatorTftV5GetFeaturedGamesUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *SpectatorTftV5GetFeaturedGamesTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *SpectatorTftV5GetFeaturedGamesInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *SpectatorTftV5GetFeaturedGamesBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *SpectatorTftV5GetFeaturedGamesServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *SpectatorTftV5GetFeaturedGamesGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeSpectatorV5GetCurrentGameInfoByPuuidResponse(response SpectatorV5GetCurrentGameInfoByPuuidRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *SpectatorV5CurrentGameInfo:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *SpectatorV5GetCurrentGameInfoByPuuidBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *SpectatorV5GetCurrentGameInfoByPuuidUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *SpectatorV5GetCurrentGameInfoByPuuidForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *SpectatorV5GetCurrentGameInfoByPuuidNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *SpectatorV5GetCurrentGameInfoByPuuidMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *SpectatorV5GetCurrentGameInfoByPuuidUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *SpectatorV5GetCurrentGameInfoByPuuidTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *SpectatorV5GetCurrentGameInfoByPuuidInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *SpectatorV5GetCurrentGameInfoByPuuidBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *SpectatorV5GetCurrentGameInfoByPuuidServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *SpectatorV5GetCurrentGameInfoByPuuidGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeSpectatorV5GetFeaturedGamesResponse(response SpectatorV5GetFeaturedGamesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *SpectatorV5FeaturedGames:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *SpectatorV5GetFeaturedGamesBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *SpectatorV5GetFeaturedGamesUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *SpectatorV5GetFeaturedGamesForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *SpectatorV5GetFeaturedGamesNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *SpectatorV5GetFeaturedGamesMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *SpectatorV5GetFeaturedGamesUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *SpectatorV5GetFeaturedGamesTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *SpectatorV5GetFeaturedGamesInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *SpectatorV5GetFeaturedGamesBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *SpectatorV5GetFeaturedGamesServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *SpectatorV5GetFeaturedGamesGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeSummonerV4GetByAccessTokenResponse(response SummonerV4GetByAccessTokenRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *SummonerV4SummonerDTO:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *SummonerV4GetByAccessTokenBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *SummonerV4GetByAccessTokenUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *SummonerV4GetByAccessTokenForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *SummonerV4GetByAccessTokenNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *SummonerV4GetByAccessTokenMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *SummonerV4GetByAccessTokenUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *SummonerV4GetByAccessTokenTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *SummonerV4GetByAccessTokenInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *SummonerV4GetByAccessTokenBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *SummonerV4GetByAccessTokenServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *SummonerV4GetByAccessTokenGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeSummonerV4GetByPUUIDResponse(response SummonerV4GetByPUUIDRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *SummonerV4SummonerDTO:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *SummonerV4GetByPUUIDBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *SummonerV4GetByPUUIDUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *SummonerV4GetByPUUIDForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *SummonerV4GetByPUUIDNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *SummonerV4GetByPUUIDMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *SummonerV4GetByPUUIDUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *SummonerV4GetByPUUIDTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *SummonerV4GetByPUUIDInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *SummonerV4GetByPUUIDBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *SummonerV4GetByPUUIDServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *SummonerV4GetByPUUIDGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTftLeagueV1GetChallengerLeagueResponse(response TftLeagueV1GetChallengerLeagueRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TftLeagueV1LeagueListDTO:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *TftLeagueV1GetChallengerLeagueBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TftLeagueV1GetChallengerLeagueUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TftLeagueV1GetChallengerLeagueForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TftLeagueV1GetChallengerLeagueNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TftLeagueV1GetChallengerLeagueMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TftLeagueV1GetChallengerLeagueUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TftLeagueV1GetChallengerLeagueTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TftLeagueV1GetChallengerLeagueInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TftLeagueV1GetChallengerLeagueBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TftLeagueV1GetChallengerLeagueServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TftLeagueV1GetChallengerLeagueGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTftLeagueV1GetGrandmasterLeagueResponse(response TftLeagueV1GetGrandmasterLeagueRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TftLeagueV1LeagueListDTO:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *TftLeagueV1GetGrandmasterLeagueBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TftLeagueV1GetGrandmasterLeagueUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TftLeagueV1GetGrandmasterLeagueForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TftLeagueV1GetGrandmasterLeagueNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TftLeagueV1GetGrandmasterLeagueMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TftLeagueV1GetGrandmasterLeagueUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TftLeagueV1GetGrandmasterLeagueTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TftLeagueV1GetGrandmasterLeagueInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TftLeagueV1GetGrandmasterLeagueBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TftLeagueV1GetGrandmasterLeagueServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TftLeagueV1GetGrandmasterLeagueGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTftLeagueV1GetLeagueByIdResponse(response TftLeagueV1GetLeagueByIdRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TftLeagueV1LeagueListDTO:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *TftLeagueV1GetLeagueByIdBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TftLeagueV1GetLeagueByIdUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TftLeagueV1GetLeagueByIdForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TftLeagueV1GetLeagueByIdNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TftLeagueV1GetLeagueByIdMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TftLeagueV1GetLeagueByIdUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TftLeagueV1GetLeagueByIdTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TftLeagueV1GetLeagueByIdInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TftLeagueV1GetLeagueByIdBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TftLeagueV1GetLeagueByIdServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TftLeagueV1GetLeagueByIdGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTftLeagueV1GetLeagueEntriesResponse(response TftLeagueV1GetLeagueEntriesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TftLeagueV1GetLeagueEntriesOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *TftLeagueV1GetLeagueEntriesBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TftLeagueV1GetLeagueEntriesUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TftLeagueV1GetLeagueEntriesForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TftLeagueV1GetLeagueEntriesNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TftLeagueV1GetLeagueEntriesMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TftLeagueV1GetLeagueEntriesUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TftLeagueV1GetLeagueEntriesTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TftLeagueV1GetLeagueEntriesInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TftLeagueV1GetLeagueEntriesBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TftLeagueV1GetLeagueEntriesServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TftLeagueV1GetLeagueEntriesGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTftLeagueV1GetLeagueEntriesByPUUIDResponse(response TftLeagueV1GetLeagueEntriesByPUUIDRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TftLeagueV1GetLeagueEntriesByPUUIDOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *TftLeagueV1GetLeagueEntriesByPUUIDBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TftLeagueV1GetLeagueEntriesByPUUIDUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TftLeagueV1GetLeagueEntriesByPUUIDForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TftLeagueV1GetLeagueEntriesByPUUIDNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TftLeagueV1GetLeagueEntriesByPUUIDMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TftLeagueV1GetLeagueEntriesByPUUIDUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TftLeagueV1GetLeagueEntriesByPUUIDTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TftLeagueV1GetLeagueEntriesByPUUIDInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TftLeagueV1GetLeagueEntriesByPUUIDBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TftLeagueV1GetLeagueEntriesByPUUIDServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TftLeagueV1GetLeagueEntriesByPUUIDGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTftLeagueV1GetMasterLeagueResponse(response TftLeagueV1GetMasterLeagueRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TftLeagueV1LeagueListDTO:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *TftLeagueV1GetMasterLeagueBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TftLeagueV1GetMasterLeagueUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TftLeagueV1GetMasterLeagueForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TftLeagueV1GetMasterLeagueNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TftLeagueV1GetMasterLeagueMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TftLeagueV1GetMasterLeagueUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TftLeagueV1GetMasterLeagueTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TftLeagueV1GetMasterLeagueInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TftLeagueV1GetMasterLeagueBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TftLeagueV1GetMasterLeagueServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TftLeagueV1GetMasterLeagueGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTftLeagueV1GetTopRatedLadderResponse(response TftLeagueV1GetTopRatedLadderRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TftLeagueV1GetTopRatedLadderOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *TftLeagueV1GetTopRatedLadderBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TftLeagueV1GetTopRatedLadderUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TftLeagueV1GetTopRatedLadderForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TftLeagueV1GetTopRatedLadderNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TftLeagueV1GetTopRatedLadderMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TftLeagueV1GetTopRatedLadderUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TftLeagueV1GetTopRatedLadderTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TftLeagueV1GetTopRatedLadderInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TftLeagueV1GetTopRatedLadderBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TftLeagueV1GetTopRatedLadderServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TftLeagueV1GetTopRatedLadderGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTftMatchV1GetMatchResponse(response TftMatchV1GetMatchRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TftMatchV1MatchDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *TftMatchV1GetMatchBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TftMatchV1GetMatchUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TftMatchV1GetMatchForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TftMatchV1GetMatchNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TftMatchV1GetMatchMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TftMatchV1GetMatchUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TftMatchV1GetMatchTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TftMatchV1GetMatchInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TftMatchV1GetMatchBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TftMatchV1GetMatchServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TftMatchV1GetMatchGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTftMatchV1GetMatchIdsByPUUIDResponse(response TftMatchV1GetMatchIdsByPUUIDRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TftMatchV1GetMatchIdsByPUUIDOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *TftMatchV1GetMatchIdsByPUUIDBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TftMatchV1GetMatchIdsByPUUIDUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TftMatchV1GetMatchIdsByPUUIDForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TftMatchV1GetMatchIdsByPUUIDNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TftMatchV1GetMatchIdsByPUUIDMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TftMatchV1GetMatchIdsByPUUIDUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TftMatchV1GetMatchIdsByPUUIDTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TftMatchV1GetMatchIdsByPUUIDInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TftMatchV1GetMatchIdsByPUUIDBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TftMatchV1GetMatchIdsByPUUIDServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TftMatchV1GetMatchIdsByPUUIDGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTftStatusV1GetPlatformDataResponse(response TftStatusV1GetPlatformDataRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TftStatusV1PlatformDataDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *TftStatusV1GetPlatformDataBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TftStatusV1GetPlatformDataUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TftStatusV1GetPlatformDataForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TftStatusV1GetPlatformDataNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TftStatusV1GetPlatformDataMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TftStatusV1GetPlatformDataUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TftStatusV1GetPlatformDataTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TftStatusV1GetPlatformDataInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TftStatusV1GetPlatformDataBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TftStatusV1GetPlatformDataServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TftStatusV1GetPlatformDataGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTftSummonerV1GetByAccessTokenResponse(response TftSummonerV1GetByAccessTokenRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TftSummonerV1SummonerDTO:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *TftSummonerV1GetByAccessTokenBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TftSummonerV1GetByAccessTokenUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TftSummonerV1GetByAccessTokenForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TftSummonerV1GetByAccessTokenNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TftSummonerV1GetByAccessTokenMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TftSummonerV1GetByAccessTokenUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TftSummonerV1GetByAccessTokenTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TftSummonerV1GetByAccessTokenInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TftSummonerV1GetByAccessTokenBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TftSummonerV1GetByAccessTokenServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TftSummonerV1GetByAccessTokenGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTftSummonerV1GetByPUUIDResponse(response TftSummonerV1GetByPUUIDRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TftSummonerV1SummonerDTO:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *TftSummonerV1GetByPUUIDBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TftSummonerV1GetByPUUIDUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TftSummonerV1GetByPUUIDForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TftSummonerV1GetByPUUIDNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TftSummonerV1GetByPUUIDMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TftSummonerV1GetByPUUIDUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TftSummonerV1GetByPUUIDTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TftSummonerV1GetByPUUIDInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TftSummonerV1GetByPUUIDBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TftSummonerV1GetByPUUIDServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TftSummonerV1GetByPUUIDGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTournamentStubV5CreateTournamentCodeResponse(response TournamentStubV5CreateTournamentCodeRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TournamentStubV5CreateTournamentCodeOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *TournamentStubV5CreateTournamentCodeBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TournamentStubV5CreateTournamentCodeUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TournamentStubV5CreateTournamentCodeForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TournamentStubV5CreateTournamentCodeNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TournamentStubV5CreateTournamentCodeMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TournamentStubV5CreateTournamentCodeUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TournamentStubV5CreateTournamentCodeTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TournamentStubV5CreateTournamentCodeInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TournamentStubV5CreateTournamentCodeBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TournamentStubV5CreateTournamentCodeServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TournamentStubV5CreateTournamentCodeGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTournamentStubV5GetLobbyEventsByCodeResponse(response TournamentStubV5GetLobbyEventsByCodeRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TournamentStubV5LobbyEventV5DTOWrapper:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *TournamentStubV5GetLobbyEventsByCodeBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TournamentStubV5GetLobbyEventsByCodeUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TournamentStubV5GetLobbyEventsByCodeForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TournamentStubV5GetLobbyEventsByCodeNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TournamentStubV5GetLobbyEventsByCodeMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TournamentStubV5GetLobbyEventsByCodeUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TournamentStubV5GetLobbyEventsByCodeTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TournamentStubV5GetLobbyEventsByCodeInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TournamentStubV5GetLobbyEventsByCodeBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TournamentStubV5GetLobbyEventsByCodeServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TournamentStubV5GetLobbyEventsByCodeGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTournamentStubV5GetTournamentCodeResponse(response TournamentStubV5GetTournamentCodeRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TournamentStubV5TournamentCodeV5DTO:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *TournamentStubV5GetTournamentCodeBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TournamentStubV5GetTournamentCodeUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TournamentStubV5GetTournamentCodeForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TournamentStubV5GetTournamentCodeNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TournamentStubV5GetTournamentCodeMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TournamentStubV5GetTournamentCodeUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TournamentStubV5GetTournamentCodeTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TournamentStubV5GetTournamentCodeInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TournamentStubV5GetTournamentCodeBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TournamentStubV5GetTournamentCodeServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TournamentStubV5GetTournamentCodeGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTournamentStubV5RegisterProviderDataResponse(response TournamentStubV5RegisterProviderDataRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TournamentStubV5RegisterProviderDataOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *TournamentStubV5RegisterProviderDataBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TournamentStubV5RegisterProviderDataUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TournamentStubV5RegisterProviderDataForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TournamentStubV5RegisterProviderDataNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TournamentStubV5RegisterProviderDataMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TournamentStubV5RegisterProviderDataUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TournamentStubV5RegisterProviderDataTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TournamentStubV5RegisterProviderDataInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TournamentStubV5RegisterProviderDataBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TournamentStubV5RegisterProviderDataServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TournamentStubV5RegisterProviderDataGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTournamentStubV5RegisterTournamentResponse(response TournamentStubV5RegisterTournamentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TournamentStubV5RegisterTournamentOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *TournamentStubV5RegisterTournamentBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TournamentStubV5RegisterTournamentUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TournamentStubV5RegisterTournamentForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TournamentStubV5RegisterTournamentNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TournamentStubV5RegisterTournamentMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TournamentStubV5RegisterTournamentUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TournamentStubV5RegisterTournamentTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TournamentStubV5RegisterTournamentInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TournamentStubV5RegisterTournamentBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TournamentStubV5RegisterTournamentServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TournamentStubV5RegisterTournamentGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTournamentV5CreateTournamentCodeResponse(response TournamentV5CreateTournamentCodeRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TournamentV5CreateTournamentCodeOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *TournamentV5CreateTournamentCodeBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TournamentV5CreateTournamentCodeUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TournamentV5CreateTournamentCodeForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TournamentV5CreateTournamentCodeNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TournamentV5CreateTournamentCodeMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TournamentV5CreateTournamentCodeUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TournamentV5CreateTournamentCodeTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TournamentV5CreateTournamentCodeInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TournamentV5CreateTournamentCodeBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TournamentV5CreateTournamentCodeServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TournamentV5CreateTournamentCodeGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTournamentV5GetGamesResponse(response TournamentV5GetGamesRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TournamentV5GetGamesOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *TournamentV5GetGamesBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TournamentV5GetGamesUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TournamentV5GetGamesForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TournamentV5GetGamesNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TournamentV5GetGamesMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TournamentV5GetGamesUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TournamentV5GetGamesTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TournamentV5GetGamesInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TournamentV5GetGamesBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TournamentV5GetGamesServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TournamentV5GetGamesGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTournamentV5GetLobbyEventsByCodeResponse(response TournamentV5GetLobbyEventsByCodeRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TournamentV5LobbyEventV5DTOWrapper:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *TournamentV5GetLobbyEventsByCodeBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TournamentV5GetLobbyEventsByCodeUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TournamentV5GetLobbyEventsByCodeForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TournamentV5GetLobbyEventsByCodeNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TournamentV5GetLobbyEventsByCodeMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TournamentV5GetLobbyEventsByCodeUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TournamentV5GetLobbyEventsByCodeTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TournamentV5GetLobbyEventsByCodeInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TournamentV5GetLobbyEventsByCodeBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TournamentV5GetLobbyEventsByCodeServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TournamentV5GetLobbyEventsByCodeGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTournamentV5GetTournamentCodeResponse(response TournamentV5GetTournamentCodeRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TournamentV5TournamentCodeV5DTO:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *TournamentV5GetTournamentCodeBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TournamentV5GetTournamentCodeUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TournamentV5GetTournamentCodeForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TournamentV5GetTournamentCodeNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TournamentV5GetTournamentCodeMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TournamentV5GetTournamentCodeUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TournamentV5GetTournamentCodeTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TournamentV5GetTournamentCodeInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TournamentV5GetTournamentCodeBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TournamentV5GetTournamentCodeServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TournamentV5GetTournamentCodeGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTournamentV5RegisterProviderDataResponse(response TournamentV5RegisterProviderDataRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TournamentV5RegisterProviderDataOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *TournamentV5RegisterProviderDataBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TournamentV5RegisterProviderDataUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TournamentV5RegisterProviderDataForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TournamentV5RegisterProviderDataNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TournamentV5RegisterProviderDataMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TournamentV5RegisterProviderDataUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TournamentV5RegisterProviderDataTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TournamentV5RegisterProviderDataInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TournamentV5RegisterProviderDataBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TournamentV5RegisterProviderDataServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TournamentV5RegisterProviderDataGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTournamentV5RegisterTournamentResponse(response TournamentV5RegisterTournamentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TournamentV5RegisterTournamentOKApplicationJSON:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *TournamentV5RegisterTournamentBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TournamentV5RegisterTournamentUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TournamentV5RegisterTournamentForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TournamentV5RegisterTournamentNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TournamentV5RegisterTournamentMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TournamentV5RegisterTournamentUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TournamentV5RegisterTournamentTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TournamentV5RegisterTournamentInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TournamentV5RegisterTournamentBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TournamentV5RegisterTournamentServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TournamentV5RegisterTournamentGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeTournamentV5UpdateCodeResponse(response TournamentV5UpdateCodeRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *TournamentV5UpdateCodeOK:
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		return nil

	case *TournamentV5UpdateCodeBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *TournamentV5UpdateCodeUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *TournamentV5UpdateCodeForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *TournamentV5UpdateCodeNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *TournamentV5UpdateCodeMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *TournamentV5UpdateCodeUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *TournamentV5UpdateCodeTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *TournamentV5UpdateCodeInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *TournamentV5UpdateCodeBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *TournamentV5UpdateCodeServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *TournamentV5UpdateCodeGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeValConsoleMatchV1GetMatchResponse(response ValConsoleMatchV1GetMatchRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ValConsoleMatchV1MatchDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ValConsoleMatchV1GetMatchBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *ValConsoleMatchV1GetMatchUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *ValConsoleMatchV1GetMatchForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *ValConsoleMatchV1GetMatchNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *ValConsoleMatchV1GetMatchMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *ValConsoleMatchV1GetMatchUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *ValConsoleMatchV1GetMatchTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *ValConsoleMatchV1GetMatchInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *ValConsoleMatchV1GetMatchBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *ValConsoleMatchV1GetMatchServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *ValConsoleMatchV1GetMatchGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeValConsoleMatchV1GetMatchlistResponse(response ValConsoleMatchV1GetMatchlistRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ValConsoleMatchV1MatchlistDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ValConsoleMatchV1GetMatchlistBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *ValConsoleMatchV1GetMatchlistUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *ValConsoleMatchV1GetMatchlistForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *ValConsoleMatchV1GetMatchlistNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *ValConsoleMatchV1GetMatchlistMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *ValConsoleMatchV1GetMatchlistUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *ValConsoleMatchV1GetMatchlistTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *ValConsoleMatchV1GetMatchlistInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *ValConsoleMatchV1GetMatchlistBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *ValConsoleMatchV1GetMatchlistServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *ValConsoleMatchV1GetMatchlistGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeValConsoleMatchV1GetRecentResponse(response ValConsoleMatchV1GetRecentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ValConsoleMatchV1RecentMatchesDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ValConsoleMatchV1GetRecentBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *ValConsoleMatchV1GetRecentUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *ValConsoleMatchV1GetRecentForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *ValConsoleMatchV1GetRecentNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *ValConsoleMatchV1GetRecentMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *ValConsoleMatchV1GetRecentUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *ValConsoleMatchV1GetRecentTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *ValConsoleMatchV1GetRecentInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *ValConsoleMatchV1GetRecentBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *ValConsoleMatchV1GetRecentServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *ValConsoleMatchV1GetRecentGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeValConsoleRankedV1GetLeaderboardResponse(response ValConsoleRankedV1GetLeaderboardRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ValConsoleRankedV1LeaderboardDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ValConsoleRankedV1GetLeaderboardBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *ValConsoleRankedV1GetLeaderboardUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *ValConsoleRankedV1GetLeaderboardForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *ValConsoleRankedV1GetLeaderboardNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *ValConsoleRankedV1GetLeaderboardMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *ValConsoleRankedV1GetLeaderboardUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *ValConsoleRankedV1GetLeaderboardTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *ValConsoleRankedV1GetLeaderboardInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *ValConsoleRankedV1GetLeaderboardBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *ValConsoleRankedV1GetLeaderboardServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *ValConsoleRankedV1GetLeaderboardGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeValContentV1GetContentResponse(response ValContentV1GetContentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ValContentV1ContentDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ValContentV1GetContentBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *ValContentV1GetContentUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *ValContentV1GetContentForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *ValContentV1GetContentNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *ValContentV1GetContentMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *ValContentV1GetContentUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *ValContentV1GetContentTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *ValContentV1GetContentInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *ValContentV1GetContentBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *ValContentV1GetContentServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *ValContentV1GetContentGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeValMatchV1GetMatchResponse(response ValMatchV1GetMatchRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ValMatchV1MatchDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ValMatchV1GetMatchBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *ValMatchV1GetMatchUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *ValMatchV1GetMatchForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *ValMatchV1GetMatchNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *ValMatchV1GetMatchMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *ValMatchV1GetMatchUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *ValMatchV1GetMatchTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *ValMatchV1GetMatchInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *ValMatchV1GetMatchBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *ValMatchV1GetMatchServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *ValMatchV1GetMatchGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeValMatchV1GetMatchlistResponse(response ValMatchV1GetMatchlistRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ValMatchV1MatchlistDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ValMatchV1GetMatchlistBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *ValMatchV1GetMatchlistUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *ValMatchV1GetMatchlistForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *ValMatchV1GetMatchlistNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *ValMatchV1GetMatchlistMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *ValMatchV1GetMatchlistUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *ValMatchV1GetMatchlistTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *ValMatchV1GetMatchlistInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *ValMatchV1GetMatchlistBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *ValMatchV1GetMatchlistServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *ValMatchV1GetMatchlistGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeValMatchV1GetRecentResponse(response ValMatchV1GetRecentRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ValMatchV1RecentMatchesDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ValMatchV1GetRecentBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *ValMatchV1GetRecentUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *ValMatchV1GetRecentForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *ValMatchV1GetRecentNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *ValMatchV1GetRecentMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *ValMatchV1GetRecentUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *ValMatchV1GetRecentTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *ValMatchV1GetRecentInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *ValMatchV1GetRecentBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *ValMatchV1GetRecentServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *ValMatchV1GetRecentGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeValRankedV1GetLeaderboardResponse(response ValRankedV1GetLeaderboardRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ValRankedV1LeaderboardDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ValRankedV1GetLeaderboardBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *ValRankedV1GetLeaderboardUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *ValRankedV1GetLeaderboardForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *ValRankedV1GetLeaderboardNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *ValRankedV1GetLeaderboardMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *ValRankedV1GetLeaderboardUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *ValRankedV1GetLeaderboardTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *ValRankedV1GetLeaderboardInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *ValRankedV1GetLeaderboardBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *ValRankedV1GetLeaderboardServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *ValRankedV1GetLeaderboardGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}

func encodeValStatusV1GetPlatformDataResponse(response ValStatusV1GetPlatformDataRes, w http.ResponseWriter, span trace.Span) error {
	switch response := response.(type) {
	case *ValStatusV1PlatformDataDto:
		w.Header().Set("Content-Type", "application/json; charset=utf-8")
		w.WriteHeader(200)
		span.SetStatus(codes.Ok, http.StatusText(200))

		e := new(jx.Encoder)
		response.Encode(e)
		if _, err := e.WriteTo(w); err != nil {
			return errors.Wrap(err, "write")
		}

		return nil

	case *ValStatusV1GetPlatformDataBadRequest:
		w.WriteHeader(400)
		span.SetStatus(codes.Error, http.StatusText(400))

		return nil

	case *ValStatusV1GetPlatformDataUnauthorized:
		w.WriteHeader(401)
		span.SetStatus(codes.Error, http.StatusText(401))

		return nil

	case *ValStatusV1GetPlatformDataForbidden:
		w.WriteHeader(403)
		span.SetStatus(codes.Error, http.StatusText(403))

		return nil

	case *ValStatusV1GetPlatformDataNotFound:
		w.WriteHeader(404)
		span.SetStatus(codes.Error, http.StatusText(404))

		return nil

	case *ValStatusV1GetPlatformDataMethodNotAllowed:
		w.WriteHeader(405)
		span.SetStatus(codes.Error, http.StatusText(405))

		return nil

	case *ValStatusV1GetPlatformDataUnsupportedMediaType:
		w.WriteHeader(415)
		span.SetStatus(codes.Error, http.StatusText(415))

		return nil

	case *ValStatusV1GetPlatformDataTooManyRequests:
		w.WriteHeader(429)
		span.SetStatus(codes.Error, http.StatusText(429))

		return nil

	case *ValStatusV1GetPlatformDataInternalServerError:
		w.WriteHeader(500)
		span.SetStatus(codes.Error, http.StatusText(500))

		return nil

	case *ValStatusV1GetPlatformDataBadGateway:
		w.WriteHeader(502)
		span.SetStatus(codes.Error, http.StatusText(502))

		return nil

	case *ValStatusV1GetPlatformDataServiceUnavailable:
		w.WriteHeader(503)
		span.SetStatus(codes.Error, http.StatusText(503))

		return nil

	case *ValStatusV1GetPlatformDataGatewayTimeout:
		w.WriteHeader(504)
		span.SetStatus(codes.Error, http.StatusText(504))

		return nil

	default:
		return errors.Errorf("unexpected response type: %T", response)
	}
}
