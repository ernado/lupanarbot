// Code generated by ogen, DO NOT EDIT.

package oas

import (
	"net/http"
	"net/url"
	"strings"

	"github.com/ogen-go/ogen/uri"
)

func (s *Server) cutPrefix(path string) (string, bool) {
	prefix := s.cfg.Prefix
	if prefix == "" {
		return path, true
	}
	if !strings.HasPrefix(path, prefix) {
		// Prefix doesn't match.
		return "", false
	}
	// Cut prefix from the path.
	return strings.TrimPrefix(path, prefix), true
}

// ServeHTTP serves http request as defined by OpenAPI v3 specification,
// calling handler that matches the path or returning not found error.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	elem := r.URL.Path
	elemIsEscaped := false
	if rawPath := r.URL.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
			elemIsEscaped = strings.ContainsRune(elem, '%')
		}
	}

	elem, ok := s.cutPrefix(elem)
	if !ok || len(elem) == 0 {
		s.notFound(w, r)
		return
	}
	args := [3]string{}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"

			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'l': // Prefix: "lo"

				if l := len("lo"); len(elem) >= l && elem[0:l] == "lo" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'l': // Prefix: "l/"

					if l := len("l/"); len(elem) >= l && elem[0:l] == "l/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "c"

						if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'h': // Prefix: "ha"

							if l := len("ha"); len(elem) >= l && elem[0:l] == "ha" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'l': // Prefix: "llenges/v1/"

								if l := len("llenges/v1/"); len(elem) >= l && elem[0:l] == "llenges/v1/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "challenges/"

									if l := len("challenges/"); len(elem) >= l && elem[0:l] == "challenges/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'c': // Prefix: "config"
										origElem := elem
										if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleLolChallengesV1GetAllChallengeConfigsRequest([0]string{}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

										elem = origElem
									case 'p': // Prefix: "percentiles"
										origElem := elem
										if l := len("percentiles"); len(elem) >= l && elem[0:l] == "percentiles" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleLolChallengesV1GetAllChallengePercentilesRequest([0]string{}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

										elem = origElem
									}
									// Param: "challengeId"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'c': // Prefix: "config"

											if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleLolChallengesV1GetChallengeConfigsRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}

										case 'l': // Prefix: "leaderboards/by-level/"

											if l := len("leaderboards/by-level/"); len(elem) >= l && elem[0:l] == "leaderboards/by-level/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "level"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleLolChallengesV1GetChallengeLeaderboardsRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}

										case 'p': // Prefix: "percentiles"

											if l := len("percentiles"); len(elem) >= l && elem[0:l] == "percentiles" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleLolChallengesV1GetChallengePercentilesRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}

										}

									}

								case 'p': // Prefix: "player-data/"

									if l := len("player-data/"); len(elem) >= l && elem[0:l] == "player-data/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "puuid"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleLolChallengesV1GetPlayerDataRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							case 'm': // Prefix: "mpion-mastery/v4/"

								if l := len("mpion-mastery/v4/"); len(elem) >= l && elem[0:l] == "mpion-mastery/v4/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "champion-masteries/by-puuid/"

									if l := len("champion-masteries/by-puuid/"); len(elem) >= l && elem[0:l] == "champion-masteries/by-puuid/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "encryptedPUUID"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleChampionMasteryV4GetAllChampionMasteriesByPUUIDRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'b': // Prefix: "by-champion/"

											if l := len("by-champion/"); len(elem) >= l && elem[0:l] == "by-champion/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "championId"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleChampionMasteryV4GetChampionMasteryByPUUIDRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}

										case 't': // Prefix: "top"

											if l := len("top"); len(elem) >= l && elem[0:l] == "top" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleChampionMasteryV4GetTopChampionMasteriesByPUUIDRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}

										}

									}

								case 's': // Prefix: "scores/by-puuid/"

									if l := len("scores/by-puuid/"); len(elem) >= l && elem[0:l] == "scores/by-puuid/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "encryptedPUUID"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleChampionMasteryV4GetChampionMasteryScoreByPUUIDRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							}

						case 'l': // Prefix: "lash/v1/"

							if l := len("lash/v1/"); len(elem) >= l && elem[0:l] == "lash/v1/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'p': // Prefix: "players/by-puuid/"

								if l := len("players/by-puuid/"); len(elem) >= l && elem[0:l] == "players/by-puuid/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "puuid"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleClashV1GetPlayersByPUUIDRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 't': // Prefix: "t"

								if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "eams/"

									if l := len("eams/"); len(elem) >= l && elem[0:l] == "eams/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "teamId"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleClashV1GetTeamByIdRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 'o': // Prefix: "ournaments"

									if l := len("ournaments"); len(elem) >= l && elem[0:l] == "ournaments" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleClashV1GetTournamentsRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'b': // Prefix: "by-team/"
											origElem := elem
											if l := len("by-team/"); len(elem) >= l && elem[0:l] == "by-team/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "teamId"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[0] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleClashV1GetTournamentByTeamRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}

											elem = origElem
										}
										// Param: "tournamentId"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[0] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleClashV1GetTournamentByIdRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									}

								}

							}

						}

					case 'l': // Prefix: "league"

						if l := len("league"); len(elem) >= l && elem[0:l] == "league" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '-': // Prefix: "-exp/v4/entries/"

							if l := len("-exp/v4/entries/"); len(elem) >= l && elem[0:l] == "-exp/v4/entries/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "queue"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "tier"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "division"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleLeagueExpV4GetLeagueEntriesRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							}

						case '/': // Prefix: "/v4/"

							if l := len("/v4/"); len(elem) >= l && elem[0:l] == "/v4/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "challengerleagues/by-queue/"

								if l := len("challengerleagues/by-queue/"); len(elem) >= l && elem[0:l] == "challengerleagues/by-queue/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "queue"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleLeagueV4GetChallengerLeagueRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'e': // Prefix: "entries/"

								if l := len("entries/"); len(elem) >= l && elem[0:l] == "entries/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'b': // Prefix: "by-puuid/"
									origElem := elem
									if l := len("by-puuid/"); len(elem) >= l && elem[0:l] == "by-puuid/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "encryptedPUUID"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleLeagueV4GetLeagueEntriesByPUUIDRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

									elem = origElem
								}
								// Param: "queue"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "tier"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "division"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleLeagueV4GetLeagueEntriesRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									}

								}

							case 'g': // Prefix: "grandmasterleagues/by-queue/"

								if l := len("grandmasterleagues/by-queue/"); len(elem) >= l && elem[0:l] == "grandmasterleagues/by-queue/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "queue"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleLeagueV4GetGrandmasterLeagueRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'l': // Prefix: "leagues/"

								if l := len("leagues/"); len(elem) >= l && elem[0:l] == "leagues/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "leagueId"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleLeagueV4GetLeagueByIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'm': // Prefix: "masterleagues/by-queue/"

								if l := len("masterleagues/by-queue/"); len(elem) >= l && elem[0:l] == "masterleagues/by-queue/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "queue"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleLeagueV4GetMasterLeagueRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							}

						}

					case 'm': // Prefix: "match/v5/matches/"

						if l := len("match/v5/matches/"); len(elem) >= l && elem[0:l] == "match/v5/matches/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'b': // Prefix: "by-puuid/"
							origElem := elem
							if l := len("by-puuid/"); len(elem) >= l && elem[0:l] == "by-puuid/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "puuid"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/ids"

								if l := len("/ids"); len(elem) >= l && elem[0:l] == "/ids" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleMatchV5GetMatchIdsByPUUIDRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							}

							elem = origElem
						}
						// Param: "matchId"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleMatchV5GetMatchRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/timeline"

							if l := len("/timeline"); len(elem) >= l && elem[0:l] == "/timeline" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleMatchV5GetTimelineRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					case 'p': // Prefix: "platform/v3/champion-rotations"

						if l := len("platform/v3/champion-rotations"); len(elem) >= l && elem[0:l] == "platform/v3/champion-rotations" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleChampionV3GetChampionInfoRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 'r': // Prefix: "rso-match/v1/matches/"

						if l := len("rso-match/v1/matches/"); len(elem) >= l && elem[0:l] == "rso-match/v1/matches/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'i': // Prefix: "ids"
							origElem := elem
							if l := len("ids"); len(elem) >= l && elem[0:l] == "ids" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleLolRsoMatchV1GetMatchIdsRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

							elem = origElem
						}
						// Param: "matchId"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleLolRsoMatchV1GetMatchRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/timeline"

							if l := len("/timeline"); len(elem) >= l && elem[0:l] == "/timeline" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleLolRsoMatchV1GetTimelineRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					case 's': // Prefix: "s"

						if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'p': // Prefix: "pectator/"

							if l := len("pectator/"); len(elem) >= l && elem[0:l] == "pectator/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 't': // Prefix: "tft/v5/"

								if l := len("tft/v5/"); len(elem) >= l && elem[0:l] == "tft/v5/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "active-games/by-puuid/"

									if l := len("active-games/by-puuid/"); len(elem) >= l && elem[0:l] == "active-games/by-puuid/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "encryptedPUUID"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleSpectatorTftV5GetCurrentGameInfoByPuuidRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 'f': // Prefix: "featured-games"

									if l := len("featured-games"); len(elem) >= l && elem[0:l] == "featured-games" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleSpectatorTftV5GetFeaturedGamesRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							case 'v': // Prefix: "v5/"

								if l := len("v5/"); len(elem) >= l && elem[0:l] == "v5/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "active-games/by-summoner/"

									if l := len("active-games/by-summoner/"); len(elem) >= l && elem[0:l] == "active-games/by-summoner/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "encryptedPUUID"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleSpectatorV5GetCurrentGameInfoByPuuidRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 'f': // Prefix: "featured-games"

									if l := len("featured-games"); len(elem) >= l && elem[0:l] == "featured-games" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleSpectatorV5GetFeaturedGamesRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							}

						case 't': // Prefix: "tatus/v4/platform-data"

							if l := len("tatus/v4/platform-data"); len(elem) >= l && elem[0:l] == "tatus/v4/platform-data" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleLolStatusV4GetPlatformDataRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						case 'u': // Prefix: "ummoner/v4/summoners/"

							if l := len("ummoner/v4/summoners/"); len(elem) >= l && elem[0:l] == "ummoner/v4/summoners/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'b': // Prefix: "by-puuid/"

								if l := len("by-puuid/"); len(elem) >= l && elem[0:l] == "by-puuid/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "encryptedPUUID"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleSummonerV4GetByPUUIDRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'm': // Prefix: "me"

								if l := len("me"); len(elem) >= l && elem[0:l] == "me" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleSummonerV4GetByAccessTokenRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							}

						}

					case 't': // Prefix: "tournament"

						if l := len("tournament"); len(elem) >= l && elem[0:l] == "tournament" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '-': // Prefix: "-stub/v5/"

							if l := len("-stub/v5/"); len(elem) >= l && elem[0:l] == "-stub/v5/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "codes"

								if l := len("codes"); len(elem) >= l && elem[0:l] == "codes" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "POST":
										s.handleTournamentStubV5CreateTournamentCodeRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "tournamentCode"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleTournamentStubV5GetTournamentCodeRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							case 'l': // Prefix: "lobby-events/by-code/"

								if l := len("lobby-events/by-code/"); len(elem) >= l && elem[0:l] == "lobby-events/by-code/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "tournamentCode"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleTournamentStubV5GetLobbyEventsByCodeRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'p': // Prefix: "providers"

								if l := len("providers"); len(elem) >= l && elem[0:l] == "providers" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleTournamentStubV5RegisterProviderDataRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							case 't': // Prefix: "tournaments"

								if l := len("tournaments"); len(elem) >= l && elem[0:l] == "tournaments" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleTournamentStubV5RegisterTournamentRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							}

						case '/': // Prefix: "/v5/"

							if l := len("/v5/"); len(elem) >= l && elem[0:l] == "/v5/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "codes"

								if l := len("codes"); len(elem) >= l && elem[0:l] == "codes" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "POST":
										s.handleTournamentV5CreateTournamentCodeRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "tournamentCode"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleTournamentV5GetTournamentCodeRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										case "PUT":
											s.handleTournamentV5UpdateCodeRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET,PUT")
										}

										return
									}

								}

							case 'g': // Prefix: "games/by-code/"

								if l := len("games/by-code/"); len(elem) >= l && elem[0:l] == "games/by-code/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "tournamentCode"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleTournamentV5GetGamesRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'l': // Prefix: "lobby-events/by-code/"

								if l := len("lobby-events/by-code/"); len(elem) >= l && elem[0:l] == "lobby-events/by-code/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "tournamentCode"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleTournamentV5GetLobbyEventsByCodeRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'p': // Prefix: "providers"

								if l := len("providers"); len(elem) >= l && elem[0:l] == "providers" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleTournamentV5RegisterProviderDataRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							case 't': // Prefix: "tournaments"

								if l := len("tournaments"); len(elem) >= l && elem[0:l] == "tournaments" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleTournamentV5RegisterTournamentRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							}

						}

					}

				case 'r': // Prefix: "r/"

					if l := len("r/"); len(elem) >= l && elem[0:l] == "r/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'd': // Prefix: "deck/v1/decks/me"

						if l := len("deck/v1/decks/me"); len(elem) >= l && elem[0:l] == "deck/v1/decks/me" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleLorDeckV1GetDecksRequest([0]string{}, elemIsEscaped, w, r)
							case "POST":
								s.handleLorDeckV1CreateDeckRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}

					case 'i': // Prefix: "inventory/v1/cards/me"

						if l := len("inventory/v1/cards/me"); len(elem) >= l && elem[0:l] == "inventory/v1/cards/me" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleLorInventoryV1GetCardsRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 'm': // Prefix: "match/v1/matches/"

						if l := len("match/v1/matches/"); len(elem) >= l && elem[0:l] == "match/v1/matches/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'b': // Prefix: "by-puuid/"
							origElem := elem
							if l := len("by-puuid/"); len(elem) >= l && elem[0:l] == "by-puuid/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "puuid"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/ids"

								if l := len("/ids"); len(elem) >= l && elem[0:l] == "/ids" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleLorMatchV1GetMatchIdsByPUUIDRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							}

							elem = origElem
						}
						// Param: "matchId"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleLorMatchV1GetMatchRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 'r': // Prefix: "ranked/v1/leaderboards"

						if l := len("ranked/v1/leaderboards"); len(elem) >= l && elem[0:l] == "ranked/v1/leaderboards" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleLorRankedV1GetLeaderboardsRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 's': // Prefix: "status/v1/platform-data"

						if l := len("status/v1/platform-data"); len(elem) >= l && elem[0:l] == "status/v1/platform-data" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleLorStatusV1GetPlatformDataRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					}

				}

			case 'r': // Prefix: "riot/account/v1/"

				if l := len("riot/account/v1/"); len(elem) >= l && elem[0:l] == "riot/account/v1/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "ac"

					if l := len("ac"); len(elem) >= l && elem[0:l] == "ac" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "counts/"

						if l := len("counts/"); len(elem) >= l && elem[0:l] == "counts/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'b': // Prefix: "by-"

							if l := len("by-"); len(elem) >= l && elem[0:l] == "by-" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'p': // Prefix: "puuid/"

								if l := len("puuid/"); len(elem) >= l && elem[0:l] == "puuid/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "puuid"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleAccountV1GetByPuuidRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'r': // Prefix: "riot-id/"

								if l := len("riot-id/"); len(elem) >= l && elem[0:l] == "riot-id/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "gameName"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "tagLine"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleAccountV1GetByRiotIdRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							}

						case 'm': // Prefix: "me"

							if l := len("me"); len(elem) >= l && elem[0:l] == "me" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleAccountV1GetByAccessTokenRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					case 't': // Prefix: "tive-shards/by-game/"

						if l := len("tive-shards/by-game/"); len(elem) >= l && elem[0:l] == "tive-shards/by-game/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "game"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/by-puuid/"

							if l := len("/by-puuid/"); len(elem) >= l && elem[0:l] == "/by-puuid/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "puuid"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleAccountV1GetActiveShardRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					}

				case 'r': // Prefix: "region/by-game/"

					if l := len("region/by-game/"); len(elem) >= l && elem[0:l] == "region/by-game/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "game"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/by-puuid/"

						if l := len("/by-puuid/"); len(elem) >= l && elem[0:l] == "/by-puuid/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "puuid"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleAccountV1GetActiveRegionRequest([2]string{
									args[0],
									args[1],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					}

				}

			case 't': // Prefix: "tft/"

				if l := len("tft/"); len(elem) >= l && elem[0:l] == "tft/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'l': // Prefix: "league/v1/"

					if l := len("league/v1/"); len(elem) >= l && elem[0:l] == "league/v1/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'b': // Prefix: "by-puuid/"

						if l := len("by-puuid/"); len(elem) >= l && elem[0:l] == "by-puuid/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "puuid"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleTftLeagueV1GetLeagueEntriesByPUUIDRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 'c': // Prefix: "challenger"

						if l := len("challenger"); len(elem) >= l && elem[0:l] == "challenger" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleTftLeagueV1GetChallengerLeagueRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 'e': // Prefix: "entries/"

						if l := len("entries/"); len(elem) >= l && elem[0:l] == "entries/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "tier"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "division"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleTftLeagueV1GetLeagueEntriesRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					case 'g': // Prefix: "grandmaster"

						if l := len("grandmaster"); len(elem) >= l && elem[0:l] == "grandmaster" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleTftLeagueV1GetGrandmasterLeagueRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 'l': // Prefix: "leagues/"

						if l := len("leagues/"); len(elem) >= l && elem[0:l] == "leagues/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "leagueId"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleTftLeagueV1GetLeagueByIdRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 'm': // Prefix: "master"

						if l := len("master"); len(elem) >= l && elem[0:l] == "master" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleTftLeagueV1GetMasterLeagueRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 'r': // Prefix: "rated-ladders/"

						if l := len("rated-ladders/"); len(elem) >= l && elem[0:l] == "rated-ladders/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "queue"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/top"

							if l := len("/top"); len(elem) >= l && elem[0:l] == "/top" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleTftLeagueV1GetTopRatedLadderRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					}

				case 'm': // Prefix: "match/v1/matches/"

					if l := len("match/v1/matches/"); len(elem) >= l && elem[0:l] == "match/v1/matches/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'b': // Prefix: "by-puuid/"
						origElem := elem
						if l := len("by-puuid/"); len(elem) >= l && elem[0:l] == "by-puuid/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "puuid"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/ids"

							if l := len("/ids"); len(elem) >= l && elem[0:l] == "/ids" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleTftMatchV1GetMatchIdsByPUUIDRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

						elem = origElem
					}
					// Param: "matchId"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleTftMatchV1GetMatchRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				case 's': // Prefix: "s"

					if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 't': // Prefix: "tatus/v1/platform-data"

						if l := len("tatus/v1/platform-data"); len(elem) >= l && elem[0:l] == "tatus/v1/platform-data" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleTftStatusV1GetPlatformDataRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 'u': // Prefix: "ummoner/v1/summoners/"

						if l := len("ummoner/v1/summoners/"); len(elem) >= l && elem[0:l] == "ummoner/v1/summoners/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'b': // Prefix: "by-puuid/"

							if l := len("by-puuid/"); len(elem) >= l && elem[0:l] == "by-puuid/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "encryptedPUUID"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleTftSummonerV1GetByPUUIDRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						case 'm': // Prefix: "me"

							if l := len("me"); len(elem) >= l && elem[0:l] == "me" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleTftSummonerV1GetByAccessTokenRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					}

				}

			case 'v': // Prefix: "val/"

				if l := len("val/"); len(elem) >= l && elem[0:l] == "val/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "con"

					if l := len("con"); len(elem) >= l && elem[0:l] == "con" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 's': // Prefix: "sole/ranked/v1/leaderboards/by-act/"

						if l := len("sole/ranked/v1/leaderboards/by-act/"); len(elem) >= l && elem[0:l] == "sole/ranked/v1/leaderboards/by-act/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "actId"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleValConsoleRankedV1GetLeaderboardRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					case 't': // Prefix: "tent/v1/contents"

						if l := len("tent/v1/contents"); len(elem) >= l && elem[0:l] == "tent/v1/contents" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleValContentV1GetContentRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

					}

				case 'm': // Prefix: "match/"

					if l := len("match/"); len(elem) >= l && elem[0:l] == "match/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "console/v1/"

						if l := len("console/v1/"); len(elem) >= l && elem[0:l] == "console/v1/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'm': // Prefix: "match"

							if l := len("match"); len(elem) >= l && elem[0:l] == "match" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "es/"

								if l := len("es/"); len(elem) >= l && elem[0:l] == "es/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "matchId"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleValConsoleMatchV1GetMatchRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'l': // Prefix: "lists/by-puuid/"

								if l := len("lists/by-puuid/"); len(elem) >= l && elem[0:l] == "lists/by-puuid/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "puuid"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleValConsoleMatchV1GetMatchlistRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							}

						case 'r': // Prefix: "recent-matches/by-queue/"

							if l := len("recent-matches/by-queue/"); len(elem) >= l && elem[0:l] == "recent-matches/by-queue/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "queue"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleValConsoleMatchV1GetRecentRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					case 'v': // Prefix: "v1/"

						if l := len("v1/"); len(elem) >= l && elem[0:l] == "v1/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'm': // Prefix: "match"

							if l := len("match"); len(elem) >= l && elem[0:l] == "match" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "es/"

								if l := len("es/"); len(elem) >= l && elem[0:l] == "es/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "matchId"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleValMatchV1GetMatchRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'l': // Prefix: "lists/by-puuid/"

								if l := len("lists/by-puuid/"); len(elem) >= l && elem[0:l] == "lists/by-puuid/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "puuid"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleValMatchV1GetMatchlistRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							}

						case 'r': // Prefix: "recent-matches/by-queue/"

							if l := len("recent-matches/by-queue/"); len(elem) >= l && elem[0:l] == "recent-matches/by-queue/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "queue"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleValMatchV1GetRecentRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					}

				case 'r': // Prefix: "ranked/v1/leaderboards/by-act/"

					if l := len("ranked/v1/leaderboards/by-act/"); len(elem) >= l && elem[0:l] == "ranked/v1/leaderboards/by-act/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "actId"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleValRankedV1GetLeaderboardRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				case 's': // Prefix: "status/v1/platform-data"

					if l := len("status/v1/platform-data"); len(elem) >= l && elem[0:l] == "status/v1/platform-data" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleValStatusV1GetPlatformDataRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				}

			}

		}
	}
	s.notFound(w, r)
}

// Route is route object.
type Route struct {
	name        string
	summary     string
	operationID string
	pathPattern string
	count       int
	args        [3]string
}

// Name returns ogen operation name.
//
// It is guaranteed to be unique and not empty.
func (r Route) Name() string {
	return r.name
}

// Summary returns OpenAPI summary.
func (r Route) Summary() string {
	return r.summary
}

// OperationID returns OpenAPI operationId.
func (r Route) OperationID() string {
	return r.operationID
}

// PathPattern returns OpenAPI path.
func (r Route) PathPattern() string {
	return r.pathPattern
}

// Args returns parsed arguments.
func (r Route) Args() []string {
	return r.args[:r.count]
}

// FindRoute finds Route for given method and path.
//
// Note: this method does not unescape path or handle reserved characters in path properly. Use FindPath instead.
func (s *Server) FindRoute(method, path string) (Route, bool) {
	return s.FindPath(method, &url.URL{Path: path})
}

// FindPath finds Route for given method and URL.
func (s *Server) FindPath(method string, u *url.URL) (r Route, _ bool) {
	var (
		elem = u.Path
		args = r.args
	)
	if rawPath := u.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
		}
		defer func() {
			for i, arg := range r.args[:r.count] {
				if unescaped, err := url.PathUnescape(arg); err == nil {
					r.args[i] = unescaped
				}
			}
		}()
	}

	elem, ok := s.cutPrefix(elem)
	if !ok {
		return r, false
	}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"

			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'l': // Prefix: "lo"

				if l := len("lo"); len(elem) >= l && elem[0:l] == "lo" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'l': // Prefix: "l/"

					if l := len("l/"); len(elem) >= l && elem[0:l] == "l/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "c"

						if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'h': // Prefix: "ha"

							if l := len("ha"); len(elem) >= l && elem[0:l] == "ha" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'l': // Prefix: "llenges/v1/"

								if l := len("llenges/v1/"); len(elem) >= l && elem[0:l] == "llenges/v1/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "challenges/"

									if l := len("challenges/"); len(elem) >= l && elem[0:l] == "challenges/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'c': // Prefix: "config"
										origElem := elem
										if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = LolChallengesV1GetAllChallengeConfigsOperation
												r.summary = "List of all basic challenge configuration information (includes all translations for names and descriptions)"
												r.operationID = "lol-challenges-v1.getAllChallengeConfigs"
												r.pathPattern = "/lol/challenges/v1/challenges/config"
												r.args = args
												r.count = 0
												return r, true
											default:
												return
											}
										}

										elem = origElem
									case 'p': // Prefix: "percentiles"
										origElem := elem
										if l := len("percentiles"); len(elem) >= l && elem[0:l] == "percentiles" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = LolChallengesV1GetAllChallengePercentilesOperation
												r.summary = "Map of level to percentile of players who have achieved it - keys: ChallengeId -> Season -> Level -> percentile of players who achieved it"
												r.operationID = "lol-challenges-v1.getAllChallengePercentiles"
												r.pathPattern = "/lol/challenges/v1/challenges/percentiles"
												r.args = args
												r.count = 0
												return r, true
											default:
												return
											}
										}

										elem = origElem
									}
									// Param: "challengeId"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'c': // Prefix: "config"

											if l := len("config"); len(elem) >= l && elem[0:l] == "config" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "GET":
													r.name = LolChallengesV1GetChallengeConfigsOperation
													r.summary = "Get challenge configuration (REST)"
													r.operationID = "lol-challenges-v1.getChallengeConfigs"
													r.pathPattern = "/lol/challenges/v1/challenges/{challengeId}/config"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

										case 'l': // Prefix: "leaderboards/by-level/"

											if l := len("leaderboards/by-level/"); len(elem) >= l && elem[0:l] == "leaderboards/by-level/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "level"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "GET":
													r.name = LolChallengesV1GetChallengeLeaderboardsOperation
													r.summary = "Return top players for each level. Level must be MASTER, GRANDMASTER or CHALLENGER."
													r.operationID = "lol-challenges-v1.getChallengeLeaderboards"
													r.pathPattern = "/lol/challenges/v1/challenges/{challengeId}/leaderboards/by-level/{level}"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

										case 'p': // Prefix: "percentiles"

											if l := len("percentiles"); len(elem) >= l && elem[0:l] == "percentiles" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "GET":
													r.name = LolChallengesV1GetChallengePercentilesOperation
													r.summary = "Map of level to percentile of players who have achieved it"
													r.operationID = "lol-challenges-v1.getChallengePercentiles"
													r.pathPattern = "/lol/challenges/v1/challenges/{challengeId}/percentiles"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

										}

									}

								case 'p': // Prefix: "player-data/"

									if l := len("player-data/"); len(elem) >= l && elem[0:l] == "player-data/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "puuid"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = LolChallengesV1GetPlayerDataOperation
											r.summary = "Returns player information with list of all progressed challenges (REST)"
											r.operationID = "lol-challenges-v1.getPlayerData"
											r.pathPattern = "/lol/challenges/v1/player-data/{puuid}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							case 'm': // Prefix: "mpion-mastery/v4/"

								if l := len("mpion-mastery/v4/"); len(elem) >= l && elem[0:l] == "mpion-mastery/v4/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "champion-masteries/by-puuid/"

									if l := len("champion-masteries/by-puuid/"); len(elem) >= l && elem[0:l] == "champion-masteries/by-puuid/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "encryptedPUUID"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = ChampionMasteryV4GetAllChampionMasteriesByPUUIDOperation
											r.summary = "Get all champion mastery entries sorted by number of champion points descending."
											r.operationID = "champion-mastery-v4.getAllChampionMasteriesByPUUID"
											r.pathPattern = "/lol/champion-mastery/v4/champion-masteries/by-puuid/{encryptedPUUID}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'b': // Prefix: "by-champion/"

											if l := len("by-champion/"); len(elem) >= l && elem[0:l] == "by-champion/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "championId"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "GET":
													r.name = ChampionMasteryV4GetChampionMasteryByPUUIDOperation
													r.summary = "Get a champion mastery by puuid and champion ID."
													r.operationID = "champion-mastery-v4.getChampionMasteryByPUUID"
													r.pathPattern = "/lol/champion-mastery/v4/champion-masteries/by-puuid/{encryptedPUUID}/by-champion/{championId}"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

										case 't': // Prefix: "top"

											if l := len("top"); len(elem) >= l && elem[0:l] == "top" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "GET":
													r.name = ChampionMasteryV4GetTopChampionMasteriesByPUUIDOperation
													r.summary = "Get specified number of top champion mastery entries sorted by number of champion points descending."
													r.operationID = "champion-mastery-v4.getTopChampionMasteriesByPUUID"
													r.pathPattern = "/lol/champion-mastery/v4/champion-masteries/by-puuid/{encryptedPUUID}/top"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

										}

									}

								case 's': // Prefix: "scores/by-puuid/"

									if l := len("scores/by-puuid/"); len(elem) >= l && elem[0:l] == "scores/by-puuid/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "encryptedPUUID"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = ChampionMasteryV4GetChampionMasteryScoreByPUUIDOperation
											r.summary = "Get a player's total champion mastery score, which is the sum of individual champion mastery levels."
											r.operationID = "champion-mastery-v4.getChampionMasteryScoreByPUUID"
											r.pathPattern = "/lol/champion-mastery/v4/scores/by-puuid/{encryptedPUUID}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							}

						case 'l': // Prefix: "lash/v1/"

							if l := len("lash/v1/"); len(elem) >= l && elem[0:l] == "lash/v1/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'p': // Prefix: "players/by-puuid/"

								if l := len("players/by-puuid/"); len(elem) >= l && elem[0:l] == "players/by-puuid/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "puuid"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = ClashV1GetPlayersByPUUIDOperation
										r.summary = "Get players by puuid"
										r.operationID = "clash-v1.getPlayersByPUUID"
										r.pathPattern = "/lol/clash/v1/players/by-puuid/{puuid}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 't': // Prefix: "t"

								if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "eams/"

									if l := len("eams/"); len(elem) >= l && elem[0:l] == "eams/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "teamId"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = ClashV1GetTeamByIdOperation
											r.summary = "Get team by ID."
											r.operationID = "clash-v1.getTeamById"
											r.pathPattern = "/lol/clash/v1/teams/{teamId}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 'o': // Prefix: "ournaments"

									if l := len("ournaments"); len(elem) >= l && elem[0:l] == "ournaments" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = ClashV1GetTournamentsOperation
											r.summary = "Get all active or upcoming tournaments."
											r.operationID = "clash-v1.getTournaments"
											r.pathPattern = "/lol/clash/v1/tournaments"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'b': // Prefix: "by-team/"
											origElem := elem
											if l := len("by-team/"); len(elem) >= l && elem[0:l] == "by-team/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "teamId"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[0] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "GET":
													r.name = ClashV1GetTournamentByTeamOperation
													r.summary = "Get tournament by team ID."
													r.operationID = "clash-v1.getTournamentByTeam"
													r.pathPattern = "/lol/clash/v1/tournaments/by-team/{teamId}"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

											elem = origElem
										}
										// Param: "tournamentId"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[0] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = ClashV1GetTournamentByIdOperation
												r.summary = "Get tournament by ID."
												r.operationID = "clash-v1.getTournamentById"
												r.pathPattern = "/lol/clash/v1/tournaments/{tournamentId}"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									}

								}

							}

						}

					case 'l': // Prefix: "league"

						if l := len("league"); len(elem) >= l && elem[0:l] == "league" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '-': // Prefix: "-exp/v4/entries/"

							if l := len("-exp/v4/entries/"); len(elem) >= l && elem[0:l] == "-exp/v4/entries/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "queue"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "tier"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "division"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = LeagueExpV4GetLeagueEntriesOperation
											r.summary = "Get all the league entries."
											r.operationID = "league-exp-v4.getLeagueEntries"
											r.pathPattern = "/lol/league-exp/v4/entries/{queue}/{tier}/{division}"
											r.args = args
											r.count = 3
											return r, true
										default:
											return
										}
									}

								}

							}

						case '/': // Prefix: "/v4/"

							if l := len("/v4/"); len(elem) >= l && elem[0:l] == "/v4/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "challengerleagues/by-queue/"

								if l := len("challengerleagues/by-queue/"); len(elem) >= l && elem[0:l] == "challengerleagues/by-queue/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "queue"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = LeagueV4GetChallengerLeagueOperation
										r.summary = "Get the challenger league for given queue."
										r.operationID = "league-v4.getChallengerLeague"
										r.pathPattern = "/lol/league/v4/challengerleagues/by-queue/{queue}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'e': // Prefix: "entries/"

								if l := len("entries/"); len(elem) >= l && elem[0:l] == "entries/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'b': // Prefix: "by-puuid/"
									origElem := elem
									if l := len("by-puuid/"); len(elem) >= l && elem[0:l] == "by-puuid/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "encryptedPUUID"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = LeagueV4GetLeagueEntriesByPUUIDOperation
											r.summary = "Get league entries in all queues for a given puuid"
											r.operationID = "league-v4.getLeagueEntriesByPUUID"
											r.pathPattern = "/lol/league/v4/entries/by-puuid/{encryptedPUUID}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

									elem = origElem
								}
								// Param: "queue"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "tier"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "division"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = LeagueV4GetLeagueEntriesOperation
												r.summary = "Get all the league entries."
												r.operationID = "league-v4.getLeagueEntries"
												r.pathPattern = "/lol/league/v4/entries/{queue}/{tier}/{division}"
												r.args = args
												r.count = 3
												return r, true
											default:
												return
											}
										}

									}

								}

							case 'g': // Prefix: "grandmasterleagues/by-queue/"

								if l := len("grandmasterleagues/by-queue/"); len(elem) >= l && elem[0:l] == "grandmasterleagues/by-queue/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "queue"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = LeagueV4GetGrandmasterLeagueOperation
										r.summary = "Get the grandmaster league of a specific queue."
										r.operationID = "league-v4.getGrandmasterLeague"
										r.pathPattern = "/lol/league/v4/grandmasterleagues/by-queue/{queue}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'l': // Prefix: "leagues/"

								if l := len("leagues/"); len(elem) >= l && elem[0:l] == "leagues/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "leagueId"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = LeagueV4GetLeagueByIdOperation
										r.summary = "Get league with given ID, including inactive entries."
										r.operationID = "league-v4.getLeagueById"
										r.pathPattern = "/lol/league/v4/leagues/{leagueId}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'm': // Prefix: "masterleagues/by-queue/"

								if l := len("masterleagues/by-queue/"); len(elem) >= l && elem[0:l] == "masterleagues/by-queue/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "queue"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = LeagueV4GetMasterLeagueOperation
										r.summary = "Get the master league for given queue."
										r.operationID = "league-v4.getMasterLeague"
										r.pathPattern = "/lol/league/v4/masterleagues/by-queue/{queue}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						}

					case 'm': // Prefix: "match/v5/matches/"

						if l := len("match/v5/matches/"); len(elem) >= l && elem[0:l] == "match/v5/matches/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'b': // Prefix: "by-puuid/"
							origElem := elem
							if l := len("by-puuid/"); len(elem) >= l && elem[0:l] == "by-puuid/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "puuid"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/ids"

								if l := len("/ids"); len(elem) >= l && elem[0:l] == "/ids" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = MatchV5GetMatchIdsByPUUIDOperation
										r.summary = "Get a list of match ids by puuid"
										r.operationID = "match-v5.getMatchIdsByPUUID"
										r.pathPattern = "/lol/match/v5/matches/by-puuid/{puuid}/ids"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

							elem = origElem
						}
						// Param: "matchId"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = MatchV5GetMatchOperation
								r.summary = "Get a match by match id"
								r.operationID = "match-v5.getMatch"
								r.pathPattern = "/lol/match/v5/matches/{matchId}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/timeline"

							if l := len("/timeline"); len(elem) >= l && elem[0:l] == "/timeline" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = MatchV5GetTimelineOperation
									r.summary = "Get a match timeline by match id"
									r.operationID = "match-v5.getTimeline"
									r.pathPattern = "/lol/match/v5/matches/{matchId}/timeline"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					case 'p': // Prefix: "platform/v3/champion-rotations"

						if l := len("platform/v3/champion-rotations"); len(elem) >= l && elem[0:l] == "platform/v3/champion-rotations" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = ChampionV3GetChampionInfoOperation
								r.summary = "Returns champion rotations, including free-to-play and low-level free-to-play rotations (REST)"
								r.operationID = "champion-v3.getChampionInfo"
								r.pathPattern = "/lol/platform/v3/champion-rotations"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'r': // Prefix: "rso-match/v1/matches/"

						if l := len("rso-match/v1/matches/"); len(elem) >= l && elem[0:l] == "rso-match/v1/matches/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'i': // Prefix: "ids"
							origElem := elem
							if l := len("ids"); len(elem) >= l && elem[0:l] == "ids" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = LolRsoMatchV1GetMatchIdsOperation
									r.summary = "Get a list of match ids by player access token - Includes custom matches"
									r.operationID = "lol-rso-match-v1.getMatchIds"
									r.pathPattern = "/lol/rso-match/v1/matches/ids"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

							elem = origElem
						}
						// Param: "matchId"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = LolRsoMatchV1GetMatchOperation
								r.summary = "Get a match by match id"
								r.operationID = "lol-rso-match-v1.getMatch"
								r.pathPattern = "/lol/rso-match/v1/matches/{matchId}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/timeline"

							if l := len("/timeline"); len(elem) >= l && elem[0:l] == "/timeline" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = LolRsoMatchV1GetTimelineOperation
									r.summary = "Get a match timeline by match id"
									r.operationID = "lol-rso-match-v1.getTimeline"
									r.pathPattern = "/lol/rso-match/v1/matches/{matchId}/timeline"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					case 's': // Prefix: "s"

						if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'p': // Prefix: "pectator/"

							if l := len("pectator/"); len(elem) >= l && elem[0:l] == "pectator/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 't': // Prefix: "tft/v5/"

								if l := len("tft/v5/"); len(elem) >= l && elem[0:l] == "tft/v5/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "active-games/by-puuid/"

									if l := len("active-games/by-puuid/"); len(elem) >= l && elem[0:l] == "active-games/by-puuid/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "encryptedPUUID"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = SpectatorTftV5GetCurrentGameInfoByPuuidOperation
											r.summary = "Get current game information for the given puuid."
											r.operationID = "spectator-tft-v5.getCurrentGameInfoByPuuid"
											r.pathPattern = "/lol/spectator/tft/v5/active-games/by-puuid/{encryptedPUUID}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 'f': // Prefix: "featured-games"

									if l := len("featured-games"); len(elem) >= l && elem[0:l] == "featured-games" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = SpectatorTftV5GetFeaturedGamesOperation
											r.summary = "Get list of featured games."
											r.operationID = "spectator-tft-v5.getFeaturedGames"
											r.pathPattern = "/lol/spectator/tft/v5/featured-games"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								}

							case 'v': // Prefix: "v5/"

								if l := len("v5/"); len(elem) >= l && elem[0:l] == "v5/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "active-games/by-summoner/"

									if l := len("active-games/by-summoner/"); len(elem) >= l && elem[0:l] == "active-games/by-summoner/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "encryptedPUUID"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = SpectatorV5GetCurrentGameInfoByPuuidOperation
											r.summary = "Get current game information for the given puuid."
											r.operationID = "spectator-v5.getCurrentGameInfoByPuuid"
											r.pathPattern = "/lol/spectator/v5/active-games/by-summoner/{encryptedPUUID}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 'f': // Prefix: "featured-games"

									if l := len("featured-games"); len(elem) >= l && elem[0:l] == "featured-games" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = SpectatorV5GetFeaturedGamesOperation
											r.summary = "Get list of featured games."
											r.operationID = "spectator-v5.getFeaturedGames"
											r.pathPattern = "/lol/spectator/v5/featured-games"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								}

							}

						case 't': // Prefix: "tatus/v4/platform-data"

							if l := len("tatus/v4/platform-data"); len(elem) >= l && elem[0:l] == "tatus/v4/platform-data" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = LolStatusV4GetPlatformDataOperation
									r.summary = "Get League of Legends status for the given platform."
									r.operationID = "lol-status-v4.getPlatformData"
									r.pathPattern = "/lol/status/v4/platform-data"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'u': // Prefix: "ummoner/v4/summoners/"

							if l := len("ummoner/v4/summoners/"); len(elem) >= l && elem[0:l] == "ummoner/v4/summoners/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'b': // Prefix: "by-puuid/"

								if l := len("by-puuid/"); len(elem) >= l && elem[0:l] == "by-puuid/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "encryptedPUUID"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = SummonerV4GetByPUUIDOperation
										r.summary = "Get a summoner by PUUID."
										r.operationID = "summoner-v4.getByPUUID"
										r.pathPattern = "/lol/summoner/v4/summoners/by-puuid/{encryptedPUUID}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'm': // Prefix: "me"

								if l := len("me"); len(elem) >= l && elem[0:l] == "me" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = SummonerV4GetByAccessTokenOperation
										r.summary = "Get a summoner by access token."
										r.operationID = "summoner-v4.getByAccessToken"
										r.pathPattern = "/lol/summoner/v4/summoners/me"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							}

						}

					case 't': // Prefix: "tournament"

						if l := len("tournament"); len(elem) >= l && elem[0:l] == "tournament" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '-': // Prefix: "-stub/v5/"

							if l := len("-stub/v5/"); len(elem) >= l && elem[0:l] == "-stub/v5/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "codes"

								if l := len("codes"); len(elem) >= l && elem[0:l] == "codes" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										r.name = TournamentStubV5CreateTournamentCodeOperation
										r.summary = "Create a tournament code for the given tournament - Stub method"
										r.operationID = "tournament-stub-v5.createTournamentCode"
										r.pathPattern = "/lol/tournament-stub/v5/codes"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "tournamentCode"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = TournamentStubV5GetTournamentCodeOperation
											r.summary = "Returns the tournament code DTO associated with a tournament code string - Stub Method"
											r.operationID = "tournament-stub-v5.getTournamentCode"
											r.pathPattern = "/lol/tournament-stub/v5/codes/{tournamentCode}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							case 'l': // Prefix: "lobby-events/by-code/"

								if l := len("lobby-events/by-code/"); len(elem) >= l && elem[0:l] == "lobby-events/by-code/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "tournamentCode"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = TournamentStubV5GetLobbyEventsByCodeOperation
										r.summary = "Gets a list of lobby events by tournament code - Stub method"
										r.operationID = "tournament-stub-v5.getLobbyEventsByCode"
										r.pathPattern = "/lol/tournament-stub/v5/lobby-events/by-code/{tournamentCode}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'p': // Prefix: "providers"

								if l := len("providers"); len(elem) >= l && elem[0:l] == "providers" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = TournamentStubV5RegisterProviderDataOperation
										r.summary = "Creates a tournament provider and returns its ID - Stub method"
										r.operationID = "tournament-stub-v5.registerProviderData"
										r.pathPattern = "/lol/tournament-stub/v5/providers"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							case 't': // Prefix: "tournaments"

								if l := len("tournaments"); len(elem) >= l && elem[0:l] == "tournaments" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = TournamentStubV5RegisterTournamentOperation
										r.summary = "Creates a tournament and returns its ID - Stub method"
										r.operationID = "tournament-stub-v5.registerTournament"
										r.pathPattern = "/lol/tournament-stub/v5/tournaments"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							}

						case '/': // Prefix: "/v5/"

							if l := len("/v5/"); len(elem) >= l && elem[0:l] == "/v5/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "codes"

								if l := len("codes"); len(elem) >= l && elem[0:l] == "codes" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										r.name = TournamentV5CreateTournamentCodeOperation
										r.summary = "Create a tournament code for the given tournament."
										r.operationID = "tournament-v5.createTournamentCode"
										r.pathPattern = "/lol/tournament/v5/codes"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "tournamentCode"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = TournamentV5GetTournamentCodeOperation
											r.summary = "Returns the tournament code DTO associated with a tournament code string."
											r.operationID = "tournament-v5.getTournamentCode"
											r.pathPattern = "/lol/tournament/v5/codes/{tournamentCode}"
											r.args = args
											r.count = 1
											return r, true
										case "PUT":
											r.name = TournamentV5UpdateCodeOperation
											r.summary = "Update the pick type, map, spectator type, or allowed puuids for a code."
											r.operationID = "tournament-v5.updateCode"
											r.pathPattern = "/lol/tournament/v5/codes/{tournamentCode}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							case 'g': // Prefix: "games/by-code/"

								if l := len("games/by-code/"); len(elem) >= l && elem[0:l] == "games/by-code/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "tournamentCode"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = TournamentV5GetGamesOperation
										r.summary = "Get games details"
										r.operationID = "tournament-v5.getGames"
										r.pathPattern = "/lol/tournament/v5/games/by-code/{tournamentCode}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'l': // Prefix: "lobby-events/by-code/"

								if l := len("lobby-events/by-code/"); len(elem) >= l && elem[0:l] == "lobby-events/by-code/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "tournamentCode"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = TournamentV5GetLobbyEventsByCodeOperation
										r.summary = "Gets a list of lobby events by tournament code."
										r.operationID = "tournament-v5.getLobbyEventsByCode"
										r.pathPattern = "/lol/tournament/v5/lobby-events/by-code/{tournamentCode}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'p': // Prefix: "providers"

								if l := len("providers"); len(elem) >= l && elem[0:l] == "providers" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = TournamentV5RegisterProviderDataOperation
										r.summary = "Creates a tournament provider and returns its ID."
										r.operationID = "tournament-v5.registerProviderData"
										r.pathPattern = "/lol/tournament/v5/providers"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							case 't': // Prefix: "tournaments"

								if l := len("tournaments"); len(elem) >= l && elem[0:l] == "tournaments" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = TournamentV5RegisterTournamentOperation
										r.summary = "Creates a tournament and returns its ID."
										r.operationID = "tournament-v5.registerTournament"
										r.pathPattern = "/lol/tournament/v5/tournaments"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							}

						}

					}

				case 'r': // Prefix: "r/"

					if l := len("r/"); len(elem) >= l && elem[0:l] == "r/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'd': // Prefix: "deck/v1/decks/me"

						if l := len("deck/v1/decks/me"); len(elem) >= l && elem[0:l] == "deck/v1/decks/me" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = LorDeckV1GetDecksOperation
								r.summary = "Get a list of the calling user's decks."
								r.operationID = "lor-deck-v1.getDecks"
								r.pathPattern = "/lor/deck/v1/decks/me"
								r.args = args
								r.count = 0
								return r, true
							case "POST":
								r.name = LorDeckV1CreateDeckOperation
								r.summary = "Create a new deck for the calling user."
								r.operationID = "lor-deck-v1.createDeck"
								r.pathPattern = "/lor/deck/v1/decks/me"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'i': // Prefix: "inventory/v1/cards/me"

						if l := len("inventory/v1/cards/me"); len(elem) >= l && elem[0:l] == "inventory/v1/cards/me" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = LorInventoryV1GetCardsOperation
								r.summary = "Return a list of cards owned by the calling user."
								r.operationID = "lor-inventory-v1.getCards"
								r.pathPattern = "/lor/inventory/v1/cards/me"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'm': // Prefix: "match/v1/matches/"

						if l := len("match/v1/matches/"); len(elem) >= l && elem[0:l] == "match/v1/matches/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'b': // Prefix: "by-puuid/"
							origElem := elem
							if l := len("by-puuid/"); len(elem) >= l && elem[0:l] == "by-puuid/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "puuid"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/ids"

								if l := len("/ids"); len(elem) >= l && elem[0:l] == "/ids" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = LorMatchV1GetMatchIdsByPUUIDOperation
										r.summary = "Get a list of match ids by PUUID"
										r.operationID = "lor-match-v1.getMatchIdsByPUUID"
										r.pathPattern = "/lor/match/v1/matches/by-puuid/{puuid}/ids"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

							elem = origElem
						}
						// Param: "matchId"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = LorMatchV1GetMatchOperation
								r.summary = "Get match by id"
								r.operationID = "lor-match-v1.getMatch"
								r.pathPattern = "/lor/match/v1/matches/{matchId}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

					case 'r': // Prefix: "ranked/v1/leaderboards"

						if l := len("ranked/v1/leaderboards"); len(elem) >= l && elem[0:l] == "ranked/v1/leaderboards" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = LorRankedV1GetLeaderboardsOperation
								r.summary = "Get the players in Master tier."
								r.operationID = "lor-ranked-v1.getLeaderboards"
								r.pathPattern = "/lor/ranked/v1/leaderboards"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 's': // Prefix: "status/v1/platform-data"

						if l := len("status/v1/platform-data"); len(elem) >= l && elem[0:l] == "status/v1/platform-data" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = LorStatusV1GetPlatformDataOperation
								r.summary = "Get Legends of Runeterra status for the given platform."
								r.operationID = "lor-status-v1.getPlatformData"
								r.pathPattern = "/lor/status/v1/platform-data"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					}

				}

			case 'r': // Prefix: "riot/account/v1/"

				if l := len("riot/account/v1/"); len(elem) >= l && elem[0:l] == "riot/account/v1/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "ac"

					if l := len("ac"); len(elem) >= l && elem[0:l] == "ac" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "counts/"

						if l := len("counts/"); len(elem) >= l && elem[0:l] == "counts/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'b': // Prefix: "by-"

							if l := len("by-"); len(elem) >= l && elem[0:l] == "by-" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'p': // Prefix: "puuid/"

								if l := len("puuid/"); len(elem) >= l && elem[0:l] == "puuid/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "puuid"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = AccountV1GetByPuuidOperation
										r.summary = "Get account by puuid"
										r.operationID = "account-v1.getByPuuid"
										r.pathPattern = "/riot/account/v1/accounts/by-puuid/{puuid}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'r': // Prefix: "riot-id/"

								if l := len("riot-id/"); len(elem) >= l && elem[0:l] == "riot-id/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "gameName"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "tagLine"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = AccountV1GetByRiotIdOperation
											r.summary = "Get account by riot id"
											r.operationID = "account-v1.getByRiotId"
											r.pathPattern = "/riot/account/v1/accounts/by-riot-id/{gameName}/{tagLine}"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}

								}

							}

						case 'm': // Prefix: "me"

							if l := len("me"); len(elem) >= l && elem[0:l] == "me" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = AccountV1GetByAccessTokenOperation
									r.summary = "Get account by access token"
									r.operationID = "account-v1.getByAccessToken"
									r.pathPattern = "/riot/account/v1/accounts/me"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					case 't': // Prefix: "tive-shards/by-game/"

						if l := len("tive-shards/by-game/"); len(elem) >= l && elem[0:l] == "tive-shards/by-game/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "game"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/by-puuid/"

							if l := len("/by-puuid/"); len(elem) >= l && elem[0:l] == "/by-puuid/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "puuid"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = AccountV1GetActiveShardOperation
									r.summary = "Get active shard for a player"
									r.operationID = "account-v1.getActiveShard"
									r.pathPattern = "/riot/account/v1/active-shards/by-game/{game}/by-puuid/{puuid}"
									r.args = args
									r.count = 2
									return r, true
								default:
									return
								}
							}

						}

					}

				case 'r': // Prefix: "region/by-game/"

					if l := len("region/by-game/"); len(elem) >= l && elem[0:l] == "region/by-game/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "game"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '/': // Prefix: "/by-puuid/"

						if l := len("/by-puuid/"); len(elem) >= l && elem[0:l] == "/by-puuid/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "puuid"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = AccountV1GetActiveRegionOperation
								r.summary = "Get active region (lol and tft)"
								r.operationID = "account-v1.getActiveRegion"
								r.pathPattern = "/riot/account/v1/region/by-game/{game}/by-puuid/{puuid}"
								r.args = args
								r.count = 2
								return r, true
							default:
								return
							}
						}

					}

				}

			case 't': // Prefix: "tft/"

				if l := len("tft/"); len(elem) >= l && elem[0:l] == "tft/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'l': // Prefix: "league/v1/"

					if l := len("league/v1/"); len(elem) >= l && elem[0:l] == "league/v1/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'b': // Prefix: "by-puuid/"

						if l := len("by-puuid/"); len(elem) >= l && elem[0:l] == "by-puuid/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "puuid"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = TftLeagueV1GetLeagueEntriesByPUUIDOperation
								r.summary = "Get league entries in all queues for a given puuid"
								r.operationID = "tft-league-v1.getLeagueEntriesByPUUID"
								r.pathPattern = "/tft/league/v1/by-puuid/{puuid}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

					case 'c': // Prefix: "challenger"

						if l := len("challenger"); len(elem) >= l && elem[0:l] == "challenger" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = TftLeagueV1GetChallengerLeagueOperation
								r.summary = "Get the challenger league."
								r.operationID = "tft-league-v1.getChallengerLeague"
								r.pathPattern = "/tft/league/v1/challenger"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'e': // Prefix: "entries/"

						if l := len("entries/"); len(elem) >= l && elem[0:l] == "entries/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "tier"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "division"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = TftLeagueV1GetLeagueEntriesOperation
									r.summary = "Get all the league entries."
									r.operationID = "tft-league-v1.getLeagueEntries"
									r.pathPattern = "/tft/league/v1/entries/{tier}/{division}"
									r.args = args
									r.count = 2
									return r, true
								default:
									return
								}
							}

						}

					case 'g': // Prefix: "grandmaster"

						if l := len("grandmaster"); len(elem) >= l && elem[0:l] == "grandmaster" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = TftLeagueV1GetGrandmasterLeagueOperation
								r.summary = "Get the grandmaster league."
								r.operationID = "tft-league-v1.getGrandmasterLeague"
								r.pathPattern = "/tft/league/v1/grandmaster"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'l': // Prefix: "leagues/"

						if l := len("leagues/"); len(elem) >= l && elem[0:l] == "leagues/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "leagueId"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = TftLeagueV1GetLeagueByIdOperation
								r.summary = "Get league with given ID, including inactive entries."
								r.operationID = "tft-league-v1.getLeagueById"
								r.pathPattern = "/tft/league/v1/leagues/{leagueId}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

					case 'm': // Prefix: "master"

						if l := len("master"); len(elem) >= l && elem[0:l] == "master" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = TftLeagueV1GetMasterLeagueOperation
								r.summary = "Get the master league."
								r.operationID = "tft-league-v1.getMasterLeague"
								r.pathPattern = "/tft/league/v1/master"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'r': // Prefix: "rated-ladders/"

						if l := len("rated-ladders/"); len(elem) >= l && elem[0:l] == "rated-ladders/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "queue"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/top"

							if l := len("/top"); len(elem) >= l && elem[0:l] == "/top" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = TftLeagueV1GetTopRatedLadderOperation
									r.summary = "Get the top rated ladder for given queue"
									r.operationID = "tft-league-v1.getTopRatedLadder"
									r.pathPattern = "/tft/league/v1/rated-ladders/{queue}/top"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					}

				case 'm': // Prefix: "match/v1/matches/"

					if l := len("match/v1/matches/"); len(elem) >= l && elem[0:l] == "match/v1/matches/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'b': // Prefix: "by-puuid/"
						origElem := elem
						if l := len("by-puuid/"); len(elem) >= l && elem[0:l] == "by-puuid/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "puuid"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/ids"

							if l := len("/ids"); len(elem) >= l && elem[0:l] == "/ids" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = TftMatchV1GetMatchIdsByPUUIDOperation
									r.summary = "Get a list of match ids by PUUID"
									r.operationID = "tft-match-v1.getMatchIdsByPUUID"
									r.pathPattern = "/tft/match/v1/matches/by-puuid/{puuid}/ids"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

						elem = origElem
					}
					// Param: "matchId"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = TftMatchV1GetMatchOperation
							r.summary = "Get a match by match id"
							r.operationID = "tft-match-v1.getMatch"
							r.pathPattern = "/tft/match/v1/matches/{matchId}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}

				case 's': // Prefix: "s"

					if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 't': // Prefix: "tatus/v1/platform-data"

						if l := len("tatus/v1/platform-data"); len(elem) >= l && elem[0:l] == "tatus/v1/platform-data" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = TftStatusV1GetPlatformDataOperation
								r.summary = "Get Teamfight Tactics status for the given platform."
								r.operationID = "tft-status-v1.getPlatformData"
								r.pathPattern = "/tft/status/v1/platform-data"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'u': // Prefix: "ummoner/v1/summoners/"

						if l := len("ummoner/v1/summoners/"); len(elem) >= l && elem[0:l] == "ummoner/v1/summoners/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'b': // Prefix: "by-puuid/"

							if l := len("by-puuid/"); len(elem) >= l && elem[0:l] == "by-puuid/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "encryptedPUUID"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = TftSummonerV1GetByPUUIDOperation
									r.summary = "Get a summoner by PUUID."
									r.operationID = "tft-summoner-v1.getByPUUID"
									r.pathPattern = "/tft/summoner/v1/summoners/by-puuid/{encryptedPUUID}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						case 'm': // Prefix: "me"

							if l := len("me"); len(elem) >= l && elem[0:l] == "me" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = TftSummonerV1GetByAccessTokenOperation
									r.summary = "Get a summoner by access token."
									r.operationID = "tft-summoner-v1.getByAccessToken"
									r.pathPattern = "/tft/summoner/v1/summoners/me"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					}

				}

			case 'v': // Prefix: "val/"

				if l := len("val/"); len(elem) >= l && elem[0:l] == "val/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "con"

					if l := len("con"); len(elem) >= l && elem[0:l] == "con" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 's': // Prefix: "sole/ranked/v1/leaderboards/by-act/"

						if l := len("sole/ranked/v1/leaderboards/by-act/"); len(elem) >= l && elem[0:l] == "sole/ranked/v1/leaderboards/by-act/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "actId"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = ValConsoleRankedV1GetLeaderboardOperation
								r.summary = "Get leaderboard for the competitive queue"
								r.operationID = "val-console-ranked-v1.getLeaderboard"
								r.pathPattern = "/val/console/ranked/v1/leaderboards/by-act/{actId}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

					case 't': // Prefix: "tent/v1/contents"

						if l := len("tent/v1/contents"); len(elem) >= l && elem[0:l] == "tent/v1/contents" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = ValContentV1GetContentOperation
								r.summary = "Get content optionally filtered by locale"
								r.operationID = "val-content-v1.getContent"
								r.pathPattern = "/val/content/v1/contents"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					}

				case 'm': // Prefix: "match/"

					if l := len("match/"); len(elem) >= l && elem[0:l] == "match/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "console/v1/"

						if l := len("console/v1/"); len(elem) >= l && elem[0:l] == "console/v1/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'm': // Prefix: "match"

							if l := len("match"); len(elem) >= l && elem[0:l] == "match" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "es/"

								if l := len("es/"); len(elem) >= l && elem[0:l] == "es/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "matchId"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = ValConsoleMatchV1GetMatchOperation
										r.summary = "Get match by id"
										r.operationID = "val-console-match-v1.getMatch"
										r.pathPattern = "/val/match/console/v1/matches/{matchId}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'l': // Prefix: "lists/by-puuid/"

								if l := len("lists/by-puuid/"); len(elem) >= l && elem[0:l] == "lists/by-puuid/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "puuid"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = ValConsoleMatchV1GetMatchlistOperation
										r.summary = "Get matchlist for games played by puuid and platform type"
										r.operationID = "val-console-match-v1.getMatchlist"
										r.pathPattern = "/val/match/console/v1/matchlists/by-puuid/{puuid}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						case 'r': // Prefix: "recent-matches/by-queue/"

							if l := len("recent-matches/by-queue/"); len(elem) >= l && elem[0:l] == "recent-matches/by-queue/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "queue"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = ValConsoleMatchV1GetRecentOperation
									r.summary = "Get recent matches"
									r.operationID = "val-console-match-v1.getRecent"
									r.pathPattern = "/val/match/console/v1/recent-matches/by-queue/{queue}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					case 'v': // Prefix: "v1/"

						if l := len("v1/"); len(elem) >= l && elem[0:l] == "v1/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'm': // Prefix: "match"

							if l := len("match"); len(elem) >= l && elem[0:l] == "match" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "es/"

								if l := len("es/"); len(elem) >= l && elem[0:l] == "es/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "matchId"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = ValMatchV1GetMatchOperation
										r.summary = "Get match by id"
										r.operationID = "val-match-v1.getMatch"
										r.pathPattern = "/val/match/v1/matches/{matchId}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'l': // Prefix: "lists/by-puuid/"

								if l := len("lists/by-puuid/"); len(elem) >= l && elem[0:l] == "lists/by-puuid/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "puuid"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = ValMatchV1GetMatchlistOperation
										r.summary = "Get matchlist for games played by puuid"
										r.operationID = "val-match-v1.getMatchlist"
										r.pathPattern = "/val/match/v1/matchlists/by-puuid/{puuid}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						case 'r': // Prefix: "recent-matches/by-queue/"

							if l := len("recent-matches/by-queue/"); len(elem) >= l && elem[0:l] == "recent-matches/by-queue/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "queue"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = ValMatchV1GetRecentOperation
									r.summary = "Get recent matches"
									r.operationID = "val-match-v1.getRecent"
									r.pathPattern = "/val/match/v1/recent-matches/by-queue/{queue}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					}

				case 'r': // Prefix: "ranked/v1/leaderboards/by-act/"

					if l := len("ranked/v1/leaderboards/by-act/"); len(elem) >= l && elem[0:l] == "ranked/v1/leaderboards/by-act/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "actId"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = ValRankedV1GetLeaderboardOperation
							r.summary = "Get leaderboard for the competitive queue"
							r.operationID = "val-ranked-v1.getLeaderboard"
							r.pathPattern = "/val/ranked/v1/leaderboards/by-act/{actId}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}

				case 's': // Prefix: "status/v1/platform-data"

					if l := len("status/v1/platform-data"); len(elem) >= l && elem[0:l] == "status/v1/platform-data" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = ValStatusV1GetPlatformDataOperation
							r.summary = "Get VALORANT status for the given platform."
							r.operationID = "val-status-v1.getPlatformData"
							r.pathPattern = "/val/status/v1/platform-data"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				}

			}

		}
	}
	return r, false
}
