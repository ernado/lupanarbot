// Code generated by ogen, DO NOT EDIT.

package oas

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AccountV1AccountDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AccountV1AccountDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		if s.GameName.Set {
			e.FieldStart("gameName")
			s.GameName.Encode(e)
		}
	}
	{
		if s.TagLine.Set {
			e.FieldStart("tagLine")
			s.TagLine.Encode(e)
		}
	}
}

var jsonFieldsNameOfAccountV1AccountDto = [3]string{
	0: "puuid",
	1: "gameName",
	2: "tagLine",
}

// Decode decodes AccountV1AccountDto from json.
func (s *AccountV1AccountDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountV1AccountDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "puuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "gameName":
			if err := func() error {
				s.GameName.Reset()
				if err := s.GameName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameName\"")
			}
		case "tagLine":
			if err := func() error {
				s.TagLine.Reset()
				if err := s.TagLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tagLine\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccountV1AccountDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAccountV1AccountDto) {
					name = jsonFieldsNameOfAccountV1AccountDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AccountV1AccountDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountV1AccountDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AccountV1AccountRegionDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AccountV1AccountRegionDTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		e.FieldStart("game")
		e.Str(s.Game)
	}
	{
		e.FieldStart("region")
		e.Str(s.Region)
	}
}

var jsonFieldsNameOfAccountV1AccountRegionDTO = [3]string{
	0: "puuid",
	1: "game",
	2: "region",
}

// Decode decodes AccountV1AccountRegionDTO from json.
func (s *AccountV1AccountRegionDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountV1AccountRegionDTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "puuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "game":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Game = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game\"")
			}
		case "region":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Region = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccountV1AccountRegionDTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAccountV1AccountRegionDTO) {
					name = jsonFieldsNameOfAccountV1AccountRegionDTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AccountV1AccountRegionDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountV1AccountRegionDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AccountV1ActiveShardDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AccountV1ActiveShardDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		e.FieldStart("game")
		e.Str(s.Game)
	}
	{
		e.FieldStart("activeShard")
		e.Str(s.ActiveShard)
	}
}

var jsonFieldsNameOfAccountV1ActiveShardDto = [3]string{
	0: "puuid",
	1: "game",
	2: "activeShard",
}

// Decode decodes AccountV1ActiveShardDto from json.
func (s *AccountV1ActiveShardDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountV1ActiveShardDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "puuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "game":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Game = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game\"")
			}
		case "activeShard":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ActiveShard = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeShard\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccountV1ActiveShardDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAccountV1ActiveShardDto) {
					name = jsonFieldsNameOfAccountV1ActiveShardDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AccountV1ActiveShardDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountV1ActiveShardDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChampionMasteryV4ChampionMasteryDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChampionMasteryV4ChampionMasteryDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		e.FieldStart("championPointsUntilNextLevel")
		e.Int64(s.ChampionPointsUntilNextLevel)
	}
	{
		if s.ChestGranted.Set {
			e.FieldStart("chestGranted")
			s.ChestGranted.Encode(e)
		}
	}
	{
		e.FieldStart("championId")
		e.Int64(s.ChampionId)
	}
	{
		e.FieldStart("lastPlayTime")
		e.Int64(s.LastPlayTime)
	}
	{
		e.FieldStart("championLevel")
		e.Int32(s.ChampionLevel)
	}
	{
		e.FieldStart("championPoints")
		e.Int32(s.ChampionPoints)
	}
	{
		e.FieldStart("championPointsSinceLastLevel")
		e.Int64(s.ChampionPointsSinceLastLevel)
	}
	{
		e.FieldStart("markRequiredForNextLevel")
		e.Int32(s.MarkRequiredForNextLevel)
	}
	{
		e.FieldStart("championSeasonMilestone")
		e.Int32(s.ChampionSeasonMilestone)
	}
	{
		e.FieldStart("nextSeasonMilestone")
		s.NextSeasonMilestone.Encode(e)
	}
	{
		e.FieldStart("tokensEarned")
		e.Int32(s.TokensEarned)
	}
	{
		if s.MilestoneGrades != nil {
			e.FieldStart("milestoneGrades")
			e.ArrStart()
			for _, elem := range s.MilestoneGrades {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfChampionMasteryV4ChampionMasteryDto = [13]string{
	0:  "puuid",
	1:  "championPointsUntilNextLevel",
	2:  "chestGranted",
	3:  "championId",
	4:  "lastPlayTime",
	5:  "championLevel",
	6:  "championPoints",
	7:  "championPointsSinceLastLevel",
	8:  "markRequiredForNextLevel",
	9:  "championSeasonMilestone",
	10: "nextSeasonMilestone",
	11: "tokensEarned",
	12: "milestoneGrades",
}

// Decode decodes ChampionMasteryV4ChampionMasteryDto from json.
func (s *ChampionMasteryV4ChampionMasteryDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChampionMasteryV4ChampionMasteryDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "puuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "championPointsUntilNextLevel":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.ChampionPointsUntilNextLevel = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"championPointsUntilNextLevel\"")
			}
		case "chestGranted":
			if err := func() error {
				s.ChestGranted.Reset()
				if err := s.ChestGranted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chestGranted\"")
			}
		case "championId":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int64()
				s.ChampionId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"championId\"")
			}
		case "lastPlayTime":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.LastPlayTime = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastPlayTime\"")
			}
		case "championLevel":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.ChampionLevel = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"championLevel\"")
			}
		case "championPoints":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.ChampionPoints = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"championPoints\"")
			}
		case "championPointsSinceLastLevel":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int64()
				s.ChampionPointsSinceLastLevel = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"championPointsSinceLastLevel\"")
			}
		case "markRequiredForNextLevel":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.MarkRequiredForNextLevel = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"markRequiredForNextLevel\"")
			}
		case "championSeasonMilestone":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.ChampionSeasonMilestone = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"championSeasonMilestone\"")
			}
		case "nextSeasonMilestone":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.NextSeasonMilestone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextSeasonMilestone\"")
			}
		case "tokensEarned":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.TokensEarned = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokensEarned\"")
			}
		case "milestoneGrades":
			if err := func() error {
				s.MilestoneGrades = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.MilestoneGrades = append(s.MilestoneGrades, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"milestoneGrades\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChampionMasteryV4ChampionMasteryDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111011,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChampionMasteryV4ChampionMasteryDto) {
					name = jsonFieldsNameOfChampionMasteryV4ChampionMasteryDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChampionMasteryV4ChampionMasteryDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChampionMasteryV4ChampionMasteryDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChampionMasteryV4GetAllChampionMasteriesByPUUIDOKApplicationJSON as json.
func (s ChampionMasteryV4GetAllChampionMasteriesByPUUIDOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ChampionMasteryV4ChampionMasteryDto(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ChampionMasteryV4GetAllChampionMasteriesByPUUIDOKApplicationJSON from json.
func (s *ChampionMasteryV4GetAllChampionMasteriesByPUUIDOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChampionMasteryV4GetAllChampionMasteriesByPUUIDOKApplicationJSON to nil")
	}
	var unwrapped []ChampionMasteryV4ChampionMasteryDto
	if err := func() error {
		unwrapped = make([]ChampionMasteryV4ChampionMasteryDto, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ChampionMasteryV4ChampionMasteryDto
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ChampionMasteryV4GetAllChampionMasteriesByPUUIDOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChampionMasteryV4GetAllChampionMasteriesByPUUIDOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChampionMasteryV4GetAllChampionMasteriesByPUUIDOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChampionMasteryV4GetChampionMasteryScoreByPUUIDOKApplicationJSON as json.
func (s ChampionMasteryV4GetChampionMasteryScoreByPUUIDOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := int32(s)

	e.Int32(unwrapped)
}

// Decode decodes ChampionMasteryV4GetChampionMasteryScoreByPUUIDOKApplicationJSON from json.
func (s *ChampionMasteryV4GetChampionMasteryScoreByPUUIDOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChampionMasteryV4GetChampionMasteryScoreByPUUIDOKApplicationJSON to nil")
	}
	var unwrapped int32
	if err := func() error {
		v, err := d.Int32()
		unwrapped = int32(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ChampionMasteryV4GetChampionMasteryScoreByPUUIDOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChampionMasteryV4GetChampionMasteryScoreByPUUIDOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChampionMasteryV4GetChampionMasteryScoreByPUUIDOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChampionMasteryV4GetTopChampionMasteriesByPUUIDOKApplicationJSON as json.
func (s ChampionMasteryV4GetTopChampionMasteriesByPUUIDOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ChampionMasteryV4ChampionMasteryDto(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ChampionMasteryV4GetTopChampionMasteriesByPUUIDOKApplicationJSON from json.
func (s *ChampionMasteryV4GetTopChampionMasteriesByPUUIDOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChampionMasteryV4GetTopChampionMasteriesByPUUIDOKApplicationJSON to nil")
	}
	var unwrapped []ChampionMasteryV4ChampionMasteryDto
	if err := func() error {
		unwrapped = make([]ChampionMasteryV4ChampionMasteryDto, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ChampionMasteryV4ChampionMasteryDto
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ChampionMasteryV4GetTopChampionMasteriesByPUUIDOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChampionMasteryV4GetTopChampionMasteriesByPUUIDOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChampionMasteryV4GetTopChampionMasteriesByPUUIDOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChampionMasteryV4NextSeasonMilestonesDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChampionMasteryV4NextSeasonMilestonesDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("requireGradeCounts")
		s.RequireGradeCounts.Encode(e)
	}
	{
		e.FieldStart("rewardMarks")
		e.Int32(s.RewardMarks)
	}
	{
		e.FieldStart("bonus")
		e.Bool(s.Bonus)
	}
	{
		if s.RewardConfig.Set {
			e.FieldStart("rewardConfig")
			s.RewardConfig.Encode(e)
		}
	}
	{
		e.FieldStart("totalGamesRequires")
		e.Int32(s.TotalGamesRequires)
	}
}

var jsonFieldsNameOfChampionMasteryV4NextSeasonMilestonesDto = [5]string{
	0: "requireGradeCounts",
	1: "rewardMarks",
	2: "bonus",
	3: "rewardConfig",
	4: "totalGamesRequires",
}

// Decode decodes ChampionMasteryV4NextSeasonMilestonesDto from json.
func (s *ChampionMasteryV4NextSeasonMilestonesDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChampionMasteryV4NextSeasonMilestonesDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "requireGradeCounts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.RequireGradeCounts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requireGradeCounts\"")
			}
		case "rewardMarks":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.RewardMarks = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewardMarks\"")
			}
		case "bonus":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Bonus = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bonus\"")
			}
		case "rewardConfig":
			if err := func() error {
				s.RewardConfig.Reset()
				if err := s.RewardConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewardConfig\"")
			}
		case "totalGamesRequires":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.TotalGamesRequires = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalGamesRequires\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChampionMasteryV4NextSeasonMilestonesDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChampionMasteryV4NextSeasonMilestonesDto) {
					name = jsonFieldsNameOfChampionMasteryV4NextSeasonMilestonesDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChampionMasteryV4NextSeasonMilestonesDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChampionMasteryV4NextSeasonMilestonesDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ChampionMasteryV4NextSeasonMilestonesDtoRequireGradeCounts) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ChampionMasteryV4NextSeasonMilestonesDtoRequireGradeCounts) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int32(elem)
	}
}

// Decode decodes ChampionMasteryV4NextSeasonMilestonesDtoRequireGradeCounts from json.
func (s *ChampionMasteryV4NextSeasonMilestonesDtoRequireGradeCounts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChampionMasteryV4NextSeasonMilestonesDtoRequireGradeCounts to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int32
		if err := func() error {
			v, err := d.Int32()
			elem = int32(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChampionMasteryV4NextSeasonMilestonesDtoRequireGradeCounts")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChampionMasteryV4NextSeasonMilestonesDtoRequireGradeCounts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChampionMasteryV4NextSeasonMilestonesDtoRequireGradeCounts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChampionMasteryV4RewardConfigDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChampionMasteryV4RewardConfigDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("rewardValue")
		e.Str(s.RewardValue)
	}
	{
		e.FieldStart("rewardType")
		e.Str(s.RewardType)
	}
	{
		e.FieldStart("maximumReward")
		e.Int32(s.MaximumReward)
	}
}

var jsonFieldsNameOfChampionMasteryV4RewardConfigDto = [3]string{
	0: "rewardValue",
	1: "rewardType",
	2: "maximumReward",
}

// Decode decodes ChampionMasteryV4RewardConfigDto from json.
func (s *ChampionMasteryV4RewardConfigDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChampionMasteryV4RewardConfigDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rewardValue":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RewardValue = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewardValue\"")
			}
		case "rewardType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RewardType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rewardType\"")
			}
		case "maximumReward":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.MaximumReward = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximumReward\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChampionMasteryV4RewardConfigDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChampionMasteryV4RewardConfigDto) {
					name = jsonFieldsNameOfChampionMasteryV4RewardConfigDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChampionMasteryV4RewardConfigDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChampionMasteryV4RewardConfigDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChampionV3ChampionInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChampionV3ChampionInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("maxNewPlayerLevel")
		e.Int32(s.MaxNewPlayerLevel)
	}
	{
		e.FieldStart("freeChampionIdsForNewPlayers")
		e.ArrStart()
		for _, elem := range s.FreeChampionIdsForNewPlayers {
			e.Int32(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("freeChampionIds")
		e.ArrStart()
		for _, elem := range s.FreeChampionIds {
			e.Int32(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfChampionV3ChampionInfo = [3]string{
	0: "maxNewPlayerLevel",
	1: "freeChampionIdsForNewPlayers",
	2: "freeChampionIds",
}

// Decode decodes ChampionV3ChampionInfo from json.
func (s *ChampionV3ChampionInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChampionV3ChampionInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxNewPlayerLevel":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.MaxNewPlayerLevel = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxNewPlayerLevel\"")
			}
		case "freeChampionIdsForNewPlayers":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.FreeChampionIdsForNewPlayers = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int32
					v, err := d.Int32()
					elem = int32(v)
					if err != nil {
						return err
					}
					s.FreeChampionIdsForNewPlayers = append(s.FreeChampionIdsForNewPlayers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"freeChampionIdsForNewPlayers\"")
			}
		case "freeChampionIds":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.FreeChampionIds = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int32
					v, err := d.Int32()
					elem = int32(v)
					if err != nil {
						return err
					}
					s.FreeChampionIds = append(s.FreeChampionIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"freeChampionIds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChampionV3ChampionInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChampionV3ChampionInfo) {
					name = jsonFieldsNameOfChampionV3ChampionInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChampionV3ChampionInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChampionV3ChampionInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClashV1GetPlayersByPUUIDOKApplicationJSON as json.
func (s ClashV1GetPlayersByPUUIDOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ClashV1PlayerDto(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ClashV1GetPlayersByPUUIDOKApplicationJSON from json.
func (s *ClashV1GetPlayersByPUUIDOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClashV1GetPlayersByPUUIDOKApplicationJSON to nil")
	}
	var unwrapped []ClashV1PlayerDto
	if err := func() error {
		unwrapped = make([]ClashV1PlayerDto, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ClashV1PlayerDto
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ClashV1GetPlayersByPUUIDOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ClashV1GetPlayersByPUUIDOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClashV1GetPlayersByPUUIDOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClashV1GetTournamentsOKApplicationJSON as json.
func (s ClashV1GetTournamentsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ClashV1TournamentDto(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ClashV1GetTournamentsOKApplicationJSON from json.
func (s *ClashV1GetTournamentsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClashV1GetTournamentsOKApplicationJSON to nil")
	}
	var unwrapped []ClashV1TournamentDto
	if err := func() error {
		unwrapped = make([]ClashV1TournamentDto, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ClashV1TournamentDto
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ClashV1GetTournamentsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ClashV1GetTournamentsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClashV1GetTournamentsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClashV1PlayerDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClashV1PlayerDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		if s.TeamId.Set {
			e.FieldStart("teamId")
			s.TeamId.Encode(e)
		}
	}
	{
		e.FieldStart("position")
		s.Position.Encode(e)
	}
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
}

var jsonFieldsNameOfClashV1PlayerDto = [4]string{
	0: "puuid",
	1: "teamId",
	2: "position",
	3: "role",
}

// Decode decodes ClashV1PlayerDto from json.
func (s *ClashV1PlayerDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClashV1PlayerDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "puuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "teamId":
			if err := func() error {
				s.TeamId.Reset()
				if err := s.TeamId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamId\"")
			}
		case "position":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Position.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClashV1PlayerDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClashV1PlayerDto) {
					name = jsonFieldsNameOfClashV1PlayerDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClashV1PlayerDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClashV1PlayerDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClashV1PlayerDtoPosition as json.
func (s ClashV1PlayerDtoPosition) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ClashV1PlayerDtoPosition from json.
func (s *ClashV1PlayerDtoPosition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClashV1PlayerDtoPosition to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ClashV1PlayerDtoPosition(v) {
	case ClashV1PlayerDtoPositionUNSELECTED:
		*s = ClashV1PlayerDtoPositionUNSELECTED
	case ClashV1PlayerDtoPositionFILL:
		*s = ClashV1PlayerDtoPositionFILL
	case ClashV1PlayerDtoPositionTOP:
		*s = ClashV1PlayerDtoPositionTOP
	case ClashV1PlayerDtoPositionJUNGLE:
		*s = ClashV1PlayerDtoPositionJUNGLE
	case ClashV1PlayerDtoPositionMIDDLE:
		*s = ClashV1PlayerDtoPositionMIDDLE
	case ClashV1PlayerDtoPositionBOTTOM:
		*s = ClashV1PlayerDtoPositionBOTTOM
	case ClashV1PlayerDtoPositionUTILITY:
		*s = ClashV1PlayerDtoPositionUTILITY
	default:
		*s = ClashV1PlayerDtoPosition(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ClashV1PlayerDtoPosition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClashV1PlayerDtoPosition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClashV1PlayerDtoRole as json.
func (s ClashV1PlayerDtoRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ClashV1PlayerDtoRole from json.
func (s *ClashV1PlayerDtoRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClashV1PlayerDtoRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ClashV1PlayerDtoRole(v) {
	case ClashV1PlayerDtoRoleCAPTAIN:
		*s = ClashV1PlayerDtoRoleCAPTAIN
	case ClashV1PlayerDtoRoleMEMBER:
		*s = ClashV1PlayerDtoRoleMEMBER
	default:
		*s = ClashV1PlayerDtoRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ClashV1PlayerDtoRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClashV1PlayerDtoRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClashV1TeamDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClashV1TeamDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("tournamentId")
		e.Int32(s.TournamentId)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("iconId")
		e.Int32(s.IconId)
	}
	{
		e.FieldStart("tier")
		e.Int32(s.Tier)
	}
	{
		e.FieldStart("captain")
		e.Str(s.Captain)
	}
	{
		e.FieldStart("abbreviation")
		e.Str(s.Abbreviation)
	}
	{
		e.FieldStart("players")
		e.ArrStart()
		for _, elem := range s.Players {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfClashV1TeamDto = [8]string{
	0: "id",
	1: "tournamentId",
	2: "name",
	3: "iconId",
	4: "tier",
	5: "captain",
	6: "abbreviation",
	7: "players",
}

// Decode decodes ClashV1TeamDto from json.
func (s *ClashV1TeamDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClashV1TeamDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "tournamentId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.TournamentId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tournamentId\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "iconId":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.IconId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iconId\"")
			}
		case "tier":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Tier = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier\"")
			}
		case "captain":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Captain = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"captain\"")
			}
		case "abbreviation":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Abbreviation = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"abbreviation\"")
			}
		case "players":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.Players = make([]ClashV1PlayerDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ClashV1PlayerDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Players = append(s.Players, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"players\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClashV1TeamDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClashV1TeamDto) {
					name = jsonFieldsNameOfClashV1TeamDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClashV1TeamDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClashV1TeamDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClashV1TournamentDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClashV1TournamentDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int32(s.ID)
	}
	{
		e.FieldStart("themeId")
		e.Int32(s.ThemeId)
	}
	{
		e.FieldStart("nameKey")
		e.Str(s.NameKey)
	}
	{
		e.FieldStart("nameKeySecondary")
		e.Str(s.NameKeySecondary)
	}
	{
		e.FieldStart("schedule")
		e.ArrStart()
		for _, elem := range s.Schedule {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfClashV1TournamentDto = [5]string{
	0: "id",
	1: "themeId",
	2: "nameKey",
	3: "nameKeySecondary",
	4: "schedule",
}

// Decode decodes ClashV1TournamentDto from json.
func (s *ClashV1TournamentDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClashV1TournamentDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ID = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "themeId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.ThemeId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"themeId\"")
			}
		case "nameKey":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NameKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nameKey\"")
			}
		case "nameKeySecondary":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.NameKeySecondary = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nameKeySecondary\"")
			}
		case "schedule":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Schedule = make([]ClashV1TournamentPhaseDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ClashV1TournamentPhaseDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Schedule = append(s.Schedule, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schedule\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClashV1TournamentDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClashV1TournamentDto) {
					name = jsonFieldsNameOfClashV1TournamentDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClashV1TournamentDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClashV1TournamentDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClashV1TournamentPhaseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClashV1TournamentPhaseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int32(s.ID)
	}
	{
		e.FieldStart("registrationTime")
		e.Int64(s.RegistrationTime)
	}
	{
		e.FieldStart("startTime")
		e.Int64(s.StartTime)
	}
	{
		e.FieldStart("cancelled")
		e.Bool(s.Cancelled)
	}
}

var jsonFieldsNameOfClashV1TournamentPhaseDto = [4]string{
	0: "id",
	1: "registrationTime",
	2: "startTime",
	3: "cancelled",
}

// Decode decodes ClashV1TournamentPhaseDto from json.
func (s *ClashV1TournamentPhaseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClashV1TournamentPhaseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ID = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "registrationTime":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.RegistrationTime = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"registrationTime\"")
			}
		case "startTime":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.StartTime = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startTime\"")
			}
		case "cancelled":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Cancelled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cancelled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClashV1TournamentPhaseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClashV1TournamentPhaseDto) {
					name = jsonFieldsNameOfClashV1TournamentPhaseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClashV1TournamentPhaseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClashV1TournamentPhaseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LeagueExpV4GetLeagueEntriesOKApplicationJSON as json.
func (s LeagueExpV4GetLeagueEntriesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []LeagueExpV4LeagueEntryDTO(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes LeagueExpV4GetLeagueEntriesOKApplicationJSON from json.
func (s *LeagueExpV4GetLeagueEntriesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeagueExpV4GetLeagueEntriesOKApplicationJSON to nil")
	}
	var unwrapped []LeagueExpV4LeagueEntryDTO
	if err := func() error {
		unwrapped = make([]LeagueExpV4LeagueEntryDTO, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem LeagueExpV4LeagueEntryDTO
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LeagueExpV4GetLeagueEntriesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LeagueExpV4GetLeagueEntriesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeagueExpV4GetLeagueEntriesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeagueExpV4LeagueEntryDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeagueExpV4LeagueEntryDTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("leagueId")
		e.Str(s.LeagueId)
	}
	{
		if s.SummonerId.Set {
			e.FieldStart("summonerId")
			s.SummonerId.Encode(e)
		}
	}
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		e.FieldStart("queueType")
		e.Str(s.QueueType)
	}
	{
		e.FieldStart("tier")
		e.Str(s.Tier)
	}
	{
		e.FieldStart("rank")
		e.Str(s.Rank)
	}
	{
		e.FieldStart("leaguePoints")
		e.Int32(s.LeaguePoints)
	}
	{
		e.FieldStart("wins")
		e.Int32(s.Wins)
	}
	{
		e.FieldStart("losses")
		e.Int32(s.Losses)
	}
	{
		e.FieldStart("hotStreak")
		e.Bool(s.HotStreak)
	}
	{
		e.FieldStart("veteran")
		e.Bool(s.Veteran)
	}
	{
		e.FieldStart("freshBlood")
		e.Bool(s.FreshBlood)
	}
	{
		e.FieldStart("inactive")
		e.Bool(s.Inactive)
	}
	{
		if s.MiniSeries.Set {
			e.FieldStart("miniSeries")
			s.MiniSeries.Encode(e)
		}
	}
}

var jsonFieldsNameOfLeagueExpV4LeagueEntryDTO = [14]string{
	0:  "leagueId",
	1:  "summonerId",
	2:  "puuid",
	3:  "queueType",
	4:  "tier",
	5:  "rank",
	6:  "leaguePoints",
	7:  "wins",
	8:  "losses",
	9:  "hotStreak",
	10: "veteran",
	11: "freshBlood",
	12: "inactive",
	13: "miniSeries",
}

// Decode decodes LeagueExpV4LeagueEntryDTO from json.
func (s *LeagueExpV4LeagueEntryDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeagueExpV4LeagueEntryDTO to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "leagueId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.LeagueId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leagueId\"")
			}
		case "summonerId":
			if err := func() error {
				s.SummonerId.Reset()
				if err := s.SummonerId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summonerId\"")
			}
		case "puuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "queueType":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.QueueType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queueType\"")
			}
		case "tier":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Tier = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier\"")
			}
		case "rank":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Rank = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rank\"")
			}
		case "leaguePoints":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.LeaguePoints = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leaguePoints\"")
			}
		case "wins":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.Wins = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wins\"")
			}
		case "losses":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Losses = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"losses\"")
			}
		case "hotStreak":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HotStreak = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hotStreak\"")
			}
		case "veteran":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Veteran = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"veteran\"")
			}
		case "freshBlood":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.FreshBlood = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"freshBlood\"")
			}
		case "inactive":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Inactive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inactive\"")
			}
		case "miniSeries":
			if err := func() error {
				s.MiniSeries.Reset()
				if err := s.MiniSeries.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"miniSeries\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeagueExpV4LeagueEntryDTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111101,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLeagueExpV4LeagueEntryDTO) {
					name = jsonFieldsNameOfLeagueExpV4LeagueEntryDTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeagueExpV4LeagueEntryDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeagueExpV4LeagueEntryDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeagueExpV4MiniSeriesDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeagueExpV4MiniSeriesDTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("losses")
		e.Int32(s.Losses)
	}
	{
		e.FieldStart("progress")
		e.Str(s.Progress)
	}
	{
		e.FieldStart("target")
		e.Int32(s.Target)
	}
	{
		e.FieldStart("wins")
		e.Int32(s.Wins)
	}
}

var jsonFieldsNameOfLeagueExpV4MiniSeriesDTO = [4]string{
	0: "losses",
	1: "progress",
	2: "target",
	3: "wins",
}

// Decode decodes LeagueExpV4MiniSeriesDTO from json.
func (s *LeagueExpV4MiniSeriesDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeagueExpV4MiniSeriesDTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "losses":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Losses = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"losses\"")
			}
		case "progress":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Progress = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress\"")
			}
		case "target":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Target = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		case "wins":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Wins = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wins\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeagueExpV4MiniSeriesDTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLeagueExpV4MiniSeriesDTO) {
					name = jsonFieldsNameOfLeagueExpV4MiniSeriesDTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeagueExpV4MiniSeriesDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeagueExpV4MiniSeriesDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LeagueV4GetLeagueEntriesByPUUIDOKApplicationJSON as json.
func (s LeagueV4GetLeagueEntriesByPUUIDOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []LeagueV4LeagueEntryDTO(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes LeagueV4GetLeagueEntriesByPUUIDOKApplicationJSON from json.
func (s *LeagueV4GetLeagueEntriesByPUUIDOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeagueV4GetLeagueEntriesByPUUIDOKApplicationJSON to nil")
	}
	var unwrapped []LeagueV4LeagueEntryDTO
	if err := func() error {
		unwrapped = make([]LeagueV4LeagueEntryDTO, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem LeagueV4LeagueEntryDTO
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LeagueV4GetLeagueEntriesByPUUIDOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LeagueV4GetLeagueEntriesByPUUIDOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeagueV4GetLeagueEntriesByPUUIDOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LeagueV4GetLeagueEntriesOKApplicationJSON as json.
func (s LeagueV4GetLeagueEntriesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []LeagueV4LeagueEntryDTO(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes LeagueV4GetLeagueEntriesOKApplicationJSON from json.
func (s *LeagueV4GetLeagueEntriesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeagueV4GetLeagueEntriesOKApplicationJSON to nil")
	}
	var unwrapped []LeagueV4LeagueEntryDTO
	if err := func() error {
		unwrapped = make([]LeagueV4LeagueEntryDTO, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem LeagueV4LeagueEntryDTO
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LeagueV4GetLeagueEntriesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LeagueV4GetLeagueEntriesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeagueV4GetLeagueEntriesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeagueV4LeagueEntryDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeagueV4LeagueEntryDTO) encodeFields(e *jx.Encoder) {
	{
		if s.LeagueId.Set {
			e.FieldStart("leagueId")
			s.LeagueId.Encode(e)
		}
	}
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		e.FieldStart("queueType")
		e.Str(s.QueueType)
	}
	{
		if s.Tier.Set {
			e.FieldStart("tier")
			s.Tier.Encode(e)
		}
	}
	{
		if s.Rank.Set {
			e.FieldStart("rank")
			s.Rank.Encode(e)
		}
	}
	{
		e.FieldStart("leaguePoints")
		e.Int32(s.LeaguePoints)
	}
	{
		e.FieldStart("wins")
		e.Int32(s.Wins)
	}
	{
		e.FieldStart("losses")
		e.Int32(s.Losses)
	}
	{
		e.FieldStart("hotStreak")
		e.Bool(s.HotStreak)
	}
	{
		e.FieldStart("veteran")
		e.Bool(s.Veteran)
	}
	{
		e.FieldStart("freshBlood")
		e.Bool(s.FreshBlood)
	}
	{
		e.FieldStart("inactive")
		e.Bool(s.Inactive)
	}
	{
		if s.MiniSeries.Set {
			e.FieldStart("miniSeries")
			s.MiniSeries.Encode(e)
		}
	}
	{
		if s.SummonerId.Set {
			e.FieldStart("summonerId")
			s.SummonerId.Encode(e)
		}
	}
}

var jsonFieldsNameOfLeagueV4LeagueEntryDTO = [14]string{
	0:  "leagueId",
	1:  "puuid",
	2:  "queueType",
	3:  "tier",
	4:  "rank",
	5:  "leaguePoints",
	6:  "wins",
	7:  "losses",
	8:  "hotStreak",
	9:  "veteran",
	10: "freshBlood",
	11: "inactive",
	12: "miniSeries",
	13: "summonerId",
}

// Decode decodes LeagueV4LeagueEntryDTO from json.
func (s *LeagueV4LeagueEntryDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeagueV4LeagueEntryDTO to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "leagueId":
			if err := func() error {
				s.LeagueId.Reset()
				if err := s.LeagueId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leagueId\"")
			}
		case "puuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "queueType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.QueueType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queueType\"")
			}
		case "tier":
			if err := func() error {
				s.Tier.Reset()
				if err := s.Tier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier\"")
			}
		case "rank":
			if err := func() error {
				s.Rank.Reset()
				if err := s.Rank.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rank\"")
			}
		case "leaguePoints":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.LeaguePoints = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leaguePoints\"")
			}
		case "wins":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.Wins = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wins\"")
			}
		case "losses":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.Losses = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"losses\"")
			}
		case "hotStreak":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.HotStreak = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hotStreak\"")
			}
		case "veteran":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Veteran = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"veteran\"")
			}
		case "freshBlood":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.FreshBlood = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"freshBlood\"")
			}
		case "inactive":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Inactive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inactive\"")
			}
		case "miniSeries":
			if err := func() error {
				s.MiniSeries.Reset()
				if err := s.MiniSeries.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"miniSeries\"")
			}
		case "summonerId":
			if err := func() error {
				s.SummonerId.Reset()
				if err := s.SummonerId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summonerId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeagueV4LeagueEntryDTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11100110,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLeagueV4LeagueEntryDTO) {
					name = jsonFieldsNameOfLeagueV4LeagueEntryDTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeagueV4LeagueEntryDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeagueV4LeagueEntryDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeagueV4LeagueItemDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeagueV4LeagueItemDTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("freshBlood")
		e.Bool(s.FreshBlood)
	}
	{
		e.FieldStart("wins")
		e.Int32(s.Wins)
	}
	{
		if s.MiniSeries.Set {
			e.FieldStart("miniSeries")
			s.MiniSeries.Encode(e)
		}
	}
	{
		e.FieldStart("inactive")
		e.Bool(s.Inactive)
	}
	{
		e.FieldStart("veteran")
		e.Bool(s.Veteran)
	}
	{
		e.FieldStart("hotStreak")
		e.Bool(s.HotStreak)
	}
	{
		e.FieldStart("rank")
		e.Str(s.Rank)
	}
	{
		e.FieldStart("leaguePoints")
		e.Int32(s.LeaguePoints)
	}
	{
		e.FieldStart("losses")
		e.Int32(s.Losses)
	}
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		if s.SummonerId.Set {
			e.FieldStart("summonerId")
			s.SummonerId.Encode(e)
		}
	}
}

var jsonFieldsNameOfLeagueV4LeagueItemDTO = [11]string{
	0:  "freshBlood",
	1:  "wins",
	2:  "miniSeries",
	3:  "inactive",
	4:  "veteran",
	5:  "hotStreak",
	6:  "rank",
	7:  "leaguePoints",
	8:  "losses",
	9:  "puuid",
	10: "summonerId",
}

// Decode decodes LeagueV4LeagueItemDTO from json.
func (s *LeagueV4LeagueItemDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeagueV4LeagueItemDTO to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "freshBlood":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.FreshBlood = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"freshBlood\"")
			}
		case "wins":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Wins = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wins\"")
			}
		case "miniSeries":
			if err := func() error {
				s.MiniSeries.Reset()
				if err := s.MiniSeries.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"miniSeries\"")
			}
		case "inactive":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Inactive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inactive\"")
			}
		case "veteran":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Veteran = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"veteran\"")
			}
		case "hotStreak":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.HotStreak = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hotStreak\"")
			}
		case "rank":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Rank = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rank\"")
			}
		case "leaguePoints":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.LeaguePoints = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leaguePoints\"")
			}
		case "losses":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Losses = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"losses\"")
			}
		case "puuid":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "summonerId":
			if err := func() error {
				s.SummonerId.Reset()
				if err := s.SummonerId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summonerId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeagueV4LeagueItemDTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111011,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLeagueV4LeagueItemDTO) {
					name = jsonFieldsNameOfLeagueV4LeagueItemDTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeagueV4LeagueItemDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeagueV4LeagueItemDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeagueV4LeagueListDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeagueV4LeagueListDTO) encodeFields(e *jx.Encoder) {
	{
		if s.LeagueId.Set {
			e.FieldStart("leagueId")
			s.LeagueId.Encode(e)
		}
	}
	{
		e.FieldStart("entries")
		e.ArrStart()
		for _, elem := range s.Entries {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("tier")
		e.Str(s.Tier)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Queue.Set {
			e.FieldStart("queue")
			s.Queue.Encode(e)
		}
	}
}

var jsonFieldsNameOfLeagueV4LeagueListDTO = [5]string{
	0: "leagueId",
	1: "entries",
	2: "tier",
	3: "name",
	4: "queue",
}

// Decode decodes LeagueV4LeagueListDTO from json.
func (s *LeagueV4LeagueListDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeagueV4LeagueListDTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "leagueId":
			if err := func() error {
				s.LeagueId.Reset()
				if err := s.LeagueId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leagueId\"")
			}
		case "entries":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Entries = make([]LeagueV4LeagueItemDTO, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LeagueV4LeagueItemDTO
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Entries = append(s.Entries, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entries\"")
			}
		case "tier":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tier = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "queue":
			if err := func() error {
				s.Queue.Reset()
				if err := s.Queue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeagueV4LeagueListDTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLeagueV4LeagueListDTO) {
					name = jsonFieldsNameOfLeagueV4LeagueListDTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeagueV4LeagueListDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeagueV4LeagueListDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeagueV4MiniSeriesDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeagueV4MiniSeriesDTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("losses")
		e.Int32(s.Losses)
	}
	{
		e.FieldStart("progress")
		e.Str(s.Progress)
	}
	{
		e.FieldStart("target")
		e.Int32(s.Target)
	}
	{
		e.FieldStart("wins")
		e.Int32(s.Wins)
	}
}

var jsonFieldsNameOfLeagueV4MiniSeriesDTO = [4]string{
	0: "losses",
	1: "progress",
	2: "target",
	3: "wins",
}

// Decode decodes LeagueV4MiniSeriesDTO from json.
func (s *LeagueV4MiniSeriesDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeagueV4MiniSeriesDTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "losses":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Losses = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"losses\"")
			}
		case "progress":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Progress = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress\"")
			}
		case "target":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Target = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		case "wins":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Wins = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wins\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeagueV4MiniSeriesDTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLeagueV4MiniSeriesDTO) {
					name = jsonFieldsNameOfLeagueV4MiniSeriesDTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeagueV4MiniSeriesDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeagueV4MiniSeriesDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LolChallengesV1ApexPlayerInfoDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LolChallengesV1ApexPlayerInfoDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		e.FieldStart("value")
		e.Float64(s.Value)
	}
	{
		e.FieldStart("position")
		e.Int32(s.Position)
	}
}

var jsonFieldsNameOfLolChallengesV1ApexPlayerInfoDto = [3]string{
	0: "puuid",
	1: "value",
	2: "position",
}

// Decode decodes LolChallengesV1ApexPlayerInfoDto from json.
func (s *LolChallengesV1ApexPlayerInfoDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolChallengesV1ApexPlayerInfoDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "puuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Value = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "position":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Position = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LolChallengesV1ApexPlayerInfoDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLolChallengesV1ApexPlayerInfoDto) {
					name = jsonFieldsNameOfLolChallengesV1ApexPlayerInfoDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LolChallengesV1ApexPlayerInfoDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolChallengesV1ApexPlayerInfoDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LolChallengesV1ChallengeConfigInfoDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LolChallengesV1ChallengeConfigInfoDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int64(s.ID)
	}
	{
		e.FieldStart("localizedNames")
		s.LocalizedNames.Encode(e)
	}
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
	{
		if s.Tracking.Set {
			e.FieldStart("tracking")
			s.Tracking.Encode(e)
		}
	}
	{
		if s.StartTimestamp.Set {
			e.FieldStart("startTimestamp")
			s.StartTimestamp.Encode(e)
		}
	}
	{
		if s.EndTimestamp.Set {
			e.FieldStart("endTimestamp")
			s.EndTimestamp.Encode(e)
		}
	}
	{
		e.FieldStart("leaderboard")
		e.Bool(s.Leaderboard)
	}
	{
		e.FieldStart("thresholds")
		s.Thresholds.Encode(e)
	}
}

var jsonFieldsNameOfLolChallengesV1ChallengeConfigInfoDto = [8]string{
	0: "id",
	1: "localizedNames",
	2: "state",
	3: "tracking",
	4: "startTimestamp",
	5: "endTimestamp",
	6: "leaderboard",
	7: "thresholds",
}

// Decode decodes LolChallengesV1ChallengeConfigInfoDto from json.
func (s *LolChallengesV1ChallengeConfigInfoDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolChallengesV1ChallengeConfigInfoDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "localizedNames":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.LocalizedNames.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"localizedNames\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "tracking":
			if err := func() error {
				s.Tracking.Reset()
				if err := s.Tracking.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tracking\"")
			}
		case "startTimestamp":
			if err := func() error {
				s.StartTimestamp.Reset()
				if err := s.StartTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startTimestamp\"")
			}
		case "endTimestamp":
			if err := func() error {
				s.EndTimestamp.Reset()
				if err := s.EndTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endTimestamp\"")
			}
		case "leaderboard":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Leaderboard = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leaderboard\"")
			}
		case "thresholds":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Thresholds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thresholds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LolChallengesV1ChallengeConfigInfoDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLolChallengesV1ChallengeConfigInfoDto) {
					name = jsonFieldsNameOfLolChallengesV1ChallengeConfigInfoDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LolChallengesV1ChallengeConfigInfoDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolChallengesV1ChallengeConfigInfoDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s LolChallengesV1ChallengeConfigInfoDtoLocalizedNames) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s LolChallengesV1ChallengeConfigInfoDtoLocalizedNames) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes LolChallengesV1ChallengeConfigInfoDtoLocalizedNames from json.
func (s *LolChallengesV1ChallengeConfigInfoDtoLocalizedNames) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolChallengesV1ChallengeConfigInfoDtoLocalizedNames to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem LolChallengesV1ChallengeConfigInfoDtoLocalizedNamesItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LolChallengesV1ChallengeConfigInfoDtoLocalizedNames")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LolChallengesV1ChallengeConfigInfoDtoLocalizedNames) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolChallengesV1ChallengeConfigInfoDtoLocalizedNames) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s LolChallengesV1ChallengeConfigInfoDtoLocalizedNamesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s LolChallengesV1ChallengeConfigInfoDtoLocalizedNamesItem) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes LolChallengesV1ChallengeConfigInfoDtoLocalizedNamesItem from json.
func (s *LolChallengesV1ChallengeConfigInfoDtoLocalizedNamesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolChallengesV1ChallengeConfigInfoDtoLocalizedNamesItem to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LolChallengesV1ChallengeConfigInfoDtoLocalizedNamesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LolChallengesV1ChallengeConfigInfoDtoLocalizedNamesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolChallengesV1ChallengeConfigInfoDtoLocalizedNamesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LolChallengesV1ChallengeConfigInfoDtoState as json.
func (s LolChallengesV1ChallengeConfigInfoDtoState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LolChallengesV1ChallengeConfigInfoDtoState from json.
func (s *LolChallengesV1ChallengeConfigInfoDtoState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolChallengesV1ChallengeConfigInfoDtoState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LolChallengesV1ChallengeConfigInfoDtoState(v) {
	case LolChallengesV1ChallengeConfigInfoDtoStateDISABLED:
		*s = LolChallengesV1ChallengeConfigInfoDtoStateDISABLED
	case LolChallengesV1ChallengeConfigInfoDtoStateHIDDEN:
		*s = LolChallengesV1ChallengeConfigInfoDtoStateHIDDEN
	case LolChallengesV1ChallengeConfigInfoDtoStateENABLED:
		*s = LolChallengesV1ChallengeConfigInfoDtoStateENABLED
	case LolChallengesV1ChallengeConfigInfoDtoStateARCHIVED:
		*s = LolChallengesV1ChallengeConfigInfoDtoStateARCHIVED
	default:
		*s = LolChallengesV1ChallengeConfigInfoDtoState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LolChallengesV1ChallengeConfigInfoDtoState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolChallengesV1ChallengeConfigInfoDtoState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s LolChallengesV1ChallengeConfigInfoDtoThresholds) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s LolChallengesV1ChallengeConfigInfoDtoThresholds) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Float64(elem)
	}
}

// Decode decodes LolChallengesV1ChallengeConfigInfoDtoThresholds from json.
func (s *LolChallengesV1ChallengeConfigInfoDtoThresholds) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolChallengesV1ChallengeConfigInfoDtoThresholds to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem float64
		if err := func() error {
			v, err := d.Float64()
			elem = float64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LolChallengesV1ChallengeConfigInfoDtoThresholds")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LolChallengesV1ChallengeConfigInfoDtoThresholds) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolChallengesV1ChallengeConfigInfoDtoThresholds) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LolChallengesV1ChallengeConfigInfoDtoTracking as json.
func (s LolChallengesV1ChallengeConfigInfoDtoTracking) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LolChallengesV1ChallengeConfigInfoDtoTracking from json.
func (s *LolChallengesV1ChallengeConfigInfoDtoTracking) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolChallengesV1ChallengeConfigInfoDtoTracking to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LolChallengesV1ChallengeConfigInfoDtoTracking(v) {
	case LolChallengesV1ChallengeConfigInfoDtoTrackingLIFETIME:
		*s = LolChallengesV1ChallengeConfigInfoDtoTrackingLIFETIME
	case LolChallengesV1ChallengeConfigInfoDtoTrackingSEASON:
		*s = LolChallengesV1ChallengeConfigInfoDtoTrackingSEASON
	default:
		*s = LolChallengesV1ChallengeConfigInfoDtoTracking(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LolChallengesV1ChallengeConfigInfoDtoTracking) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolChallengesV1ChallengeConfigInfoDtoTracking) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LolChallengesV1ChallengeInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LolChallengesV1ChallengeInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("challengeId")
		e.Int64(s.ChallengeId)
	}
	{
		e.FieldStart("percentile")
		e.Float64(s.Percentile)
	}
	{
		e.FieldStart("level")
		e.Str(s.Level)
	}
	{
		e.FieldStart("value")
		e.Float64(s.Value)
	}
	{
		if s.AchievedTime.Set {
			e.FieldStart("achievedTime")
			s.AchievedTime.Encode(e)
		}
	}
	{
		if s.Position.Set {
			e.FieldStart("position")
			s.Position.Encode(e)
		}
	}
	{
		if s.PlayersInLevel.Set {
			e.FieldStart("playersInLevel")
			s.PlayersInLevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfLolChallengesV1ChallengeInfo = [7]string{
	0: "challengeId",
	1: "percentile",
	2: "level",
	3: "value",
	4: "achievedTime",
	5: "position",
	6: "playersInLevel",
}

// Decode decodes LolChallengesV1ChallengeInfo from json.
func (s *LolChallengesV1ChallengeInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolChallengesV1ChallengeInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "challengeId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ChallengeId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"challengeId\"")
			}
		case "percentile":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Percentile = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"percentile\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Level = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Value = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "achievedTime":
			if err := func() error {
				s.AchievedTime.Reset()
				if err := s.AchievedTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"achievedTime\"")
			}
		case "position":
			if err := func() error {
				s.Position.Reset()
				if err := s.Position.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "playersInLevel":
			if err := func() error {
				s.PlayersInLevel.Reset()
				if err := s.PlayersInLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playersInLevel\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LolChallengesV1ChallengeInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLolChallengesV1ChallengeInfo) {
					name = jsonFieldsNameOfLolChallengesV1ChallengeInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LolChallengesV1ChallengeInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolChallengesV1ChallengeInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LolChallengesV1ChallengePoints) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LolChallengesV1ChallengePoints) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("level")
		e.Str(s.Level)
	}
	{
		e.FieldStart("current")
		e.Int64(s.Current)
	}
	{
		e.FieldStart("max")
		e.Int64(s.Max)
	}
	{
		if s.Percentile.Set {
			e.FieldStart("percentile")
			s.Percentile.Encode(e)
		}
	}
}

var jsonFieldsNameOfLolChallengesV1ChallengePoints = [4]string{
	0: "level",
	1: "current",
	2: "max",
	3: "percentile",
}

// Decode decodes LolChallengesV1ChallengePoints from json.
func (s *LolChallengesV1ChallengePoints) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolChallengesV1ChallengePoints to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "level":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Level = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "current":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Current = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "max":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Max = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max\"")
			}
		case "percentile":
			if err := func() error {
				s.Percentile.Reset()
				if err := s.Percentile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"percentile\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LolChallengesV1ChallengePoints")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLolChallengesV1ChallengePoints) {
					name = jsonFieldsNameOfLolChallengesV1ChallengePoints[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LolChallengesV1ChallengePoints) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolChallengesV1ChallengePoints) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LolChallengesV1GetAllChallengeConfigsOKApplicationJSON as json.
func (s LolChallengesV1GetAllChallengeConfigsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []LolChallengesV1ChallengeConfigInfoDto(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes LolChallengesV1GetAllChallengeConfigsOKApplicationJSON from json.
func (s *LolChallengesV1GetAllChallengeConfigsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolChallengesV1GetAllChallengeConfigsOKApplicationJSON to nil")
	}
	var unwrapped []LolChallengesV1ChallengeConfigInfoDto
	if err := func() error {
		unwrapped = make([]LolChallengesV1ChallengeConfigInfoDto, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem LolChallengesV1ChallengeConfigInfoDto
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LolChallengesV1GetAllChallengeConfigsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LolChallengesV1GetAllChallengeConfigsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolChallengesV1GetAllChallengeConfigsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s LolChallengesV1GetAllChallengePercentilesOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s LolChallengesV1GetAllChallengePercentilesOK) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes LolChallengesV1GetAllChallengePercentilesOK from json.
func (s *LolChallengesV1GetAllChallengePercentilesOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolChallengesV1GetAllChallengePercentilesOK to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem LolChallengesV1GetAllChallengePercentilesOKItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LolChallengesV1GetAllChallengePercentilesOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LolChallengesV1GetAllChallengePercentilesOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolChallengesV1GetAllChallengePercentilesOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s LolChallengesV1GetAllChallengePercentilesOKItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s LolChallengesV1GetAllChallengePercentilesOKItem) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Float64(elem)
	}
}

// Decode decodes LolChallengesV1GetAllChallengePercentilesOKItem from json.
func (s *LolChallengesV1GetAllChallengePercentilesOKItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolChallengesV1GetAllChallengePercentilesOKItem to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem float64
		if err := func() error {
			v, err := d.Float64()
			elem = float64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LolChallengesV1GetAllChallengePercentilesOKItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LolChallengesV1GetAllChallengePercentilesOKItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolChallengesV1GetAllChallengePercentilesOKItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LolChallengesV1GetChallengeLeaderboardsOKApplicationJSON as json.
func (s LolChallengesV1GetChallengeLeaderboardsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []LolChallengesV1ApexPlayerInfoDto(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes LolChallengesV1GetChallengeLeaderboardsOKApplicationJSON from json.
func (s *LolChallengesV1GetChallengeLeaderboardsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolChallengesV1GetChallengeLeaderboardsOKApplicationJSON to nil")
	}
	var unwrapped []LolChallengesV1ApexPlayerInfoDto
	if err := func() error {
		unwrapped = make([]LolChallengesV1ApexPlayerInfoDto, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem LolChallengesV1ApexPlayerInfoDto
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LolChallengesV1GetChallengeLeaderboardsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LolChallengesV1GetChallengeLeaderboardsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolChallengesV1GetChallengeLeaderboardsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s LolChallengesV1GetChallengePercentilesOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s LolChallengesV1GetChallengePercentilesOK) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Float64(elem)
	}
}

// Decode decodes LolChallengesV1GetChallengePercentilesOK from json.
func (s *LolChallengesV1GetChallengePercentilesOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolChallengesV1GetChallengePercentilesOK to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem float64
		if err := func() error {
			v, err := d.Float64()
			elem = float64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LolChallengesV1GetChallengePercentilesOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LolChallengesV1GetChallengePercentilesOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolChallengesV1GetChallengePercentilesOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LolChallengesV1PlayerClientPreferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LolChallengesV1PlayerClientPreferences) encodeFields(e *jx.Encoder) {
	{
		if s.BannerAccent.Set {
			e.FieldStart("bannerAccent")
			s.BannerAccent.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.ChallengeIds != nil {
			e.FieldStart("challengeIds")
			e.ArrStart()
			for _, elem := range s.ChallengeIds {
				e.Int64(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CrestBorder.Set {
			e.FieldStart("crestBorder")
			s.CrestBorder.Encode(e)
		}
	}
	{
		if s.PrestigeCrestBorderLevel.Set {
			e.FieldStart("prestigeCrestBorderLevel")
			s.PrestigeCrestBorderLevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfLolChallengesV1PlayerClientPreferences = [5]string{
	0: "bannerAccent",
	1: "title",
	2: "challengeIds",
	3: "crestBorder",
	4: "prestigeCrestBorderLevel",
}

// Decode decodes LolChallengesV1PlayerClientPreferences from json.
func (s *LolChallengesV1PlayerClientPreferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolChallengesV1PlayerClientPreferences to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bannerAccent":
			if err := func() error {
				s.BannerAccent.Reset()
				if err := s.BannerAccent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bannerAccent\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "challengeIds":
			if err := func() error {
				s.ChallengeIds = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int64
					v, err := d.Int64()
					elem = int64(v)
					if err != nil {
						return err
					}
					s.ChallengeIds = append(s.ChallengeIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"challengeIds\"")
			}
		case "crestBorder":
			if err := func() error {
				s.CrestBorder.Reset()
				if err := s.CrestBorder.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"crestBorder\"")
			}
		case "prestigeCrestBorderLevel":
			if err := func() error {
				s.PrestigeCrestBorderLevel.Reset()
				if err := s.PrestigeCrestBorderLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prestigeCrestBorderLevel\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LolChallengesV1PlayerClientPreferences")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LolChallengesV1PlayerClientPreferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolChallengesV1PlayerClientPreferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LolChallengesV1PlayerInfoDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LolChallengesV1PlayerInfoDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("challenges")
		e.ArrStart()
		for _, elem := range s.Challenges {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("preferences")
		s.Preferences.Encode(e)
	}
	{
		e.FieldStart("totalPoints")
		s.TotalPoints.Encode(e)
	}
	{
		e.FieldStart("categoryPoints")
		s.CategoryPoints.Encode(e)
	}
}

var jsonFieldsNameOfLolChallengesV1PlayerInfoDto = [4]string{
	0: "challenges",
	1: "preferences",
	2: "totalPoints",
	3: "categoryPoints",
}

// Decode decodes LolChallengesV1PlayerInfoDto from json.
func (s *LolChallengesV1PlayerInfoDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolChallengesV1PlayerInfoDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "challenges":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Challenges = make([]LolChallengesV1ChallengeInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LolChallengesV1ChallengeInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Challenges = append(s.Challenges, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"challenges\"")
			}
		case "preferences":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Preferences.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferences\"")
			}
		case "totalPoints":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.TotalPoints.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalPoints\"")
			}
		case "categoryPoints":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.CategoryPoints.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categoryPoints\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LolChallengesV1PlayerInfoDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLolChallengesV1PlayerInfoDto) {
					name = jsonFieldsNameOfLolChallengesV1PlayerInfoDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LolChallengesV1PlayerInfoDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolChallengesV1PlayerInfoDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s LolChallengesV1PlayerInfoDtoCategoryPoints) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s LolChallengesV1PlayerInfoDtoCategoryPoints) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes LolChallengesV1PlayerInfoDtoCategoryPoints from json.
func (s *LolChallengesV1PlayerInfoDtoCategoryPoints) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolChallengesV1PlayerInfoDtoCategoryPoints to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem LolChallengesV1ChallengePoints
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LolChallengesV1PlayerInfoDtoCategoryPoints")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LolChallengesV1PlayerInfoDtoCategoryPoints) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolChallengesV1PlayerInfoDtoCategoryPoints) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LolRsoMatchV1GetMatchIdsOKApplicationJSON as json.
func (s LolRsoMatchV1GetMatchIdsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []string(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes LolRsoMatchV1GetMatchIdsOKApplicationJSON from json.
func (s *LolRsoMatchV1GetMatchIdsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolRsoMatchV1GetMatchIdsOKApplicationJSON to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LolRsoMatchV1GetMatchIdsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LolRsoMatchV1GetMatchIdsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolRsoMatchV1GetMatchIdsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LolStatusV4ContentDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LolStatusV4ContentDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("locale")
		e.Str(s.Locale)
	}
	{
		e.FieldStart("content")
		e.Str(s.Content)
	}
}

var jsonFieldsNameOfLolStatusV4ContentDto = [2]string{
	0: "locale",
	1: "content",
}

// Decode decodes LolStatusV4ContentDto from json.
func (s *LolStatusV4ContentDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolStatusV4ContentDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "locale":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Locale = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locale\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LolStatusV4ContentDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLolStatusV4ContentDto) {
					name = jsonFieldsNameOfLolStatusV4ContentDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LolStatusV4ContentDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolStatusV4ContentDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LolStatusV4PlatformDataDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LolStatusV4PlatformDataDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("locales")
		e.ArrStart()
		for _, elem := range s.Locales {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("maintenances")
		e.ArrStart()
		for _, elem := range s.Maintenances {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("incidents")
		e.ArrStart()
		for _, elem := range s.Incidents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfLolStatusV4PlatformDataDto = [5]string{
	0: "id",
	1: "name",
	2: "locales",
	3: "maintenances",
	4: "incidents",
}

// Decode decodes LolStatusV4PlatformDataDto from json.
func (s *LolStatusV4PlatformDataDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolStatusV4PlatformDataDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "locales":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Locales = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Locales = append(s.Locales, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locales\"")
			}
		case "maintenances":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Maintenances = make([]LolStatusV4StatusDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LolStatusV4StatusDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Maintenances = append(s.Maintenances, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenances\"")
			}
		case "incidents":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Incidents = make([]LolStatusV4StatusDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LolStatusV4StatusDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Incidents = append(s.Incidents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incidents\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LolStatusV4PlatformDataDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLolStatusV4PlatformDataDto) {
					name = jsonFieldsNameOfLolStatusV4PlatformDataDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LolStatusV4PlatformDataDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolStatusV4PlatformDataDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LolStatusV4StatusDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LolStatusV4StatusDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int32(s.ID)
	}
	{
		if s.MaintenanceStatus.Set {
			e.FieldStart("maintenance_status")
			s.MaintenanceStatus.Encode(e)
		}
	}
	{
		if s.IncidentSeverity.Set {
			e.FieldStart("incident_severity")
			s.IncidentSeverity.Encode(e)
		}
	}
	{
		e.FieldStart("titles")
		e.ArrStart()
		for _, elem := range s.Titles {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("updates")
		e.ArrStart()
		for _, elem := range s.Updates {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("created_at")
		e.Str(s.CreatedAt)
	}
	{
		if s.ArchiveAt.Set {
			e.FieldStart("archive_at")
			s.ArchiveAt.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e)
		}
	}
	{
		e.FieldStart("platforms")
		e.ArrStart()
		for _, elem := range s.Platforms {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfLolStatusV4StatusDto = [9]string{
	0: "id",
	1: "maintenance_status",
	2: "incident_severity",
	3: "titles",
	4: "updates",
	5: "created_at",
	6: "archive_at",
	7: "updated_at",
	8: "platforms",
}

// Decode decodes LolStatusV4StatusDto from json.
func (s *LolStatusV4StatusDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolStatusV4StatusDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ID = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "maintenance_status":
			if err := func() error {
				s.MaintenanceStatus.Reset()
				if err := s.MaintenanceStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenance_status\"")
			}
		case "incident_severity":
			if err := func() error {
				s.IncidentSeverity.Reset()
				if err := s.IncidentSeverity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incident_severity\"")
			}
		case "titles":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Titles = make([]LolStatusV4ContentDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LolStatusV4ContentDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Titles = append(s.Titles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"titles\"")
			}
		case "updates":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Updates = make([]LolStatusV4UpdateDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LolStatusV4UpdateDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Updates = append(s.Updates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updates\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "archive_at":
			if err := func() error {
				s.ArchiveAt.Reset()
				if err := s.ArchiveAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "platforms":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.Platforms = make([]LolStatusV4StatusDtoPlatformsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LolStatusV4StatusDtoPlatformsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Platforms = append(s.Platforms, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platforms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LolStatusV4StatusDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111001,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLolStatusV4StatusDto) {
					name = jsonFieldsNameOfLolStatusV4StatusDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LolStatusV4StatusDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolStatusV4StatusDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LolStatusV4StatusDtoIncidentSeverity as json.
func (s LolStatusV4StatusDtoIncidentSeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LolStatusV4StatusDtoIncidentSeverity from json.
func (s *LolStatusV4StatusDtoIncidentSeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolStatusV4StatusDtoIncidentSeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LolStatusV4StatusDtoIncidentSeverity(v) {
	case LolStatusV4StatusDtoIncidentSeverityInfo:
		*s = LolStatusV4StatusDtoIncidentSeverityInfo
	case LolStatusV4StatusDtoIncidentSeverityWarning:
		*s = LolStatusV4StatusDtoIncidentSeverityWarning
	case LolStatusV4StatusDtoIncidentSeverityCritical:
		*s = LolStatusV4StatusDtoIncidentSeverityCritical
	default:
		*s = LolStatusV4StatusDtoIncidentSeverity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LolStatusV4StatusDtoIncidentSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolStatusV4StatusDtoIncidentSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LolStatusV4StatusDtoMaintenanceStatus as json.
func (s LolStatusV4StatusDtoMaintenanceStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LolStatusV4StatusDtoMaintenanceStatus from json.
func (s *LolStatusV4StatusDtoMaintenanceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolStatusV4StatusDtoMaintenanceStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LolStatusV4StatusDtoMaintenanceStatus(v) {
	case LolStatusV4StatusDtoMaintenanceStatusScheduled:
		*s = LolStatusV4StatusDtoMaintenanceStatusScheduled
	case LolStatusV4StatusDtoMaintenanceStatusInProgress:
		*s = LolStatusV4StatusDtoMaintenanceStatusInProgress
	case LolStatusV4StatusDtoMaintenanceStatusComplete:
		*s = LolStatusV4StatusDtoMaintenanceStatusComplete
	default:
		*s = LolStatusV4StatusDtoMaintenanceStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LolStatusV4StatusDtoMaintenanceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolStatusV4StatusDtoMaintenanceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LolStatusV4StatusDtoPlatformsItem as json.
func (s LolStatusV4StatusDtoPlatformsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LolStatusV4StatusDtoPlatformsItem from json.
func (s *LolStatusV4StatusDtoPlatformsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolStatusV4StatusDtoPlatformsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LolStatusV4StatusDtoPlatformsItem(v) {
	case LolStatusV4StatusDtoPlatformsItemWindows:
		*s = LolStatusV4StatusDtoPlatformsItemWindows
	case LolStatusV4StatusDtoPlatformsItemMacos:
		*s = LolStatusV4StatusDtoPlatformsItemMacos
	case LolStatusV4StatusDtoPlatformsItemAndroid:
		*s = LolStatusV4StatusDtoPlatformsItemAndroid
	case LolStatusV4StatusDtoPlatformsItemIos:
		*s = LolStatusV4StatusDtoPlatformsItemIos
	case LolStatusV4StatusDtoPlatformsItemPs4:
		*s = LolStatusV4StatusDtoPlatformsItemPs4
	case LolStatusV4StatusDtoPlatformsItemXbone:
		*s = LolStatusV4StatusDtoPlatformsItemXbone
	case LolStatusV4StatusDtoPlatformsItemSwitch:
		*s = LolStatusV4StatusDtoPlatformsItemSwitch
	default:
		*s = LolStatusV4StatusDtoPlatformsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LolStatusV4StatusDtoPlatformsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolStatusV4StatusDtoPlatformsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LolStatusV4UpdateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LolStatusV4UpdateDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int32(s.ID)
	}
	{
		e.FieldStart("author")
		e.Str(s.Author)
	}
	{
		e.FieldStart("publish")
		e.Bool(s.Publish)
	}
	{
		e.FieldStart("publish_locations")
		e.ArrStart()
		for _, elem := range s.PublishLocations {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("translations")
		e.ArrStart()
		for _, elem := range s.Translations {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("created_at")
		e.Str(s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		e.Str(s.UpdatedAt)
	}
}

var jsonFieldsNameOfLolStatusV4UpdateDto = [7]string{
	0: "id",
	1: "author",
	2: "publish",
	3: "publish_locations",
	4: "translations",
	5: "created_at",
	6: "updated_at",
}

// Decode decodes LolStatusV4UpdateDto from json.
func (s *LolStatusV4UpdateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolStatusV4UpdateDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ID = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "author":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Author = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "publish":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Publish = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publish\"")
			}
		case "publish_locations":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.PublishLocations = make([]LolStatusV4UpdateDtoPublishLocationsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LolStatusV4UpdateDtoPublishLocationsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PublishLocations = append(s.PublishLocations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publish_locations\"")
			}
		case "translations":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Translations = make([]LolStatusV4ContentDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LolStatusV4ContentDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Translations = append(s.Translations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"translations\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LolStatusV4UpdateDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLolStatusV4UpdateDto) {
					name = jsonFieldsNameOfLolStatusV4UpdateDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LolStatusV4UpdateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolStatusV4UpdateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LolStatusV4UpdateDtoPublishLocationsItem as json.
func (s LolStatusV4UpdateDtoPublishLocationsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LolStatusV4UpdateDtoPublishLocationsItem from json.
func (s *LolStatusV4UpdateDtoPublishLocationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LolStatusV4UpdateDtoPublishLocationsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LolStatusV4UpdateDtoPublishLocationsItem(v) {
	case LolStatusV4UpdateDtoPublishLocationsItemRiotclient:
		*s = LolStatusV4UpdateDtoPublishLocationsItemRiotclient
	case LolStatusV4UpdateDtoPublishLocationsItemRiotstatus:
		*s = LolStatusV4UpdateDtoPublishLocationsItemRiotstatus
	case LolStatusV4UpdateDtoPublishLocationsItemGame:
		*s = LolStatusV4UpdateDtoPublishLocationsItemGame
	default:
		*s = LolStatusV4UpdateDtoPublishLocationsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LolStatusV4UpdateDtoPublishLocationsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LolStatusV4UpdateDtoPublishLocationsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LorDeckV1CreateDeckOKApplicationJSON as json.
func (s LorDeckV1CreateDeckOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes LorDeckV1CreateDeckOKApplicationJSON from json.
func (s *LorDeckV1CreateDeckOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorDeckV1CreateDeckOKApplicationJSON to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LorDeckV1CreateDeckOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LorDeckV1CreateDeckOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorDeckV1CreateDeckOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LorDeckV1DeckDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LorDeckV1DeckDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
}

var jsonFieldsNameOfLorDeckV1DeckDto = [3]string{
	0: "id",
	1: "name",
	2: "code",
}

// Decode decodes LorDeckV1DeckDto from json.
func (s *LorDeckV1DeckDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorDeckV1DeckDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LorDeckV1DeckDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLorDeckV1DeckDto) {
					name = jsonFieldsNameOfLorDeckV1DeckDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LorDeckV1DeckDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorDeckV1DeckDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LorDeckV1GetDecksOKApplicationJSON as json.
func (s LorDeckV1GetDecksOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []LorDeckV1DeckDto(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes LorDeckV1GetDecksOKApplicationJSON from json.
func (s *LorDeckV1GetDecksOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorDeckV1GetDecksOKApplicationJSON to nil")
	}
	var unwrapped []LorDeckV1DeckDto
	if err := func() error {
		unwrapped = make([]LorDeckV1DeckDto, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem LorDeckV1DeckDto
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LorDeckV1GetDecksOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LorDeckV1GetDecksOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorDeckV1GetDecksOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LorDeckV1NewDeckDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LorDeckV1NewDeckDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
}

var jsonFieldsNameOfLorDeckV1NewDeckDto = [2]string{
	0: "name",
	1: "code",
}

// Decode decodes LorDeckV1NewDeckDto from json.
func (s *LorDeckV1NewDeckDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorDeckV1NewDeckDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LorDeckV1NewDeckDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLorDeckV1NewDeckDto) {
					name = jsonFieldsNameOfLorDeckV1NewDeckDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LorDeckV1NewDeckDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorDeckV1NewDeckDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LorInventoryV1CardDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LorInventoryV1CardDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("count")
		e.Str(s.Count)
	}
}

var jsonFieldsNameOfLorInventoryV1CardDto = [2]string{
	0: "code",
	1: "count",
}

// Decode decodes LorInventoryV1CardDto from json.
func (s *LorInventoryV1CardDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorInventoryV1CardDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "count":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Count = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LorInventoryV1CardDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLorInventoryV1CardDto) {
					name = jsonFieldsNameOfLorInventoryV1CardDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LorInventoryV1CardDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorInventoryV1CardDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LorInventoryV1GetCardsOKApplicationJSON as json.
func (s LorInventoryV1GetCardsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []LorInventoryV1CardDto(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes LorInventoryV1GetCardsOKApplicationJSON from json.
func (s *LorInventoryV1GetCardsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorInventoryV1GetCardsOKApplicationJSON to nil")
	}
	var unwrapped []LorInventoryV1CardDto
	if err := func() error {
		unwrapped = make([]LorInventoryV1CardDto, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem LorInventoryV1CardDto
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LorInventoryV1GetCardsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LorInventoryV1GetCardsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorInventoryV1GetCardsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LorMatchV1GetMatchIdsByPUUIDOKApplicationJSON as json.
func (s LorMatchV1GetMatchIdsByPUUIDOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []string(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes LorMatchV1GetMatchIdsByPUUIDOKApplicationJSON from json.
func (s *LorMatchV1GetMatchIdsByPUUIDOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorMatchV1GetMatchIdsByPUUIDOKApplicationJSON to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LorMatchV1GetMatchIdsByPUUIDOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LorMatchV1GetMatchIdsByPUUIDOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorMatchV1GetMatchIdsByPUUIDOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LorMatchV1InfoDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LorMatchV1InfoDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("game_mode")
		s.GameMode.Encode(e)
	}
	{
		e.FieldStart("game_type")
		s.GameType.Encode(e)
	}
	{
		e.FieldStart("game_start_time_utc")
		e.Str(s.GameStartTimeUtc)
	}
	{
		e.FieldStart("game_version")
		e.Str(s.GameVersion)
	}
	{
		e.FieldStart("game_format")
		s.GameFormat.Encode(e)
	}
	{
		e.FieldStart("players")
		e.ArrStart()
		for _, elem := range s.Players {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total_turn_count")
		e.Int32(s.TotalTurnCount)
	}
}

var jsonFieldsNameOfLorMatchV1InfoDto = [7]string{
	0: "game_mode",
	1: "game_type",
	2: "game_start_time_utc",
	3: "game_version",
	4: "game_format",
	5: "players",
	6: "total_turn_count",
}

// Decode decodes LorMatchV1InfoDto from json.
func (s *LorMatchV1InfoDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorMatchV1InfoDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "game_mode":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.GameMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_mode\"")
			}
		case "game_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.GameType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_type\"")
			}
		case "game_start_time_utc":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GameStartTimeUtc = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_start_time_utc\"")
			}
		case "game_version":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.GameVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_version\"")
			}
		case "game_format":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.GameFormat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_format\"")
			}
		case "players":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Players = make([]LorMatchV1PlayerDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LorMatchV1PlayerDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Players = append(s.Players, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"players\"")
			}
		case "total_turn_count":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.TotalTurnCount = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_turn_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LorMatchV1InfoDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLorMatchV1InfoDto) {
					name = jsonFieldsNameOfLorMatchV1InfoDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LorMatchV1InfoDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorMatchV1InfoDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LorMatchV1InfoDtoGameFormat as json.
func (s LorMatchV1InfoDtoGameFormat) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LorMatchV1InfoDtoGameFormat from json.
func (s *LorMatchV1InfoDtoGameFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorMatchV1InfoDtoGameFormat to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LorMatchV1InfoDtoGameFormat(v) {
	case LorMatchV1InfoDtoGameFormatStandard:
		*s = LorMatchV1InfoDtoGameFormatStandard
	case LorMatchV1InfoDtoGameFormatEternal:
		*s = LorMatchV1InfoDtoGameFormatEternal
	default:
		*s = LorMatchV1InfoDtoGameFormat(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LorMatchV1InfoDtoGameFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorMatchV1InfoDtoGameFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LorMatchV1InfoDtoGameMode as json.
func (s LorMatchV1InfoDtoGameMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LorMatchV1InfoDtoGameMode from json.
func (s *LorMatchV1InfoDtoGameMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorMatchV1InfoDtoGameMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LorMatchV1InfoDtoGameMode(v) {
	case LorMatchV1InfoDtoGameModeConstructed:
		*s = LorMatchV1InfoDtoGameModeConstructed
	case LorMatchV1InfoDtoGameModeExpeditions:
		*s = LorMatchV1InfoDtoGameModeExpeditions
	case LorMatchV1InfoDtoGameModeTutorial:
		*s = LorMatchV1InfoDtoGameModeTutorial
	default:
		*s = LorMatchV1InfoDtoGameMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LorMatchV1InfoDtoGameMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorMatchV1InfoDtoGameMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LorMatchV1InfoDtoGameType as json.
func (s LorMatchV1InfoDtoGameType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LorMatchV1InfoDtoGameType from json.
func (s *LorMatchV1InfoDtoGameType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorMatchV1InfoDtoGameType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LorMatchV1InfoDtoGameType(v) {
	case LorMatchV1InfoDtoGameTypeRanked:
		*s = LorMatchV1InfoDtoGameTypeRanked
	case LorMatchV1InfoDtoGameTypeNormal:
		*s = LorMatchV1InfoDtoGameTypeNormal
	case LorMatchV1InfoDtoGameTypeAI:
		*s = LorMatchV1InfoDtoGameTypeAI
	case LorMatchV1InfoDtoGameTypeTutorial:
		*s = LorMatchV1InfoDtoGameTypeTutorial
	case LorMatchV1InfoDtoGameTypeVanillaTrial:
		*s = LorMatchV1InfoDtoGameTypeVanillaTrial
	case LorMatchV1InfoDtoGameTypeSingleton:
		*s = LorMatchV1InfoDtoGameTypeSingleton
	case LorMatchV1InfoDtoGameTypeStandardGauntlet:
		*s = LorMatchV1InfoDtoGameTypeStandardGauntlet
	default:
		*s = LorMatchV1InfoDtoGameType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LorMatchV1InfoDtoGameType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorMatchV1InfoDtoGameType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LorMatchV1MatchDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LorMatchV1MatchDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		e.FieldStart("info")
		s.Info.Encode(e)
	}
}

var jsonFieldsNameOfLorMatchV1MatchDto = [2]string{
	0: "metadata",
	1: "info",
}

// Decode decodes LorMatchV1MatchDto from json.
func (s *LorMatchV1MatchDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorMatchV1MatchDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "info":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LorMatchV1MatchDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLorMatchV1MatchDto) {
					name = jsonFieldsNameOfLorMatchV1MatchDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LorMatchV1MatchDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorMatchV1MatchDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LorMatchV1MetadataDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LorMatchV1MetadataDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data_version")
		e.Str(s.DataVersion)
	}
	{
		e.FieldStart("match_id")
		e.Str(s.MatchID)
	}
	{
		e.FieldStart("participants")
		e.ArrStart()
		for _, elem := range s.Participants {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfLorMatchV1MetadataDto = [3]string{
	0: "data_version",
	1: "match_id",
	2: "participants",
}

// Decode decodes LorMatchV1MetadataDto from json.
func (s *LorMatchV1MetadataDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorMatchV1MetadataDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data_version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DataVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_version\"")
			}
		case "match_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.MatchID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"match_id\"")
			}
		case "participants":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Participants = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Participants = append(s.Participants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participants\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LorMatchV1MetadataDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLorMatchV1MetadataDto) {
					name = jsonFieldsNameOfLorMatchV1MetadataDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LorMatchV1MetadataDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorMatchV1MetadataDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LorMatchV1PlayerDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LorMatchV1PlayerDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		e.FieldStart("deck_id")
		e.Str(s.DeckID)
	}
	{
		e.FieldStart("deck_code")
		e.Str(s.DeckCode)
	}
	{
		e.FieldStart("factions")
		e.ArrStart()
		for _, elem := range s.Factions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("game_outcome")
		e.Str(s.GameOutcome)
	}
	{
		e.FieldStart("order_of_play")
		e.Int32(s.OrderOfPlay)
	}
}

var jsonFieldsNameOfLorMatchV1PlayerDto = [6]string{
	0: "puuid",
	1: "deck_id",
	2: "deck_code",
	3: "factions",
	4: "game_outcome",
	5: "order_of_play",
}

// Decode decodes LorMatchV1PlayerDto from json.
func (s *LorMatchV1PlayerDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorMatchV1PlayerDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "puuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "deck_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DeckID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deck_id\"")
			}
		case "deck_code":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DeckCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deck_code\"")
			}
		case "factions":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Factions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Factions = append(s.Factions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"factions\"")
			}
		case "game_outcome":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.GameOutcome = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_outcome\"")
			}
		case "order_of_play":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.OrderOfPlay = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order_of_play\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LorMatchV1PlayerDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLorMatchV1PlayerDto) {
					name = jsonFieldsNameOfLorMatchV1PlayerDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LorMatchV1PlayerDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorMatchV1PlayerDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LorRankedV1LeaderboardDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LorRankedV1LeaderboardDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("players")
		e.ArrStart()
		for _, elem := range s.Players {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfLorRankedV1LeaderboardDto = [1]string{
	0: "players",
}

// Decode decodes LorRankedV1LeaderboardDto from json.
func (s *LorRankedV1LeaderboardDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorRankedV1LeaderboardDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "players":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Players = make([]LorRankedV1PlayerDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LorRankedV1PlayerDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Players = append(s.Players, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"players\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LorRankedV1LeaderboardDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLorRankedV1LeaderboardDto) {
					name = jsonFieldsNameOfLorRankedV1LeaderboardDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LorRankedV1LeaderboardDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorRankedV1LeaderboardDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LorRankedV1PlayerDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LorRankedV1PlayerDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("rank")
		e.Int32(s.Rank)
	}
	{
		e.FieldStart("lp")
		e.Int32(s.Lp)
	}
}

var jsonFieldsNameOfLorRankedV1PlayerDto = [3]string{
	0: "name",
	1: "rank",
	2: "lp",
}

// Decode decodes LorRankedV1PlayerDto from json.
func (s *LorRankedV1PlayerDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorRankedV1PlayerDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "rank":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Rank = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rank\"")
			}
		case "lp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Lp = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LorRankedV1PlayerDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLorRankedV1PlayerDto) {
					name = jsonFieldsNameOfLorRankedV1PlayerDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LorRankedV1PlayerDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorRankedV1PlayerDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LorStatusV1ContentDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LorStatusV1ContentDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("locale")
		e.Str(s.Locale)
	}
	{
		e.FieldStart("content")
		e.Str(s.Content)
	}
}

var jsonFieldsNameOfLorStatusV1ContentDto = [2]string{
	0: "locale",
	1: "content",
}

// Decode decodes LorStatusV1ContentDto from json.
func (s *LorStatusV1ContentDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorStatusV1ContentDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "locale":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Locale = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locale\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LorStatusV1ContentDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLorStatusV1ContentDto) {
					name = jsonFieldsNameOfLorStatusV1ContentDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LorStatusV1ContentDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorStatusV1ContentDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LorStatusV1PlatformDataDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LorStatusV1PlatformDataDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("locales")
		e.ArrStart()
		for _, elem := range s.Locales {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("maintenances")
		e.ArrStart()
		for _, elem := range s.Maintenances {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("incidents")
		e.ArrStart()
		for _, elem := range s.Incidents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfLorStatusV1PlatformDataDto = [5]string{
	0: "id",
	1: "name",
	2: "locales",
	3: "maintenances",
	4: "incidents",
}

// Decode decodes LorStatusV1PlatformDataDto from json.
func (s *LorStatusV1PlatformDataDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorStatusV1PlatformDataDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "locales":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Locales = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Locales = append(s.Locales, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locales\"")
			}
		case "maintenances":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Maintenances = make([]LorStatusV1StatusDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LorStatusV1StatusDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Maintenances = append(s.Maintenances, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenances\"")
			}
		case "incidents":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Incidents = make([]LorStatusV1StatusDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LorStatusV1StatusDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Incidents = append(s.Incidents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incidents\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LorStatusV1PlatformDataDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLorStatusV1PlatformDataDto) {
					name = jsonFieldsNameOfLorStatusV1PlatformDataDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LorStatusV1PlatformDataDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorStatusV1PlatformDataDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LorStatusV1StatusDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LorStatusV1StatusDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int32(s.ID)
	}
	{
		e.FieldStart("maintenance_status")
		s.MaintenanceStatus.Encode(e)
	}
	{
		e.FieldStart("incident_severity")
		s.IncidentSeverity.Encode(e)
	}
	{
		e.FieldStart("titles")
		e.ArrStart()
		for _, elem := range s.Titles {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("updates")
		e.ArrStart()
		for _, elem := range s.Updates {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("created_at")
		e.Str(s.CreatedAt)
	}
	{
		e.FieldStart("archive_at")
		e.Str(s.ArchiveAt)
	}
	{
		e.FieldStart("updated_at")
		e.Str(s.UpdatedAt)
	}
	{
		e.FieldStart("platforms")
		e.ArrStart()
		for _, elem := range s.Platforms {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfLorStatusV1StatusDto = [9]string{
	0: "id",
	1: "maintenance_status",
	2: "incident_severity",
	3: "titles",
	4: "updates",
	5: "created_at",
	6: "archive_at",
	7: "updated_at",
	8: "platforms",
}

// Decode decodes LorStatusV1StatusDto from json.
func (s *LorStatusV1StatusDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorStatusV1StatusDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ID = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "maintenance_status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.MaintenanceStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenance_status\"")
			}
		case "incident_severity":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.IncidentSeverity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incident_severity\"")
			}
		case "titles":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Titles = make([]LorStatusV1ContentDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LorStatusV1ContentDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Titles = append(s.Titles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"titles\"")
			}
		case "updates":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Updates = make([]LorStatusV1UpdateDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LorStatusV1UpdateDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Updates = append(s.Updates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updates\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "archive_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ArchiveAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "platforms":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.Platforms = make([]LorStatusV1StatusDtoPlatformsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LorStatusV1StatusDtoPlatformsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Platforms = append(s.Platforms, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platforms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LorStatusV1StatusDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLorStatusV1StatusDto) {
					name = jsonFieldsNameOfLorStatusV1StatusDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LorStatusV1StatusDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorStatusV1StatusDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LorStatusV1StatusDtoIncidentSeverity as json.
func (s LorStatusV1StatusDtoIncidentSeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LorStatusV1StatusDtoIncidentSeverity from json.
func (s *LorStatusV1StatusDtoIncidentSeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorStatusV1StatusDtoIncidentSeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LorStatusV1StatusDtoIncidentSeverity(v) {
	case LorStatusV1StatusDtoIncidentSeverityInfo:
		*s = LorStatusV1StatusDtoIncidentSeverityInfo
	case LorStatusV1StatusDtoIncidentSeverityWarning:
		*s = LorStatusV1StatusDtoIncidentSeverityWarning
	case LorStatusV1StatusDtoIncidentSeverityCritical:
		*s = LorStatusV1StatusDtoIncidentSeverityCritical
	default:
		*s = LorStatusV1StatusDtoIncidentSeverity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LorStatusV1StatusDtoIncidentSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorStatusV1StatusDtoIncidentSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LorStatusV1StatusDtoMaintenanceStatus as json.
func (s LorStatusV1StatusDtoMaintenanceStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LorStatusV1StatusDtoMaintenanceStatus from json.
func (s *LorStatusV1StatusDtoMaintenanceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorStatusV1StatusDtoMaintenanceStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LorStatusV1StatusDtoMaintenanceStatus(v) {
	case LorStatusV1StatusDtoMaintenanceStatusScheduled:
		*s = LorStatusV1StatusDtoMaintenanceStatusScheduled
	case LorStatusV1StatusDtoMaintenanceStatusInProgress:
		*s = LorStatusV1StatusDtoMaintenanceStatusInProgress
	case LorStatusV1StatusDtoMaintenanceStatusComplete:
		*s = LorStatusV1StatusDtoMaintenanceStatusComplete
	default:
		*s = LorStatusV1StatusDtoMaintenanceStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LorStatusV1StatusDtoMaintenanceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorStatusV1StatusDtoMaintenanceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LorStatusV1StatusDtoPlatformsItem as json.
func (s LorStatusV1StatusDtoPlatformsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LorStatusV1StatusDtoPlatformsItem from json.
func (s *LorStatusV1StatusDtoPlatformsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorStatusV1StatusDtoPlatformsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LorStatusV1StatusDtoPlatformsItem(v) {
	case LorStatusV1StatusDtoPlatformsItemWindows:
		*s = LorStatusV1StatusDtoPlatformsItemWindows
	case LorStatusV1StatusDtoPlatformsItemMacos:
		*s = LorStatusV1StatusDtoPlatformsItemMacos
	case LorStatusV1StatusDtoPlatformsItemAndroid:
		*s = LorStatusV1StatusDtoPlatformsItemAndroid
	case LorStatusV1StatusDtoPlatformsItemIos:
		*s = LorStatusV1StatusDtoPlatformsItemIos
	case LorStatusV1StatusDtoPlatformsItemPs4:
		*s = LorStatusV1StatusDtoPlatformsItemPs4
	case LorStatusV1StatusDtoPlatformsItemXbone:
		*s = LorStatusV1StatusDtoPlatformsItemXbone
	case LorStatusV1StatusDtoPlatformsItemSwitch:
		*s = LorStatusV1StatusDtoPlatformsItemSwitch
	default:
		*s = LorStatusV1StatusDtoPlatformsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LorStatusV1StatusDtoPlatformsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorStatusV1StatusDtoPlatformsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LorStatusV1UpdateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LorStatusV1UpdateDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int32(s.ID)
	}
	{
		e.FieldStart("author")
		e.Str(s.Author)
	}
	{
		e.FieldStart("publish")
		e.Bool(s.Publish)
	}
	{
		e.FieldStart("publish_locations")
		e.ArrStart()
		for _, elem := range s.PublishLocations {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("translations")
		e.ArrStart()
		for _, elem := range s.Translations {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("created_at")
		e.Str(s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		e.Str(s.UpdatedAt)
	}
}

var jsonFieldsNameOfLorStatusV1UpdateDto = [7]string{
	0: "id",
	1: "author",
	2: "publish",
	3: "publish_locations",
	4: "translations",
	5: "created_at",
	6: "updated_at",
}

// Decode decodes LorStatusV1UpdateDto from json.
func (s *LorStatusV1UpdateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorStatusV1UpdateDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ID = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "author":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Author = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "publish":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Publish = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publish\"")
			}
		case "publish_locations":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.PublishLocations = make([]LorStatusV1UpdateDtoPublishLocationsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LorStatusV1UpdateDtoPublishLocationsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PublishLocations = append(s.PublishLocations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publish_locations\"")
			}
		case "translations":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Translations = make([]LorStatusV1ContentDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LorStatusV1ContentDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Translations = append(s.Translations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"translations\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LorStatusV1UpdateDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLorStatusV1UpdateDto) {
					name = jsonFieldsNameOfLorStatusV1UpdateDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LorStatusV1UpdateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorStatusV1UpdateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LorStatusV1UpdateDtoPublishLocationsItem as json.
func (s LorStatusV1UpdateDtoPublishLocationsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LorStatusV1UpdateDtoPublishLocationsItem from json.
func (s *LorStatusV1UpdateDtoPublishLocationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LorStatusV1UpdateDtoPublishLocationsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LorStatusV1UpdateDtoPublishLocationsItem(v) {
	case LorStatusV1UpdateDtoPublishLocationsItemRiotclient:
		*s = LorStatusV1UpdateDtoPublishLocationsItemRiotclient
	case LorStatusV1UpdateDtoPublishLocationsItemRiotstatus:
		*s = LorStatusV1UpdateDtoPublishLocationsItemRiotstatus
	case LorStatusV1UpdateDtoPublishLocationsItemGame:
		*s = LorStatusV1UpdateDtoPublishLocationsItemGame
	default:
		*s = LorStatusV1UpdateDtoPublishLocationsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LorStatusV1UpdateDtoPublishLocationsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LorStatusV1UpdateDtoPublishLocationsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5BanDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5BanDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("championId")
		e.Int32(s.ChampionId)
	}
	{
		e.FieldStart("pickTurn")
		e.Int32(s.PickTurn)
	}
}

var jsonFieldsNameOfMatchV5BanDto = [2]string{
	0: "championId",
	1: "pickTurn",
}

// Decode decodes MatchV5BanDto from json.
func (s *MatchV5BanDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5BanDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "championId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ChampionId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"championId\"")
			}
		case "pickTurn":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.PickTurn = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pickTurn\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5BanDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchV5BanDto) {
					name = jsonFieldsNameOfMatchV5BanDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5BanDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5BanDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5ChallengesDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5ChallengesDto) encodeFields(e *jx.Encoder) {
	{
		if s.R12AssistStreakCount.Set {
			e.FieldStart("12AssistStreakCount")
			s.R12AssistStreakCount.Encode(e)
		}
	}
	{
		if s.BaronBuffGoldAdvantageOverThreshold.Set {
			e.FieldStart("baronBuffGoldAdvantageOverThreshold")
			s.BaronBuffGoldAdvantageOverThreshold.Encode(e)
		}
	}
	{
		if s.ControlWardTimeCoverageInRiverOrEnemyHalf.Set {
			e.FieldStart("controlWardTimeCoverageInRiverOrEnemyHalf")
			s.ControlWardTimeCoverageInRiverOrEnemyHalf.Encode(e)
		}
	}
	{
		if s.EarliestBaron.Set {
			e.FieldStart("earliestBaron")
			s.EarliestBaron.Encode(e)
		}
	}
	{
		if s.EarliestDragonTakedown.Set {
			e.FieldStart("earliestDragonTakedown")
			s.EarliestDragonTakedown.Encode(e)
		}
	}
	{
		if s.EarliestElderDragon.Set {
			e.FieldStart("earliestElderDragon")
			s.EarliestElderDragon.Encode(e)
		}
	}
	{
		if s.EarlyLaningPhaseGoldExpAdvantage.Set {
			e.FieldStart("earlyLaningPhaseGoldExpAdvantage")
			s.EarlyLaningPhaseGoldExpAdvantage.Encode(e)
		}
	}
	{
		if s.FasterSupportQuestCompletion.Set {
			e.FieldStart("fasterSupportQuestCompletion")
			s.FasterSupportQuestCompletion.Encode(e)
		}
	}
	{
		if s.FastestLegendary.Set {
			e.FieldStart("fastestLegendary")
			s.FastestLegendary.Encode(e)
		}
	}
	{
		if s.HadAfkTeammate.Set {
			e.FieldStart("hadAfkTeammate")
			s.HadAfkTeammate.Encode(e)
		}
	}
	{
		if s.HighestChampionDamage.Set {
			e.FieldStart("highestChampionDamage")
			s.HighestChampionDamage.Encode(e)
		}
	}
	{
		if s.HighestCrowdControlScore.Set {
			e.FieldStart("highestCrowdControlScore")
			s.HighestCrowdControlScore.Encode(e)
		}
	}
	{
		if s.HighestWardKills.Set {
			e.FieldStart("highestWardKills")
			s.HighestWardKills.Encode(e)
		}
	}
	{
		if s.JunglerKillsEarlyJungle.Set {
			e.FieldStart("junglerKillsEarlyJungle")
			s.JunglerKillsEarlyJungle.Encode(e)
		}
	}
	{
		if s.KillsOnLanersEarlyJungleAsJungler.Set {
			e.FieldStart("killsOnLanersEarlyJungleAsJungler")
			s.KillsOnLanersEarlyJungleAsJungler.Encode(e)
		}
	}
	{
		if s.LaningPhaseGoldExpAdvantage.Set {
			e.FieldStart("laningPhaseGoldExpAdvantage")
			s.LaningPhaseGoldExpAdvantage.Encode(e)
		}
	}
	{
		if s.LegendaryCount.Set {
			e.FieldStart("legendaryCount")
			s.LegendaryCount.Encode(e)
		}
	}
	{
		if s.MaxCsAdvantageOnLaneOpponent.Set {
			e.FieldStart("maxCsAdvantageOnLaneOpponent")
			s.MaxCsAdvantageOnLaneOpponent.Encode(e)
		}
	}
	{
		if s.MaxLevelLeadLaneOpponent.Set {
			e.FieldStart("maxLevelLeadLaneOpponent")
			s.MaxLevelLeadLaneOpponent.Encode(e)
		}
	}
	{
		if s.MostWardsDestroyedOneSweeper.Set {
			e.FieldStart("mostWardsDestroyedOneSweeper")
			s.MostWardsDestroyedOneSweeper.Encode(e)
		}
	}
	{
		if s.MythicItemUsed.Set {
			e.FieldStart("mythicItemUsed")
			s.MythicItemUsed.Encode(e)
		}
	}
	{
		if s.PlayedChampSelectPosition.Set {
			e.FieldStart("playedChampSelectPosition")
			s.PlayedChampSelectPosition.Encode(e)
		}
	}
	{
		if s.SoloTurretsLategame.Set {
			e.FieldStart("soloTurretsLategame")
			s.SoloTurretsLategame.Encode(e)
		}
	}
	{
		if s.TakedownsFirst25Minutes.Set {
			e.FieldStart("takedownsFirst25Minutes")
			s.TakedownsFirst25Minutes.Encode(e)
		}
	}
	{
		if s.TeleportTakedowns.Set {
			e.FieldStart("teleportTakedowns")
			s.TeleportTakedowns.Encode(e)
		}
	}
	{
		if s.ThirdInhibitorDestroyedTime.Set {
			e.FieldStart("thirdInhibitorDestroyedTime")
			s.ThirdInhibitorDestroyedTime.Encode(e)
		}
	}
	{
		if s.ThreeWardsOneSweeperCount.Set {
			e.FieldStart("threeWardsOneSweeperCount")
			s.ThreeWardsOneSweeperCount.Encode(e)
		}
	}
	{
		if s.VisionScoreAdvantageLaneOpponent.Set {
			e.FieldStart("visionScoreAdvantageLaneOpponent")
			s.VisionScoreAdvantageLaneOpponent.Encode(e)
		}
	}
	{
		if s.InfernalScalePickup.Set {
			e.FieldStart("InfernalScalePickup")
			s.InfernalScalePickup.Encode(e)
		}
	}
	{
		if s.FistBumpParticipation.Set {
			e.FieldStart("fistBumpParticipation")
			s.FistBumpParticipation.Encode(e)
		}
	}
	{
		if s.VoidMonsterKill.Set {
			e.FieldStart("voidMonsterKill")
			s.VoidMonsterKill.Encode(e)
		}
	}
	{
		if s.AbilityUses.Set {
			e.FieldStart("abilityUses")
			s.AbilityUses.Encode(e)
		}
	}
	{
		if s.AcesBefore15Minutes.Set {
			e.FieldStart("acesBefore15Minutes")
			s.AcesBefore15Minutes.Encode(e)
		}
	}
	{
		if s.AlliedJungleMonsterKills.Set {
			e.FieldStart("alliedJungleMonsterKills")
			s.AlliedJungleMonsterKills.Encode(e)
		}
	}
	{
		if s.BaronTakedowns.Set {
			e.FieldStart("baronTakedowns")
			s.BaronTakedowns.Encode(e)
		}
	}
	{
		if s.BlastConeOppositeOpponentCount.Set {
			e.FieldStart("blastConeOppositeOpponentCount")
			s.BlastConeOppositeOpponentCount.Encode(e)
		}
	}
	{
		if s.BountyGold.Set {
			e.FieldStart("bountyGold")
			s.BountyGold.Encode(e)
		}
	}
	{
		if s.BuffsStolen.Set {
			e.FieldStart("buffsStolen")
			s.BuffsStolen.Encode(e)
		}
	}
	{
		if s.CompleteSupportQuestInTime.Set {
			e.FieldStart("completeSupportQuestInTime")
			s.CompleteSupportQuestInTime.Encode(e)
		}
	}
	{
		if s.ControlWardsPlaced.Set {
			e.FieldStart("controlWardsPlaced")
			s.ControlWardsPlaced.Encode(e)
		}
	}
	{
		if s.DamagePerMinute.Set {
			e.FieldStart("damagePerMinute")
			s.DamagePerMinute.Encode(e)
		}
	}
	{
		if s.DamageTakenOnTeamPercentage.Set {
			e.FieldStart("damageTakenOnTeamPercentage")
			s.DamageTakenOnTeamPercentage.Encode(e)
		}
	}
	{
		if s.DancedWithRiftHerald.Set {
			e.FieldStart("dancedWithRiftHerald")
			s.DancedWithRiftHerald.Encode(e)
		}
	}
	{
		if s.DeathsByEnemyChamps.Set {
			e.FieldStart("deathsByEnemyChamps")
			s.DeathsByEnemyChamps.Encode(e)
		}
	}
	{
		if s.DodgeSkillShotsSmallWindow.Set {
			e.FieldStart("dodgeSkillShotsSmallWindow")
			s.DodgeSkillShotsSmallWindow.Encode(e)
		}
	}
	{
		if s.DoubleAces.Set {
			e.FieldStart("doubleAces")
			s.DoubleAces.Encode(e)
		}
	}
	{
		if s.DragonTakedowns.Set {
			e.FieldStart("dragonTakedowns")
			s.DragonTakedowns.Encode(e)
		}
	}
	{
		if s.LegendaryItemUsed != nil {
			e.FieldStart("legendaryItemUsed")
			e.ArrStart()
			for _, elem := range s.LegendaryItemUsed {
				e.Int32(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.EffectiveHealAndShielding.Set {
			e.FieldStart("effectiveHealAndShielding")
			s.EffectiveHealAndShielding.Encode(e)
		}
	}
	{
		if s.ElderDragonKillsWithOpposingSoul.Set {
			e.FieldStart("elderDragonKillsWithOpposingSoul")
			s.ElderDragonKillsWithOpposingSoul.Encode(e)
		}
	}
	{
		if s.ElderDragonMultikills.Set {
			e.FieldStart("elderDragonMultikills")
			s.ElderDragonMultikills.Encode(e)
		}
	}
	{
		if s.EnemyChampionImmobilizations.Set {
			e.FieldStart("enemyChampionImmobilizations")
			s.EnemyChampionImmobilizations.Encode(e)
		}
	}
	{
		if s.EnemyJungleMonsterKills.Set {
			e.FieldStart("enemyJungleMonsterKills")
			s.EnemyJungleMonsterKills.Encode(e)
		}
	}
	{
		if s.EpicMonsterKillsNearEnemyJungler.Set {
			e.FieldStart("epicMonsterKillsNearEnemyJungler")
			s.EpicMonsterKillsNearEnemyJungler.Encode(e)
		}
	}
	{
		if s.EpicMonsterKillsWithin30SecondsOfSpawn.Set {
			e.FieldStart("epicMonsterKillsWithin30SecondsOfSpawn")
			s.EpicMonsterKillsWithin30SecondsOfSpawn.Encode(e)
		}
	}
	{
		if s.EpicMonsterSteals.Set {
			e.FieldStart("epicMonsterSteals")
			s.EpicMonsterSteals.Encode(e)
		}
	}
	{
		if s.EpicMonsterStolenWithoutSmite.Set {
			e.FieldStart("epicMonsterStolenWithoutSmite")
			s.EpicMonsterStolenWithoutSmite.Encode(e)
		}
	}
	{
		if s.FirstTurretKilled.Set {
			e.FieldStart("firstTurretKilled")
			s.FirstTurretKilled.Encode(e)
		}
	}
	{
		if s.FirstTurretKilledTime.Set {
			e.FieldStart("firstTurretKilledTime")
			s.FirstTurretKilledTime.Encode(e)
		}
	}
	{
		if s.FlawlessAces.Set {
			e.FieldStart("flawlessAces")
			s.FlawlessAces.Encode(e)
		}
	}
	{
		if s.FullTeamTakedown.Set {
			e.FieldStart("fullTeamTakedown")
			s.FullTeamTakedown.Encode(e)
		}
	}
	{
		if s.GameLength.Set {
			e.FieldStart("gameLength")
			s.GameLength.Encode(e)
		}
	}
	{
		if s.GetTakedownsInAllLanesEarlyJungleAsLaner.Set {
			e.FieldStart("getTakedownsInAllLanesEarlyJungleAsLaner")
			s.GetTakedownsInAllLanesEarlyJungleAsLaner.Encode(e)
		}
	}
	{
		if s.GoldPerMinute.Set {
			e.FieldStart("goldPerMinute")
			s.GoldPerMinute.Encode(e)
		}
	}
	{
		if s.HadOpenNexus.Set {
			e.FieldStart("hadOpenNexus")
			s.HadOpenNexus.Encode(e)
		}
	}
	{
		if s.ImmobilizeAndKillWithAlly.Set {
			e.FieldStart("immobilizeAndKillWithAlly")
			s.ImmobilizeAndKillWithAlly.Encode(e)
		}
	}
	{
		if s.InitialBuffCount.Set {
			e.FieldStart("initialBuffCount")
			s.InitialBuffCount.Encode(e)
		}
	}
	{
		if s.InitialCrabCount.Set {
			e.FieldStart("initialCrabCount")
			s.InitialCrabCount.Encode(e)
		}
	}
	{
		if s.JungleCsBefore10Minutes.Set {
			e.FieldStart("jungleCsBefore10Minutes")
			s.JungleCsBefore10Minutes.Encode(e)
		}
	}
	{
		if s.JunglerTakedownsNearDamagedEpicMonster.Set {
			e.FieldStart("junglerTakedownsNearDamagedEpicMonster")
			s.JunglerTakedownsNearDamagedEpicMonster.Encode(e)
		}
	}
	{
		if s.Kda.Set {
			e.FieldStart("kda")
			s.Kda.Encode(e)
		}
	}
	{
		if s.KillAfterHiddenWithAlly.Set {
			e.FieldStart("killAfterHiddenWithAlly")
			s.KillAfterHiddenWithAlly.Encode(e)
		}
	}
	{
		if s.KilledChampTookFullTeamDamageSurvived.Set {
			e.FieldStart("killedChampTookFullTeamDamageSurvived")
			s.KilledChampTookFullTeamDamageSurvived.Encode(e)
		}
	}
	{
		if s.KillingSprees.Set {
			e.FieldStart("killingSprees")
			s.KillingSprees.Encode(e)
		}
	}
	{
		if s.KillParticipation.Set {
			e.FieldStart("killParticipation")
			s.KillParticipation.Encode(e)
		}
	}
	{
		if s.KillsNearEnemyTurret.Set {
			e.FieldStart("killsNearEnemyTurret")
			s.KillsNearEnemyTurret.Encode(e)
		}
	}
	{
		if s.KillsOnOtherLanesEarlyJungleAsLaner.Set {
			e.FieldStart("killsOnOtherLanesEarlyJungleAsLaner")
			s.KillsOnOtherLanesEarlyJungleAsLaner.Encode(e)
		}
	}
	{
		if s.KillsOnRecentlyHealedByAramPack.Set {
			e.FieldStart("killsOnRecentlyHealedByAramPack")
			s.KillsOnRecentlyHealedByAramPack.Encode(e)
		}
	}
	{
		if s.KillsUnderOwnTurret.Set {
			e.FieldStart("killsUnderOwnTurret")
			s.KillsUnderOwnTurret.Encode(e)
		}
	}
	{
		if s.KillsWithHelpFromEpicMonster.Set {
			e.FieldStart("killsWithHelpFromEpicMonster")
			s.KillsWithHelpFromEpicMonster.Encode(e)
		}
	}
	{
		if s.KnockEnemyIntoTeamAndKill.Set {
			e.FieldStart("knockEnemyIntoTeamAndKill")
			s.KnockEnemyIntoTeamAndKill.Encode(e)
		}
	}
	{
		if s.KTurretsDestroyedBeforePlatesFall.Set {
			e.FieldStart("kTurretsDestroyedBeforePlatesFall")
			s.KTurretsDestroyedBeforePlatesFall.Encode(e)
		}
	}
	{
		if s.LandSkillShotsEarlyGame.Set {
			e.FieldStart("landSkillShotsEarlyGame")
			s.LandSkillShotsEarlyGame.Encode(e)
		}
	}
	{
		if s.LaneMinionsFirst10Minutes.Set {
			e.FieldStart("laneMinionsFirst10Minutes")
			s.LaneMinionsFirst10Minutes.Encode(e)
		}
	}
	{
		if s.LostAnInhibitor.Set {
			e.FieldStart("lostAnInhibitor")
			s.LostAnInhibitor.Encode(e)
		}
	}
	{
		if s.MaxKillDeficit.Set {
			e.FieldStart("maxKillDeficit")
			s.MaxKillDeficit.Encode(e)
		}
	}
	{
		if s.MejaisFullStackInTime.Set {
			e.FieldStart("mejaisFullStackInTime")
			s.MejaisFullStackInTime.Encode(e)
		}
	}
	{
		if s.MoreEnemyJungleThanOpponent.Set {
			e.FieldStart("moreEnemyJungleThanOpponent")
			s.MoreEnemyJungleThanOpponent.Encode(e)
		}
	}
	{
		if s.MultiKillOneSpell.Set {
			e.FieldStart("multiKillOneSpell")
			s.MultiKillOneSpell.Encode(e)
		}
	}
	{
		if s.Multikills.Set {
			e.FieldStart("multikills")
			s.Multikills.Encode(e)
		}
	}
	{
		if s.MultikillsAfterAggressiveFlash.Set {
			e.FieldStart("multikillsAfterAggressiveFlash")
			s.MultikillsAfterAggressiveFlash.Encode(e)
		}
	}
	{
		if s.MultiTurretRiftHeraldCount.Set {
			e.FieldStart("multiTurretRiftHeraldCount")
			s.MultiTurretRiftHeraldCount.Encode(e)
		}
	}
	{
		if s.OuterTurretExecutesBefore10Minutes.Set {
			e.FieldStart("outerTurretExecutesBefore10Minutes")
			s.OuterTurretExecutesBefore10Minutes.Encode(e)
		}
	}
	{
		if s.OutnumberedKills.Set {
			e.FieldStart("outnumberedKills")
			s.OutnumberedKills.Encode(e)
		}
	}
	{
		if s.OutnumberedNexusKill.Set {
			e.FieldStart("outnumberedNexusKill")
			s.OutnumberedNexusKill.Encode(e)
		}
	}
	{
		if s.PerfectDragonSoulsTaken.Set {
			e.FieldStart("perfectDragonSoulsTaken")
			s.PerfectDragonSoulsTaken.Encode(e)
		}
	}
	{
		if s.PerfectGame.Set {
			e.FieldStart("perfectGame")
			s.PerfectGame.Encode(e)
		}
	}
	{
		if s.PickKillWithAlly.Set {
			e.FieldStart("pickKillWithAlly")
			s.PickKillWithAlly.Encode(e)
		}
	}
	{
		if s.PoroExplosions.Set {
			e.FieldStart("poroExplosions")
			s.PoroExplosions.Encode(e)
		}
	}
	{
		if s.QuickCleanse.Set {
			e.FieldStart("quickCleanse")
			s.QuickCleanse.Encode(e)
		}
	}
	{
		if s.QuickFirstTurret.Set {
			e.FieldStart("quickFirstTurret")
			s.QuickFirstTurret.Encode(e)
		}
	}
	{
		if s.QuickSoloKills.Set {
			e.FieldStart("quickSoloKills")
			s.QuickSoloKills.Encode(e)
		}
	}
	{
		if s.RiftHeraldTakedowns.Set {
			e.FieldStart("riftHeraldTakedowns")
			s.RiftHeraldTakedowns.Encode(e)
		}
	}
	{
		if s.SaveAllyFromDeath.Set {
			e.FieldStart("saveAllyFromDeath")
			s.SaveAllyFromDeath.Encode(e)
		}
	}
	{
		if s.ScuttleCrabKills.Set {
			e.FieldStart("scuttleCrabKills")
			s.ScuttleCrabKills.Encode(e)
		}
	}
	{
		if s.ShortestTimeToAceFromFirstTakedown.Set {
			e.FieldStart("shortestTimeToAceFromFirstTakedown")
			s.ShortestTimeToAceFromFirstTakedown.Encode(e)
		}
	}
	{
		if s.SkillshotsDodged.Set {
			e.FieldStart("skillshotsDodged")
			s.SkillshotsDodged.Encode(e)
		}
	}
	{
		if s.SkillshotsHit.Set {
			e.FieldStart("skillshotsHit")
			s.SkillshotsHit.Encode(e)
		}
	}
	{
		if s.SnowballsHit.Set {
			e.FieldStart("snowballsHit")
			s.SnowballsHit.Encode(e)
		}
	}
	{
		if s.SoloBaronKills.Set {
			e.FieldStart("soloBaronKills")
			s.SoloBaronKills.Encode(e)
		}
	}
	{
		if s.SWARMDefeatAatrox.Set {
			e.FieldStart("SWARM_DefeatAatrox")
			s.SWARMDefeatAatrox.Encode(e)
		}
	}
	{
		if s.SWARMDefeatBriar.Set {
			e.FieldStart("SWARM_DefeatBriar")
			s.SWARMDefeatBriar.Encode(e)
		}
	}
	{
		if s.SWARMDefeatMiniBosses.Set {
			e.FieldStart("SWARM_DefeatMiniBosses")
			s.SWARMDefeatMiniBosses.Encode(e)
		}
	}
	{
		if s.SWARMEvolveWeapon.Set {
			e.FieldStart("SWARM_EvolveWeapon")
			s.SWARMEvolveWeapon.Encode(e)
		}
	}
	{
		if s.SWARMHave3Passives.Set {
			e.FieldStart("SWARM_Have3Passives")
			s.SWARMHave3Passives.Encode(e)
		}
	}
	{
		if s.SWARMKillEnemy.Set {
			e.FieldStart("SWARM_KillEnemy")
			s.SWARMKillEnemy.Encode(e)
		}
	}
	{
		if s.SWARMPickupGold.Set {
			e.FieldStart("SWARM_PickupGold")
			s.SWARMPickupGold.Encode(e)
		}
	}
	{
		if s.SWARMReachLevel50.Set {
			e.FieldStart("SWARM_ReachLevel50")
			s.SWARMReachLevel50.Encode(e)
		}
	}
	{
		if s.SWARMSurvive15Min.Set {
			e.FieldStart("SWARM_Survive15Min")
			s.SWARMSurvive15Min.Encode(e)
		}
	}
	{
		if s.SWARMWinWith5EvolvedWeapons.Set {
			e.FieldStart("SWARM_WinWith5EvolvedWeapons")
			s.SWARMWinWith5EvolvedWeapons.Encode(e)
		}
	}
	{
		if s.SoloKills.Set {
			e.FieldStart("soloKills")
			s.SoloKills.Encode(e)
		}
	}
	{
		if s.StealthWardsPlaced.Set {
			e.FieldStart("stealthWardsPlaced")
			s.StealthWardsPlaced.Encode(e)
		}
	}
	{
		if s.SurvivedSingleDigitHpCount.Set {
			e.FieldStart("survivedSingleDigitHpCount")
			s.SurvivedSingleDigitHpCount.Encode(e)
		}
	}
	{
		if s.SurvivedThreeImmobilizesInFight.Set {
			e.FieldStart("survivedThreeImmobilizesInFight")
			s.SurvivedThreeImmobilizesInFight.Encode(e)
		}
	}
	{
		if s.TakedownOnFirstTurret.Set {
			e.FieldStart("takedownOnFirstTurret")
			s.TakedownOnFirstTurret.Encode(e)
		}
	}
	{
		if s.Takedowns.Set {
			e.FieldStart("takedowns")
			s.Takedowns.Encode(e)
		}
	}
	{
		if s.TakedownsAfterGainingLevelAdvantage.Set {
			e.FieldStart("takedownsAfterGainingLevelAdvantage")
			s.TakedownsAfterGainingLevelAdvantage.Encode(e)
		}
	}
	{
		if s.TakedownsBeforeJungleMinionSpawn.Set {
			e.FieldStart("takedownsBeforeJungleMinionSpawn")
			s.TakedownsBeforeJungleMinionSpawn.Encode(e)
		}
	}
	{
		if s.TakedownsFirstXMinutes.Set {
			e.FieldStart("takedownsFirstXMinutes")
			s.TakedownsFirstXMinutes.Encode(e)
		}
	}
	{
		if s.TakedownsInAlcove.Set {
			e.FieldStart("takedownsInAlcove")
			s.TakedownsInAlcove.Encode(e)
		}
	}
	{
		if s.TakedownsInEnemyFountain.Set {
			e.FieldStart("takedownsInEnemyFountain")
			s.TakedownsInEnemyFountain.Encode(e)
		}
	}
	{
		if s.TeamBaronKills.Set {
			e.FieldStart("teamBaronKills")
			s.TeamBaronKills.Encode(e)
		}
	}
	{
		if s.TeamDamagePercentage.Set {
			e.FieldStart("teamDamagePercentage")
			s.TeamDamagePercentage.Encode(e)
		}
	}
	{
		if s.TeamElderDragonKills.Set {
			e.FieldStart("teamElderDragonKills")
			s.TeamElderDragonKills.Encode(e)
		}
	}
	{
		if s.TeamRiftHeraldKills.Set {
			e.FieldStart("teamRiftHeraldKills")
			s.TeamRiftHeraldKills.Encode(e)
		}
	}
	{
		if s.TookLargeDamageSurvived.Set {
			e.FieldStart("tookLargeDamageSurvived")
			s.TookLargeDamageSurvived.Encode(e)
		}
	}
	{
		if s.TurretPlatesTaken.Set {
			e.FieldStart("turretPlatesTaken")
			s.TurretPlatesTaken.Encode(e)
		}
	}
	{
		if s.TurretsTakenWithRiftHerald.Set {
			e.FieldStart("turretsTakenWithRiftHerald")
			s.TurretsTakenWithRiftHerald.Encode(e)
		}
	}
	{
		if s.TurretTakedowns.Set {
			e.FieldStart("turretTakedowns")
			s.TurretTakedowns.Encode(e)
		}
	}
	{
		if s.TwentyMinionsIn3SecondsCount.Set {
			e.FieldStart("twentyMinionsIn3SecondsCount")
			s.TwentyMinionsIn3SecondsCount.Encode(e)
		}
	}
	{
		if s.TwoWardsOneSweeperCount.Set {
			e.FieldStart("twoWardsOneSweeperCount")
			s.TwoWardsOneSweeperCount.Encode(e)
		}
	}
	{
		if s.UnseenRecalls.Set {
			e.FieldStart("unseenRecalls")
			s.UnseenRecalls.Encode(e)
		}
	}
	{
		if s.VisionScorePerMinute.Set {
			e.FieldStart("visionScorePerMinute")
			s.VisionScorePerMinute.Encode(e)
		}
	}
	{
		if s.WardsGuarded.Set {
			e.FieldStart("wardsGuarded")
			s.WardsGuarded.Encode(e)
		}
	}
	{
		if s.WardTakedowns.Set {
			e.FieldStart("wardTakedowns")
			s.WardTakedowns.Encode(e)
		}
	}
	{
		if s.WardTakedownsBefore20M.Set {
			e.FieldStart("wardTakedownsBefore20M")
			s.WardTakedownsBefore20M.Encode(e)
		}
	}
	{
		if s.HealFromMapSources.Set {
			e.FieldStart("HealFromMapSources")
			s.HealFromMapSources.Encode(e)
		}
	}
}

var jsonFieldsNameOfMatchV5ChallengesDto = [147]string{
	0:   "12AssistStreakCount",
	1:   "baronBuffGoldAdvantageOverThreshold",
	2:   "controlWardTimeCoverageInRiverOrEnemyHalf",
	3:   "earliestBaron",
	4:   "earliestDragonTakedown",
	5:   "earliestElderDragon",
	6:   "earlyLaningPhaseGoldExpAdvantage",
	7:   "fasterSupportQuestCompletion",
	8:   "fastestLegendary",
	9:   "hadAfkTeammate",
	10:  "highestChampionDamage",
	11:  "highestCrowdControlScore",
	12:  "highestWardKills",
	13:  "junglerKillsEarlyJungle",
	14:  "killsOnLanersEarlyJungleAsJungler",
	15:  "laningPhaseGoldExpAdvantage",
	16:  "legendaryCount",
	17:  "maxCsAdvantageOnLaneOpponent",
	18:  "maxLevelLeadLaneOpponent",
	19:  "mostWardsDestroyedOneSweeper",
	20:  "mythicItemUsed",
	21:  "playedChampSelectPosition",
	22:  "soloTurretsLategame",
	23:  "takedownsFirst25Minutes",
	24:  "teleportTakedowns",
	25:  "thirdInhibitorDestroyedTime",
	26:  "threeWardsOneSweeperCount",
	27:  "visionScoreAdvantageLaneOpponent",
	28:  "InfernalScalePickup",
	29:  "fistBumpParticipation",
	30:  "voidMonsterKill",
	31:  "abilityUses",
	32:  "acesBefore15Minutes",
	33:  "alliedJungleMonsterKills",
	34:  "baronTakedowns",
	35:  "blastConeOppositeOpponentCount",
	36:  "bountyGold",
	37:  "buffsStolen",
	38:  "completeSupportQuestInTime",
	39:  "controlWardsPlaced",
	40:  "damagePerMinute",
	41:  "damageTakenOnTeamPercentage",
	42:  "dancedWithRiftHerald",
	43:  "deathsByEnemyChamps",
	44:  "dodgeSkillShotsSmallWindow",
	45:  "doubleAces",
	46:  "dragonTakedowns",
	47:  "legendaryItemUsed",
	48:  "effectiveHealAndShielding",
	49:  "elderDragonKillsWithOpposingSoul",
	50:  "elderDragonMultikills",
	51:  "enemyChampionImmobilizations",
	52:  "enemyJungleMonsterKills",
	53:  "epicMonsterKillsNearEnemyJungler",
	54:  "epicMonsterKillsWithin30SecondsOfSpawn",
	55:  "epicMonsterSteals",
	56:  "epicMonsterStolenWithoutSmite",
	57:  "firstTurretKilled",
	58:  "firstTurretKilledTime",
	59:  "flawlessAces",
	60:  "fullTeamTakedown",
	61:  "gameLength",
	62:  "getTakedownsInAllLanesEarlyJungleAsLaner",
	63:  "goldPerMinute",
	64:  "hadOpenNexus",
	65:  "immobilizeAndKillWithAlly",
	66:  "initialBuffCount",
	67:  "initialCrabCount",
	68:  "jungleCsBefore10Minutes",
	69:  "junglerTakedownsNearDamagedEpicMonster",
	70:  "kda",
	71:  "killAfterHiddenWithAlly",
	72:  "killedChampTookFullTeamDamageSurvived",
	73:  "killingSprees",
	74:  "killParticipation",
	75:  "killsNearEnemyTurret",
	76:  "killsOnOtherLanesEarlyJungleAsLaner",
	77:  "killsOnRecentlyHealedByAramPack",
	78:  "killsUnderOwnTurret",
	79:  "killsWithHelpFromEpicMonster",
	80:  "knockEnemyIntoTeamAndKill",
	81:  "kTurretsDestroyedBeforePlatesFall",
	82:  "landSkillShotsEarlyGame",
	83:  "laneMinionsFirst10Minutes",
	84:  "lostAnInhibitor",
	85:  "maxKillDeficit",
	86:  "mejaisFullStackInTime",
	87:  "moreEnemyJungleThanOpponent",
	88:  "multiKillOneSpell",
	89:  "multikills",
	90:  "multikillsAfterAggressiveFlash",
	91:  "multiTurretRiftHeraldCount",
	92:  "outerTurretExecutesBefore10Minutes",
	93:  "outnumberedKills",
	94:  "outnumberedNexusKill",
	95:  "perfectDragonSoulsTaken",
	96:  "perfectGame",
	97:  "pickKillWithAlly",
	98:  "poroExplosions",
	99:  "quickCleanse",
	100: "quickFirstTurret",
	101: "quickSoloKills",
	102: "riftHeraldTakedowns",
	103: "saveAllyFromDeath",
	104: "scuttleCrabKills",
	105: "shortestTimeToAceFromFirstTakedown",
	106: "skillshotsDodged",
	107: "skillshotsHit",
	108: "snowballsHit",
	109: "soloBaronKills",
	110: "SWARM_DefeatAatrox",
	111: "SWARM_DefeatBriar",
	112: "SWARM_DefeatMiniBosses",
	113: "SWARM_EvolveWeapon",
	114: "SWARM_Have3Passives",
	115: "SWARM_KillEnemy",
	116: "SWARM_PickupGold",
	117: "SWARM_ReachLevel50",
	118: "SWARM_Survive15Min",
	119: "SWARM_WinWith5EvolvedWeapons",
	120: "soloKills",
	121: "stealthWardsPlaced",
	122: "survivedSingleDigitHpCount",
	123: "survivedThreeImmobilizesInFight",
	124: "takedownOnFirstTurret",
	125: "takedowns",
	126: "takedownsAfterGainingLevelAdvantage",
	127: "takedownsBeforeJungleMinionSpawn",
	128: "takedownsFirstXMinutes",
	129: "takedownsInAlcove",
	130: "takedownsInEnemyFountain",
	131: "teamBaronKills",
	132: "teamDamagePercentage",
	133: "teamElderDragonKills",
	134: "teamRiftHeraldKills",
	135: "tookLargeDamageSurvived",
	136: "turretPlatesTaken",
	137: "turretsTakenWithRiftHerald",
	138: "turretTakedowns",
	139: "twentyMinionsIn3SecondsCount",
	140: "twoWardsOneSweeperCount",
	141: "unseenRecalls",
	142: "visionScorePerMinute",
	143: "wardsGuarded",
	144: "wardTakedowns",
	145: "wardTakedownsBefore20M",
	146: "HealFromMapSources",
}

// Decode decodes MatchV5ChallengesDto from json.
func (s *MatchV5ChallengesDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5ChallengesDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "12AssistStreakCount":
			if err := func() error {
				s.R12AssistStreakCount.Reset()
				if err := s.R12AssistStreakCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"12AssistStreakCount\"")
			}
		case "baronBuffGoldAdvantageOverThreshold":
			if err := func() error {
				s.BaronBuffGoldAdvantageOverThreshold.Reset()
				if err := s.BaronBuffGoldAdvantageOverThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"baronBuffGoldAdvantageOverThreshold\"")
			}
		case "controlWardTimeCoverageInRiverOrEnemyHalf":
			if err := func() error {
				s.ControlWardTimeCoverageInRiverOrEnemyHalf.Reset()
				if err := s.ControlWardTimeCoverageInRiverOrEnemyHalf.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"controlWardTimeCoverageInRiverOrEnemyHalf\"")
			}
		case "earliestBaron":
			if err := func() error {
				s.EarliestBaron.Reset()
				if err := s.EarliestBaron.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"earliestBaron\"")
			}
		case "earliestDragonTakedown":
			if err := func() error {
				s.EarliestDragonTakedown.Reset()
				if err := s.EarliestDragonTakedown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"earliestDragonTakedown\"")
			}
		case "earliestElderDragon":
			if err := func() error {
				s.EarliestElderDragon.Reset()
				if err := s.EarliestElderDragon.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"earliestElderDragon\"")
			}
		case "earlyLaningPhaseGoldExpAdvantage":
			if err := func() error {
				s.EarlyLaningPhaseGoldExpAdvantage.Reset()
				if err := s.EarlyLaningPhaseGoldExpAdvantage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"earlyLaningPhaseGoldExpAdvantage\"")
			}
		case "fasterSupportQuestCompletion":
			if err := func() error {
				s.FasterSupportQuestCompletion.Reset()
				if err := s.FasterSupportQuestCompletion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fasterSupportQuestCompletion\"")
			}
		case "fastestLegendary":
			if err := func() error {
				s.FastestLegendary.Reset()
				if err := s.FastestLegendary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fastestLegendary\"")
			}
		case "hadAfkTeammate":
			if err := func() error {
				s.HadAfkTeammate.Reset()
				if err := s.HadAfkTeammate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hadAfkTeammate\"")
			}
		case "highestChampionDamage":
			if err := func() error {
				s.HighestChampionDamage.Reset()
				if err := s.HighestChampionDamage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highestChampionDamage\"")
			}
		case "highestCrowdControlScore":
			if err := func() error {
				s.HighestCrowdControlScore.Reset()
				if err := s.HighestCrowdControlScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highestCrowdControlScore\"")
			}
		case "highestWardKills":
			if err := func() error {
				s.HighestWardKills.Reset()
				if err := s.HighestWardKills.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highestWardKills\"")
			}
		case "junglerKillsEarlyJungle":
			if err := func() error {
				s.JunglerKillsEarlyJungle.Reset()
				if err := s.JunglerKillsEarlyJungle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"junglerKillsEarlyJungle\"")
			}
		case "killsOnLanersEarlyJungleAsJungler":
			if err := func() error {
				s.KillsOnLanersEarlyJungleAsJungler.Reset()
				if err := s.KillsOnLanersEarlyJungleAsJungler.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"killsOnLanersEarlyJungleAsJungler\"")
			}
		case "laningPhaseGoldExpAdvantage":
			if err := func() error {
				s.LaningPhaseGoldExpAdvantage.Reset()
				if err := s.LaningPhaseGoldExpAdvantage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"laningPhaseGoldExpAdvantage\"")
			}
		case "legendaryCount":
			if err := func() error {
				s.LegendaryCount.Reset()
				if err := s.LegendaryCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"legendaryCount\"")
			}
		case "maxCsAdvantageOnLaneOpponent":
			if err := func() error {
				s.MaxCsAdvantageOnLaneOpponent.Reset()
				if err := s.MaxCsAdvantageOnLaneOpponent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxCsAdvantageOnLaneOpponent\"")
			}
		case "maxLevelLeadLaneOpponent":
			if err := func() error {
				s.MaxLevelLeadLaneOpponent.Reset()
				if err := s.MaxLevelLeadLaneOpponent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxLevelLeadLaneOpponent\"")
			}
		case "mostWardsDestroyedOneSweeper":
			if err := func() error {
				s.MostWardsDestroyedOneSweeper.Reset()
				if err := s.MostWardsDestroyedOneSweeper.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mostWardsDestroyedOneSweeper\"")
			}
		case "mythicItemUsed":
			if err := func() error {
				s.MythicItemUsed.Reset()
				if err := s.MythicItemUsed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mythicItemUsed\"")
			}
		case "playedChampSelectPosition":
			if err := func() error {
				s.PlayedChampSelectPosition.Reset()
				if err := s.PlayedChampSelectPosition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playedChampSelectPosition\"")
			}
		case "soloTurretsLategame":
			if err := func() error {
				s.SoloTurretsLategame.Reset()
				if err := s.SoloTurretsLategame.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"soloTurretsLategame\"")
			}
		case "takedownsFirst25Minutes":
			if err := func() error {
				s.TakedownsFirst25Minutes.Reset()
				if err := s.TakedownsFirst25Minutes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"takedownsFirst25Minutes\"")
			}
		case "teleportTakedowns":
			if err := func() error {
				s.TeleportTakedowns.Reset()
				if err := s.TeleportTakedowns.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teleportTakedowns\"")
			}
		case "thirdInhibitorDestroyedTime":
			if err := func() error {
				s.ThirdInhibitorDestroyedTime.Reset()
				if err := s.ThirdInhibitorDestroyedTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thirdInhibitorDestroyedTime\"")
			}
		case "threeWardsOneSweeperCount":
			if err := func() error {
				s.ThreeWardsOneSweeperCount.Reset()
				if err := s.ThreeWardsOneSweeperCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"threeWardsOneSweeperCount\"")
			}
		case "visionScoreAdvantageLaneOpponent":
			if err := func() error {
				s.VisionScoreAdvantageLaneOpponent.Reset()
				if err := s.VisionScoreAdvantageLaneOpponent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visionScoreAdvantageLaneOpponent\"")
			}
		case "InfernalScalePickup":
			if err := func() error {
				s.InfernalScalePickup.Reset()
				if err := s.InfernalScalePickup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"InfernalScalePickup\"")
			}
		case "fistBumpParticipation":
			if err := func() error {
				s.FistBumpParticipation.Reset()
				if err := s.FistBumpParticipation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fistBumpParticipation\"")
			}
		case "voidMonsterKill":
			if err := func() error {
				s.VoidMonsterKill.Reset()
				if err := s.VoidMonsterKill.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voidMonsterKill\"")
			}
		case "abilityUses":
			if err := func() error {
				s.AbilityUses.Reset()
				if err := s.AbilityUses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"abilityUses\"")
			}
		case "acesBefore15Minutes":
			if err := func() error {
				s.AcesBefore15Minutes.Reset()
				if err := s.AcesBefore15Minutes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"acesBefore15Minutes\"")
			}
		case "alliedJungleMonsterKills":
			if err := func() error {
				s.AlliedJungleMonsterKills.Reset()
				if err := s.AlliedJungleMonsterKills.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alliedJungleMonsterKills\"")
			}
		case "baronTakedowns":
			if err := func() error {
				s.BaronTakedowns.Reset()
				if err := s.BaronTakedowns.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"baronTakedowns\"")
			}
		case "blastConeOppositeOpponentCount":
			if err := func() error {
				s.BlastConeOppositeOpponentCount.Reset()
				if err := s.BlastConeOppositeOpponentCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blastConeOppositeOpponentCount\"")
			}
		case "bountyGold":
			if err := func() error {
				s.BountyGold.Reset()
				if err := s.BountyGold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bountyGold\"")
			}
		case "buffsStolen":
			if err := func() error {
				s.BuffsStolen.Reset()
				if err := s.BuffsStolen.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buffsStolen\"")
			}
		case "completeSupportQuestInTime":
			if err := func() error {
				s.CompleteSupportQuestInTime.Reset()
				if err := s.CompleteSupportQuestInTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completeSupportQuestInTime\"")
			}
		case "controlWardsPlaced":
			if err := func() error {
				s.ControlWardsPlaced.Reset()
				if err := s.ControlWardsPlaced.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"controlWardsPlaced\"")
			}
		case "damagePerMinute":
			if err := func() error {
				s.DamagePerMinute.Reset()
				if err := s.DamagePerMinute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damagePerMinute\"")
			}
		case "damageTakenOnTeamPercentage":
			if err := func() error {
				s.DamageTakenOnTeamPercentage.Reset()
				if err := s.DamageTakenOnTeamPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damageTakenOnTeamPercentage\"")
			}
		case "dancedWithRiftHerald":
			if err := func() error {
				s.DancedWithRiftHerald.Reset()
				if err := s.DancedWithRiftHerald.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dancedWithRiftHerald\"")
			}
		case "deathsByEnemyChamps":
			if err := func() error {
				s.DeathsByEnemyChamps.Reset()
				if err := s.DeathsByEnemyChamps.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deathsByEnemyChamps\"")
			}
		case "dodgeSkillShotsSmallWindow":
			if err := func() error {
				s.DodgeSkillShotsSmallWindow.Reset()
				if err := s.DodgeSkillShotsSmallWindow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dodgeSkillShotsSmallWindow\"")
			}
		case "doubleAces":
			if err := func() error {
				s.DoubleAces.Reset()
				if err := s.DoubleAces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"doubleAces\"")
			}
		case "dragonTakedowns":
			if err := func() error {
				s.DragonTakedowns.Reset()
				if err := s.DragonTakedowns.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dragonTakedowns\"")
			}
		case "legendaryItemUsed":
			if err := func() error {
				s.LegendaryItemUsed = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int32
					v, err := d.Int32()
					elem = int32(v)
					if err != nil {
						return err
					}
					s.LegendaryItemUsed = append(s.LegendaryItemUsed, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"legendaryItemUsed\"")
			}
		case "effectiveHealAndShielding":
			if err := func() error {
				s.EffectiveHealAndShielding.Reset()
				if err := s.EffectiveHealAndShielding.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effectiveHealAndShielding\"")
			}
		case "elderDragonKillsWithOpposingSoul":
			if err := func() error {
				s.ElderDragonKillsWithOpposingSoul.Reset()
				if err := s.ElderDragonKillsWithOpposingSoul.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elderDragonKillsWithOpposingSoul\"")
			}
		case "elderDragonMultikills":
			if err := func() error {
				s.ElderDragonMultikills.Reset()
				if err := s.ElderDragonMultikills.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elderDragonMultikills\"")
			}
		case "enemyChampionImmobilizations":
			if err := func() error {
				s.EnemyChampionImmobilizations.Reset()
				if err := s.EnemyChampionImmobilizations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enemyChampionImmobilizations\"")
			}
		case "enemyJungleMonsterKills":
			if err := func() error {
				s.EnemyJungleMonsterKills.Reset()
				if err := s.EnemyJungleMonsterKills.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enemyJungleMonsterKills\"")
			}
		case "epicMonsterKillsNearEnemyJungler":
			if err := func() error {
				s.EpicMonsterKillsNearEnemyJungler.Reset()
				if err := s.EpicMonsterKillsNearEnemyJungler.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"epicMonsterKillsNearEnemyJungler\"")
			}
		case "epicMonsterKillsWithin30SecondsOfSpawn":
			if err := func() error {
				s.EpicMonsterKillsWithin30SecondsOfSpawn.Reset()
				if err := s.EpicMonsterKillsWithin30SecondsOfSpawn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"epicMonsterKillsWithin30SecondsOfSpawn\"")
			}
		case "epicMonsterSteals":
			if err := func() error {
				s.EpicMonsterSteals.Reset()
				if err := s.EpicMonsterSteals.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"epicMonsterSteals\"")
			}
		case "epicMonsterStolenWithoutSmite":
			if err := func() error {
				s.EpicMonsterStolenWithoutSmite.Reset()
				if err := s.EpicMonsterStolenWithoutSmite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"epicMonsterStolenWithoutSmite\"")
			}
		case "firstTurretKilled":
			if err := func() error {
				s.FirstTurretKilled.Reset()
				if err := s.FirstTurretKilled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstTurretKilled\"")
			}
		case "firstTurretKilledTime":
			if err := func() error {
				s.FirstTurretKilledTime.Reset()
				if err := s.FirstTurretKilledTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstTurretKilledTime\"")
			}
		case "flawlessAces":
			if err := func() error {
				s.FlawlessAces.Reset()
				if err := s.FlawlessAces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flawlessAces\"")
			}
		case "fullTeamTakedown":
			if err := func() error {
				s.FullTeamTakedown.Reset()
				if err := s.FullTeamTakedown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fullTeamTakedown\"")
			}
		case "gameLength":
			if err := func() error {
				s.GameLength.Reset()
				if err := s.GameLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameLength\"")
			}
		case "getTakedownsInAllLanesEarlyJungleAsLaner":
			if err := func() error {
				s.GetTakedownsInAllLanesEarlyJungleAsLaner.Reset()
				if err := s.GetTakedownsInAllLanesEarlyJungleAsLaner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"getTakedownsInAllLanesEarlyJungleAsLaner\"")
			}
		case "goldPerMinute":
			if err := func() error {
				s.GoldPerMinute.Reset()
				if err := s.GoldPerMinute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"goldPerMinute\"")
			}
		case "hadOpenNexus":
			if err := func() error {
				s.HadOpenNexus.Reset()
				if err := s.HadOpenNexus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hadOpenNexus\"")
			}
		case "immobilizeAndKillWithAlly":
			if err := func() error {
				s.ImmobilizeAndKillWithAlly.Reset()
				if err := s.ImmobilizeAndKillWithAlly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"immobilizeAndKillWithAlly\"")
			}
		case "initialBuffCount":
			if err := func() error {
				s.InitialBuffCount.Reset()
				if err := s.InitialBuffCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initialBuffCount\"")
			}
		case "initialCrabCount":
			if err := func() error {
				s.InitialCrabCount.Reset()
				if err := s.InitialCrabCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initialCrabCount\"")
			}
		case "jungleCsBefore10Minutes":
			if err := func() error {
				s.JungleCsBefore10Minutes.Reset()
				if err := s.JungleCsBefore10Minutes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jungleCsBefore10Minutes\"")
			}
		case "junglerTakedownsNearDamagedEpicMonster":
			if err := func() error {
				s.JunglerTakedownsNearDamagedEpicMonster.Reset()
				if err := s.JunglerTakedownsNearDamagedEpicMonster.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"junglerTakedownsNearDamagedEpicMonster\"")
			}
		case "kda":
			if err := func() error {
				s.Kda.Reset()
				if err := s.Kda.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kda\"")
			}
		case "killAfterHiddenWithAlly":
			if err := func() error {
				s.KillAfterHiddenWithAlly.Reset()
				if err := s.KillAfterHiddenWithAlly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"killAfterHiddenWithAlly\"")
			}
		case "killedChampTookFullTeamDamageSurvived":
			if err := func() error {
				s.KilledChampTookFullTeamDamageSurvived.Reset()
				if err := s.KilledChampTookFullTeamDamageSurvived.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"killedChampTookFullTeamDamageSurvived\"")
			}
		case "killingSprees":
			if err := func() error {
				s.KillingSprees.Reset()
				if err := s.KillingSprees.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"killingSprees\"")
			}
		case "killParticipation":
			if err := func() error {
				s.KillParticipation.Reset()
				if err := s.KillParticipation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"killParticipation\"")
			}
		case "killsNearEnemyTurret":
			if err := func() error {
				s.KillsNearEnemyTurret.Reset()
				if err := s.KillsNearEnemyTurret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"killsNearEnemyTurret\"")
			}
		case "killsOnOtherLanesEarlyJungleAsLaner":
			if err := func() error {
				s.KillsOnOtherLanesEarlyJungleAsLaner.Reset()
				if err := s.KillsOnOtherLanesEarlyJungleAsLaner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"killsOnOtherLanesEarlyJungleAsLaner\"")
			}
		case "killsOnRecentlyHealedByAramPack":
			if err := func() error {
				s.KillsOnRecentlyHealedByAramPack.Reset()
				if err := s.KillsOnRecentlyHealedByAramPack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"killsOnRecentlyHealedByAramPack\"")
			}
		case "killsUnderOwnTurret":
			if err := func() error {
				s.KillsUnderOwnTurret.Reset()
				if err := s.KillsUnderOwnTurret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"killsUnderOwnTurret\"")
			}
		case "killsWithHelpFromEpicMonster":
			if err := func() error {
				s.KillsWithHelpFromEpicMonster.Reset()
				if err := s.KillsWithHelpFromEpicMonster.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"killsWithHelpFromEpicMonster\"")
			}
		case "knockEnemyIntoTeamAndKill":
			if err := func() error {
				s.KnockEnemyIntoTeamAndKill.Reset()
				if err := s.KnockEnemyIntoTeamAndKill.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"knockEnemyIntoTeamAndKill\"")
			}
		case "kTurretsDestroyedBeforePlatesFall":
			if err := func() error {
				s.KTurretsDestroyedBeforePlatesFall.Reset()
				if err := s.KTurretsDestroyedBeforePlatesFall.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kTurretsDestroyedBeforePlatesFall\"")
			}
		case "landSkillShotsEarlyGame":
			if err := func() error {
				s.LandSkillShotsEarlyGame.Reset()
				if err := s.LandSkillShotsEarlyGame.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"landSkillShotsEarlyGame\"")
			}
		case "laneMinionsFirst10Minutes":
			if err := func() error {
				s.LaneMinionsFirst10Minutes.Reset()
				if err := s.LaneMinionsFirst10Minutes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"laneMinionsFirst10Minutes\"")
			}
		case "lostAnInhibitor":
			if err := func() error {
				s.LostAnInhibitor.Reset()
				if err := s.LostAnInhibitor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lostAnInhibitor\"")
			}
		case "maxKillDeficit":
			if err := func() error {
				s.MaxKillDeficit.Reset()
				if err := s.MaxKillDeficit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxKillDeficit\"")
			}
		case "mejaisFullStackInTime":
			if err := func() error {
				s.MejaisFullStackInTime.Reset()
				if err := s.MejaisFullStackInTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mejaisFullStackInTime\"")
			}
		case "moreEnemyJungleThanOpponent":
			if err := func() error {
				s.MoreEnemyJungleThanOpponent.Reset()
				if err := s.MoreEnemyJungleThanOpponent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"moreEnemyJungleThanOpponent\"")
			}
		case "multiKillOneSpell":
			if err := func() error {
				s.MultiKillOneSpell.Reset()
				if err := s.MultiKillOneSpell.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"multiKillOneSpell\"")
			}
		case "multikills":
			if err := func() error {
				s.Multikills.Reset()
				if err := s.Multikills.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"multikills\"")
			}
		case "multikillsAfterAggressiveFlash":
			if err := func() error {
				s.MultikillsAfterAggressiveFlash.Reset()
				if err := s.MultikillsAfterAggressiveFlash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"multikillsAfterAggressiveFlash\"")
			}
		case "multiTurretRiftHeraldCount":
			if err := func() error {
				s.MultiTurretRiftHeraldCount.Reset()
				if err := s.MultiTurretRiftHeraldCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"multiTurretRiftHeraldCount\"")
			}
		case "outerTurretExecutesBefore10Minutes":
			if err := func() error {
				s.OuterTurretExecutesBefore10Minutes.Reset()
				if err := s.OuterTurretExecutesBefore10Minutes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outerTurretExecutesBefore10Minutes\"")
			}
		case "outnumberedKills":
			if err := func() error {
				s.OutnumberedKills.Reset()
				if err := s.OutnumberedKills.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outnumberedKills\"")
			}
		case "outnumberedNexusKill":
			if err := func() error {
				s.OutnumberedNexusKill.Reset()
				if err := s.OutnumberedNexusKill.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outnumberedNexusKill\"")
			}
		case "perfectDragonSoulsTaken":
			if err := func() error {
				s.PerfectDragonSoulsTaken.Reset()
				if err := s.PerfectDragonSoulsTaken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perfectDragonSoulsTaken\"")
			}
		case "perfectGame":
			if err := func() error {
				s.PerfectGame.Reset()
				if err := s.PerfectGame.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perfectGame\"")
			}
		case "pickKillWithAlly":
			if err := func() error {
				s.PickKillWithAlly.Reset()
				if err := s.PickKillWithAlly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pickKillWithAlly\"")
			}
		case "poroExplosions":
			if err := func() error {
				s.PoroExplosions.Reset()
				if err := s.PoroExplosions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"poroExplosions\"")
			}
		case "quickCleanse":
			if err := func() error {
				s.QuickCleanse.Reset()
				if err := s.QuickCleanse.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quickCleanse\"")
			}
		case "quickFirstTurret":
			if err := func() error {
				s.QuickFirstTurret.Reset()
				if err := s.QuickFirstTurret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quickFirstTurret\"")
			}
		case "quickSoloKills":
			if err := func() error {
				s.QuickSoloKills.Reset()
				if err := s.QuickSoloKills.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quickSoloKills\"")
			}
		case "riftHeraldTakedowns":
			if err := func() error {
				s.RiftHeraldTakedowns.Reset()
				if err := s.RiftHeraldTakedowns.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"riftHeraldTakedowns\"")
			}
		case "saveAllyFromDeath":
			if err := func() error {
				s.SaveAllyFromDeath.Reset()
				if err := s.SaveAllyFromDeath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"saveAllyFromDeath\"")
			}
		case "scuttleCrabKills":
			if err := func() error {
				s.ScuttleCrabKills.Reset()
				if err := s.ScuttleCrabKills.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scuttleCrabKills\"")
			}
		case "shortestTimeToAceFromFirstTakedown":
			if err := func() error {
				s.ShortestTimeToAceFromFirstTakedown.Reset()
				if err := s.ShortestTimeToAceFromFirstTakedown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortestTimeToAceFromFirstTakedown\"")
			}
		case "skillshotsDodged":
			if err := func() error {
				s.SkillshotsDodged.Reset()
				if err := s.SkillshotsDodged.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skillshotsDodged\"")
			}
		case "skillshotsHit":
			if err := func() error {
				s.SkillshotsHit.Reset()
				if err := s.SkillshotsHit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skillshotsHit\"")
			}
		case "snowballsHit":
			if err := func() error {
				s.SnowballsHit.Reset()
				if err := s.SnowballsHit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snowballsHit\"")
			}
		case "soloBaronKills":
			if err := func() error {
				s.SoloBaronKills.Reset()
				if err := s.SoloBaronKills.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"soloBaronKills\"")
			}
		case "SWARM_DefeatAatrox":
			if err := func() error {
				s.SWARMDefeatAatrox.Reset()
				if err := s.SWARMDefeatAatrox.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SWARM_DefeatAatrox\"")
			}
		case "SWARM_DefeatBriar":
			if err := func() error {
				s.SWARMDefeatBriar.Reset()
				if err := s.SWARMDefeatBriar.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SWARM_DefeatBriar\"")
			}
		case "SWARM_DefeatMiniBosses":
			if err := func() error {
				s.SWARMDefeatMiniBosses.Reset()
				if err := s.SWARMDefeatMiniBosses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SWARM_DefeatMiniBosses\"")
			}
		case "SWARM_EvolveWeapon":
			if err := func() error {
				s.SWARMEvolveWeapon.Reset()
				if err := s.SWARMEvolveWeapon.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SWARM_EvolveWeapon\"")
			}
		case "SWARM_Have3Passives":
			if err := func() error {
				s.SWARMHave3Passives.Reset()
				if err := s.SWARMHave3Passives.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SWARM_Have3Passives\"")
			}
		case "SWARM_KillEnemy":
			if err := func() error {
				s.SWARMKillEnemy.Reset()
				if err := s.SWARMKillEnemy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SWARM_KillEnemy\"")
			}
		case "SWARM_PickupGold":
			if err := func() error {
				s.SWARMPickupGold.Reset()
				if err := s.SWARMPickupGold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SWARM_PickupGold\"")
			}
		case "SWARM_ReachLevel50":
			if err := func() error {
				s.SWARMReachLevel50.Reset()
				if err := s.SWARMReachLevel50.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SWARM_ReachLevel50\"")
			}
		case "SWARM_Survive15Min":
			if err := func() error {
				s.SWARMSurvive15Min.Reset()
				if err := s.SWARMSurvive15Min.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SWARM_Survive15Min\"")
			}
		case "SWARM_WinWith5EvolvedWeapons":
			if err := func() error {
				s.SWARMWinWith5EvolvedWeapons.Reset()
				if err := s.SWARMWinWith5EvolvedWeapons.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SWARM_WinWith5EvolvedWeapons\"")
			}
		case "soloKills":
			if err := func() error {
				s.SoloKills.Reset()
				if err := s.SoloKills.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"soloKills\"")
			}
		case "stealthWardsPlaced":
			if err := func() error {
				s.StealthWardsPlaced.Reset()
				if err := s.StealthWardsPlaced.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stealthWardsPlaced\"")
			}
		case "survivedSingleDigitHpCount":
			if err := func() error {
				s.SurvivedSingleDigitHpCount.Reset()
				if err := s.SurvivedSingleDigitHpCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"survivedSingleDigitHpCount\"")
			}
		case "survivedThreeImmobilizesInFight":
			if err := func() error {
				s.SurvivedThreeImmobilizesInFight.Reset()
				if err := s.SurvivedThreeImmobilizesInFight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"survivedThreeImmobilizesInFight\"")
			}
		case "takedownOnFirstTurret":
			if err := func() error {
				s.TakedownOnFirstTurret.Reset()
				if err := s.TakedownOnFirstTurret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"takedownOnFirstTurret\"")
			}
		case "takedowns":
			if err := func() error {
				s.Takedowns.Reset()
				if err := s.Takedowns.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"takedowns\"")
			}
		case "takedownsAfterGainingLevelAdvantage":
			if err := func() error {
				s.TakedownsAfterGainingLevelAdvantage.Reset()
				if err := s.TakedownsAfterGainingLevelAdvantage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"takedownsAfterGainingLevelAdvantage\"")
			}
		case "takedownsBeforeJungleMinionSpawn":
			if err := func() error {
				s.TakedownsBeforeJungleMinionSpawn.Reset()
				if err := s.TakedownsBeforeJungleMinionSpawn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"takedownsBeforeJungleMinionSpawn\"")
			}
		case "takedownsFirstXMinutes":
			if err := func() error {
				s.TakedownsFirstXMinutes.Reset()
				if err := s.TakedownsFirstXMinutes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"takedownsFirstXMinutes\"")
			}
		case "takedownsInAlcove":
			if err := func() error {
				s.TakedownsInAlcove.Reset()
				if err := s.TakedownsInAlcove.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"takedownsInAlcove\"")
			}
		case "takedownsInEnemyFountain":
			if err := func() error {
				s.TakedownsInEnemyFountain.Reset()
				if err := s.TakedownsInEnemyFountain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"takedownsInEnemyFountain\"")
			}
		case "teamBaronKills":
			if err := func() error {
				s.TeamBaronKills.Reset()
				if err := s.TeamBaronKills.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamBaronKills\"")
			}
		case "teamDamagePercentage":
			if err := func() error {
				s.TeamDamagePercentage.Reset()
				if err := s.TeamDamagePercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamDamagePercentage\"")
			}
		case "teamElderDragonKills":
			if err := func() error {
				s.TeamElderDragonKills.Reset()
				if err := s.TeamElderDragonKills.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamElderDragonKills\"")
			}
		case "teamRiftHeraldKills":
			if err := func() error {
				s.TeamRiftHeraldKills.Reset()
				if err := s.TeamRiftHeraldKills.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamRiftHeraldKills\"")
			}
		case "tookLargeDamageSurvived":
			if err := func() error {
				s.TookLargeDamageSurvived.Reset()
				if err := s.TookLargeDamageSurvived.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tookLargeDamageSurvived\"")
			}
		case "turretPlatesTaken":
			if err := func() error {
				s.TurretPlatesTaken.Reset()
				if err := s.TurretPlatesTaken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"turretPlatesTaken\"")
			}
		case "turretsTakenWithRiftHerald":
			if err := func() error {
				s.TurretsTakenWithRiftHerald.Reset()
				if err := s.TurretsTakenWithRiftHerald.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"turretsTakenWithRiftHerald\"")
			}
		case "turretTakedowns":
			if err := func() error {
				s.TurretTakedowns.Reset()
				if err := s.TurretTakedowns.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"turretTakedowns\"")
			}
		case "twentyMinionsIn3SecondsCount":
			if err := func() error {
				s.TwentyMinionsIn3SecondsCount.Reset()
				if err := s.TwentyMinionsIn3SecondsCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"twentyMinionsIn3SecondsCount\"")
			}
		case "twoWardsOneSweeperCount":
			if err := func() error {
				s.TwoWardsOneSweeperCount.Reset()
				if err := s.TwoWardsOneSweeperCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"twoWardsOneSweeperCount\"")
			}
		case "unseenRecalls":
			if err := func() error {
				s.UnseenRecalls.Reset()
				if err := s.UnseenRecalls.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unseenRecalls\"")
			}
		case "visionScorePerMinute":
			if err := func() error {
				s.VisionScorePerMinute.Reset()
				if err := s.VisionScorePerMinute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visionScorePerMinute\"")
			}
		case "wardsGuarded":
			if err := func() error {
				s.WardsGuarded.Reset()
				if err := s.WardsGuarded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wardsGuarded\"")
			}
		case "wardTakedowns":
			if err := func() error {
				s.WardTakedowns.Reset()
				if err := s.WardTakedowns.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wardTakedowns\"")
			}
		case "wardTakedownsBefore20M":
			if err := func() error {
				s.WardTakedownsBefore20M.Reset()
				if err := s.WardTakedownsBefore20M.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wardTakedownsBefore20M\"")
			}
		case "HealFromMapSources":
			if err := func() error {
				s.HealFromMapSources.Reset()
				if err := s.HealFromMapSources.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"HealFromMapSources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5ChallengesDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5ChallengesDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5ChallengesDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MatchV5ChallengesDtoFasterSupportQuestCompletion as json.
func (s MatchV5ChallengesDtoFasterSupportQuestCompletion) Encode(e *jx.Encoder) {
	e.Int32(int32(s))
}

// Decode decodes MatchV5ChallengesDtoFasterSupportQuestCompletion from json.
func (s *MatchV5ChallengesDtoFasterSupportQuestCompletion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5ChallengesDtoFasterSupportQuestCompletion to nil")
	}
	v, err := d.Int32()
	if err != nil {
		return err
	}
	*s = MatchV5ChallengesDtoFasterSupportQuestCompletion(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MatchV5ChallengesDtoFasterSupportQuestCompletion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5ChallengesDtoFasterSupportQuestCompletion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MatchV5ChallengesDtoHadAfkTeammate as json.
func (s MatchV5ChallengesDtoHadAfkTeammate) Encode(e *jx.Encoder) {
	e.Int32(int32(s))
}

// Decode decodes MatchV5ChallengesDtoHadAfkTeammate from json.
func (s *MatchV5ChallengesDtoHadAfkTeammate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5ChallengesDtoHadAfkTeammate to nil")
	}
	v, err := d.Int32()
	if err != nil {
		return err
	}
	*s = MatchV5ChallengesDtoHadAfkTeammate(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MatchV5ChallengesDtoHadAfkTeammate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5ChallengesDtoHadAfkTeammate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MatchV5ChallengesDtoHighestCrowdControlScore as json.
func (s MatchV5ChallengesDtoHighestCrowdControlScore) Encode(e *jx.Encoder) {
	e.Int32(int32(s))
}

// Decode decodes MatchV5ChallengesDtoHighestCrowdControlScore from json.
func (s *MatchV5ChallengesDtoHighestCrowdControlScore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5ChallengesDtoHighestCrowdControlScore to nil")
	}
	v, err := d.Int32()
	if err != nil {
		return err
	}
	*s = MatchV5ChallengesDtoHighestCrowdControlScore(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MatchV5ChallengesDtoHighestCrowdControlScore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5ChallengesDtoHighestCrowdControlScore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MatchV5ChallengesDtoHighestWardKills as json.
func (s MatchV5ChallengesDtoHighestWardKills) Encode(e *jx.Encoder) {
	e.Int32(int32(s))
}

// Decode decodes MatchV5ChallengesDtoHighestWardKills from json.
func (s *MatchV5ChallengesDtoHighestWardKills) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5ChallengesDtoHighestWardKills to nil")
	}
	v, err := d.Int32()
	if err != nil {
		return err
	}
	*s = MatchV5ChallengesDtoHighestWardKills(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MatchV5ChallengesDtoHighestWardKills) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5ChallengesDtoHighestWardKills) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MatchV5ChallengesDtoLaningPhaseGoldExpAdvantage as json.
func (s MatchV5ChallengesDtoLaningPhaseGoldExpAdvantage) Encode(e *jx.Encoder) {
	e.Int32(int32(s))
}

// Decode decodes MatchV5ChallengesDtoLaningPhaseGoldExpAdvantage from json.
func (s *MatchV5ChallengesDtoLaningPhaseGoldExpAdvantage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5ChallengesDtoLaningPhaseGoldExpAdvantage to nil")
	}
	v, err := d.Int32()
	if err != nil {
		return err
	}
	*s = MatchV5ChallengesDtoLaningPhaseGoldExpAdvantage(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MatchV5ChallengesDtoLaningPhaseGoldExpAdvantage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5ChallengesDtoLaningPhaseGoldExpAdvantage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MatchV5ChallengesDtoPlayedChampSelectPosition as json.
func (s MatchV5ChallengesDtoPlayedChampSelectPosition) Encode(e *jx.Encoder) {
	e.Int32(int32(s))
}

// Decode decodes MatchV5ChallengesDtoPlayedChampSelectPosition from json.
func (s *MatchV5ChallengesDtoPlayedChampSelectPosition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5ChallengesDtoPlayedChampSelectPosition to nil")
	}
	v, err := d.Int32()
	if err != nil {
		return err
	}
	*s = MatchV5ChallengesDtoPlayedChampSelectPosition(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MatchV5ChallengesDtoPlayedChampSelectPosition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5ChallengesDtoPlayedChampSelectPosition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5ChampionStatsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5ChampionStatsDto) encodeFields(e *jx.Encoder) {
	{
		if s.AbilityHaste.Set {
			e.FieldStart("abilityHaste")
			s.AbilityHaste.Encode(e)
		}
	}
	{
		e.FieldStart("abilityPower")
		e.Int32(s.AbilityPower)
	}
	{
		e.FieldStart("armor")
		e.Int32(s.Armor)
	}
	{
		e.FieldStart("armorPen")
		e.Int32(s.ArmorPen)
	}
	{
		e.FieldStart("armorPenPercent")
		e.Int32(s.ArmorPenPercent)
	}
	{
		e.FieldStart("attackDamage")
		e.Int32(s.AttackDamage)
	}
	{
		e.FieldStart("attackSpeed")
		e.Int32(s.AttackSpeed)
	}
	{
		e.FieldStart("bonusArmorPenPercent")
		e.Int32(s.BonusArmorPenPercent)
	}
	{
		e.FieldStart("bonusMagicPenPercent")
		e.Int32(s.BonusMagicPenPercent)
	}
	{
		e.FieldStart("ccReduction")
		e.Int32(s.CcReduction)
	}
	{
		e.FieldStart("cooldownReduction")
		e.Int32(s.CooldownReduction)
	}
	{
		e.FieldStart("health")
		e.Int32(s.Health)
	}
	{
		e.FieldStart("healthMax")
		e.Int32(s.HealthMax)
	}
	{
		e.FieldStart("healthRegen")
		e.Int32(s.HealthRegen)
	}
	{
		e.FieldStart("lifesteal")
		e.Int32(s.Lifesteal)
	}
	{
		e.FieldStart("magicPen")
		e.Int32(s.MagicPen)
	}
	{
		e.FieldStart("magicPenPercent")
		e.Int32(s.MagicPenPercent)
	}
	{
		e.FieldStart("magicResist")
		e.Int32(s.MagicResist)
	}
	{
		e.FieldStart("movementSpeed")
		e.Int32(s.MovementSpeed)
	}
	{
		if s.Omnivamp.Set {
			e.FieldStart("omnivamp")
			s.Omnivamp.Encode(e)
		}
	}
	{
		if s.PhysicalVamp.Set {
			e.FieldStart("physicalVamp")
			s.PhysicalVamp.Encode(e)
		}
	}
	{
		e.FieldStart("power")
		e.Int32(s.Power)
	}
	{
		e.FieldStart("powerMax")
		e.Int32(s.PowerMax)
	}
	{
		e.FieldStart("powerRegen")
		e.Int32(s.PowerRegen)
	}
	{
		e.FieldStart("spellVamp")
		e.Int32(s.SpellVamp)
	}
}

var jsonFieldsNameOfMatchV5ChampionStatsDto = [25]string{
	0:  "abilityHaste",
	1:  "abilityPower",
	2:  "armor",
	3:  "armorPen",
	4:  "armorPenPercent",
	5:  "attackDamage",
	6:  "attackSpeed",
	7:  "bonusArmorPenPercent",
	8:  "bonusMagicPenPercent",
	9:  "ccReduction",
	10: "cooldownReduction",
	11: "health",
	12: "healthMax",
	13: "healthRegen",
	14: "lifesteal",
	15: "magicPen",
	16: "magicPenPercent",
	17: "magicResist",
	18: "movementSpeed",
	19: "omnivamp",
	20: "physicalVamp",
	21: "power",
	22: "powerMax",
	23: "powerRegen",
	24: "spellVamp",
}

// Decode decodes MatchV5ChampionStatsDto from json.
func (s *MatchV5ChampionStatsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5ChampionStatsDto to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "abilityHaste":
			if err := func() error {
				s.AbilityHaste.Reset()
				if err := s.AbilityHaste.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"abilityHaste\"")
			}
		case "abilityPower":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.AbilityPower = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"abilityPower\"")
			}
		case "armor":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Armor = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"armor\"")
			}
		case "armorPen":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.ArmorPen = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"armorPen\"")
			}
		case "armorPenPercent":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.ArmorPenPercent = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"armorPenPercent\"")
			}
		case "attackDamage":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.AttackDamage = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attackDamage\"")
			}
		case "attackSpeed":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.AttackSpeed = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attackSpeed\"")
			}
		case "bonusArmorPenPercent":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.BonusArmorPenPercent = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bonusArmorPenPercent\"")
			}
		case "bonusMagicPenPercent":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.BonusMagicPenPercent = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bonusMagicPenPercent\"")
			}
		case "ccReduction":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.CcReduction = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ccReduction\"")
			}
		case "cooldownReduction":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.CooldownReduction = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cooldownReduction\"")
			}
		case "health":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Health = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"health\"")
			}
		case "healthMax":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.HealthMax = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"healthMax\"")
			}
		case "healthRegen":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.HealthRegen = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"healthRegen\"")
			}
		case "lifesteal":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.Lifesteal = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifesteal\"")
			}
		case "magicPen":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.MagicPen = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"magicPen\"")
			}
		case "magicPenPercent":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.MagicPenPercent = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"magicPenPercent\"")
			}
		case "magicResist":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.MagicResist = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"magicResist\"")
			}
		case "movementSpeed":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.MovementSpeed = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"movementSpeed\"")
			}
		case "omnivamp":
			if err := func() error {
				s.Omnivamp.Reset()
				if err := s.Omnivamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"omnivamp\"")
			}
		case "physicalVamp":
			if err := func() error {
				s.PhysicalVamp.Reset()
				if err := s.PhysicalVamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physicalVamp\"")
			}
		case "power":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.Power = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"power\"")
			}
		case "powerMax":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.PowerMax = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"powerMax\"")
			}
		case "powerRegen":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.PowerRegen = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"powerRegen\"")
			}
		case "spellVamp":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.SpellVamp = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spellVamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5ChampionStatsDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111110,
		0b11111111,
		0b11100111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchV5ChampionStatsDto) {
					name = jsonFieldsNameOfMatchV5ChampionStatsDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5ChampionStatsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5ChampionStatsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5DamageStatsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5DamageStatsDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("magicDamageDone")
		e.Int32(s.MagicDamageDone)
	}
	{
		e.FieldStart("magicDamageDoneToChampions")
		e.Int32(s.MagicDamageDoneToChampions)
	}
	{
		e.FieldStart("magicDamageTaken")
		e.Int32(s.MagicDamageTaken)
	}
	{
		e.FieldStart("physicalDamageDone")
		e.Int32(s.PhysicalDamageDone)
	}
	{
		e.FieldStart("physicalDamageDoneToChampions")
		e.Int32(s.PhysicalDamageDoneToChampions)
	}
	{
		e.FieldStart("physicalDamageTaken")
		e.Int32(s.PhysicalDamageTaken)
	}
	{
		e.FieldStart("totalDamageDone")
		e.Int32(s.TotalDamageDone)
	}
	{
		e.FieldStart("totalDamageDoneToChampions")
		e.Int32(s.TotalDamageDoneToChampions)
	}
	{
		e.FieldStart("totalDamageTaken")
		e.Int32(s.TotalDamageTaken)
	}
	{
		e.FieldStart("trueDamageDone")
		e.Int32(s.TrueDamageDone)
	}
	{
		e.FieldStart("trueDamageDoneToChampions")
		e.Int32(s.TrueDamageDoneToChampions)
	}
	{
		e.FieldStart("trueDamageTaken")
		e.Int32(s.TrueDamageTaken)
	}
}

var jsonFieldsNameOfMatchV5DamageStatsDto = [12]string{
	0:  "magicDamageDone",
	1:  "magicDamageDoneToChampions",
	2:  "magicDamageTaken",
	3:  "physicalDamageDone",
	4:  "physicalDamageDoneToChampions",
	5:  "physicalDamageTaken",
	6:  "totalDamageDone",
	7:  "totalDamageDoneToChampions",
	8:  "totalDamageTaken",
	9:  "trueDamageDone",
	10: "trueDamageDoneToChampions",
	11: "trueDamageTaken",
}

// Decode decodes MatchV5DamageStatsDto from json.
func (s *MatchV5DamageStatsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5DamageStatsDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "magicDamageDone":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.MagicDamageDone = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"magicDamageDone\"")
			}
		case "magicDamageDoneToChampions":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.MagicDamageDoneToChampions = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"magicDamageDoneToChampions\"")
			}
		case "magicDamageTaken":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.MagicDamageTaken = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"magicDamageTaken\"")
			}
		case "physicalDamageDone":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.PhysicalDamageDone = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physicalDamageDone\"")
			}
		case "physicalDamageDoneToChampions":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.PhysicalDamageDoneToChampions = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physicalDamageDoneToChampions\"")
			}
		case "physicalDamageTaken":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.PhysicalDamageTaken = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physicalDamageTaken\"")
			}
		case "totalDamageDone":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.TotalDamageDone = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalDamageDone\"")
			}
		case "totalDamageDoneToChampions":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.TotalDamageDoneToChampions = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalDamageDoneToChampions\"")
			}
		case "totalDamageTaken":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.TotalDamageTaken = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalDamageTaken\"")
			}
		case "trueDamageDone":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.TrueDamageDone = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trueDamageDone\"")
			}
		case "trueDamageDoneToChampions":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.TrueDamageDoneToChampions = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trueDamageDoneToChampions\"")
			}
		case "trueDamageTaken":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.TrueDamageTaken = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trueDamageTaken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5DamageStatsDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchV5DamageStatsDto) {
					name = jsonFieldsNameOfMatchV5DamageStatsDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5DamageStatsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5DamageStatsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5EventsTimeLineDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5EventsTimeLineDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("timestamp")
		e.Int64(s.Timestamp)
	}
	{
		if s.RealTimestamp.Set {
			e.FieldStart("realTimestamp")
			s.RealTimestamp.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.ItemId.Set {
			e.FieldStart("itemId")
			s.ItemId.Encode(e)
		}
	}
	{
		if s.ParticipantId.Set {
			e.FieldStart("participantId")
			s.ParticipantId.Encode(e)
		}
	}
	{
		if s.LevelUpType.Set {
			e.FieldStart("levelUpType")
			s.LevelUpType.Encode(e)
		}
	}
	{
		if s.SkillSlot.Set {
			e.FieldStart("skillSlot")
			s.SkillSlot.Encode(e)
		}
	}
	{
		if s.CreatorId.Set {
			e.FieldStart("creatorId")
			s.CreatorId.Encode(e)
		}
	}
	{
		if s.WardType.Set {
			e.FieldStart("wardType")
			s.WardType.Encode(e)
		}
	}
	{
		if s.Level.Set {
			e.FieldStart("level")
			s.Level.Encode(e)
		}
	}
	{
		if s.AssistingParticipantIds != nil {
			e.FieldStart("assistingParticipantIds")
			e.ArrStart()
			for _, elem := range s.AssistingParticipantIds {
				e.Int32(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Bounty.Set {
			e.FieldStart("bounty")
			s.Bounty.Encode(e)
		}
	}
	{
		if s.KillStreakLength.Set {
			e.FieldStart("killStreakLength")
			s.KillStreakLength.Encode(e)
		}
	}
	{
		if s.KillerId.Set {
			e.FieldStart("killerId")
			s.KillerId.Encode(e)
		}
	}
	{
		if s.Position.Set {
			e.FieldStart("position")
			s.Position.Encode(e)
		}
	}
	{
		if s.VictimDamageDealt != nil {
			e.FieldStart("victimDamageDealt")
			e.ArrStart()
			for _, elem := range s.VictimDamageDealt {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.VictimDamageReceived != nil {
			e.FieldStart("victimDamageReceived")
			e.ArrStart()
			for _, elem := range s.VictimDamageReceived {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.VictimId.Set {
			e.FieldStart("victimId")
			s.VictimId.Encode(e)
		}
	}
	{
		if s.KillType.Set {
			e.FieldStart("killType")
			s.KillType.Encode(e)
		}
	}
	{
		if s.LaneType.Set {
			e.FieldStart("laneType")
			s.LaneType.Encode(e)
		}
	}
	{
		if s.TeamId.Set {
			e.FieldStart("teamId")
			s.TeamId.Encode(e)
		}
	}
	{
		if s.MultiKillLength.Set {
			e.FieldStart("multiKillLength")
			s.MultiKillLength.Encode(e)
		}
	}
	{
		if s.KillerTeamId.Set {
			e.FieldStart("killerTeamId")
			s.KillerTeamId.Encode(e)
		}
	}
	{
		if s.MonsterType.Set {
			e.FieldStart("monsterType")
			s.MonsterType.Encode(e)
		}
	}
	{
		if s.MonsterSubType.Set {
			e.FieldStart("monsterSubType")
			s.MonsterSubType.Encode(e)
		}
	}
	{
		if s.BuildingType.Set {
			e.FieldStart("buildingType")
			s.BuildingType.Encode(e)
		}
	}
	{
		if s.TowerType.Set {
			e.FieldStart("towerType")
			s.TowerType.Encode(e)
		}
	}
	{
		if s.AfterId.Set {
			e.FieldStart("afterId")
			s.AfterId.Encode(e)
		}
	}
	{
		if s.BeforeId.Set {
			e.FieldStart("beforeId")
			s.BeforeId.Encode(e)
		}
	}
	{
		if s.GoldGain.Set {
			e.FieldStart("goldGain")
			s.GoldGain.Encode(e)
		}
	}
	{
		if s.GameId.Set {
			e.FieldStart("gameId")
			s.GameId.Encode(e)
		}
	}
	{
		if s.WinningTeam.Set {
			e.FieldStart("winningTeam")
			s.WinningTeam.Encode(e)
		}
	}
	{
		if s.TransformType.Set {
			e.FieldStart("transformType")
			s.TransformType.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.ShutdownBounty.Set {
			e.FieldStart("shutdownBounty")
			s.ShutdownBounty.Encode(e)
		}
	}
	{
		if s.ActualStartTime.Set {
			e.FieldStart("actualStartTime")
			s.ActualStartTime.Encode(e)
		}
	}
	{
		if s.FeatType.Set {
			e.FieldStart("featType")
			s.FeatType.Encode(e)
		}
	}
	{
		if s.FeatValue.Set {
			e.FieldStart("featValue")
			s.FeatValue.Encode(e)
		}
	}
}

var jsonFieldsNameOfMatchV5EventsTimeLineDto = [38]string{
	0:  "timestamp",
	1:  "realTimestamp",
	2:  "type",
	3:  "itemId",
	4:  "participantId",
	5:  "levelUpType",
	6:  "skillSlot",
	7:  "creatorId",
	8:  "wardType",
	9:  "level",
	10: "assistingParticipantIds",
	11: "bounty",
	12: "killStreakLength",
	13: "killerId",
	14: "position",
	15: "victimDamageDealt",
	16: "victimDamageReceived",
	17: "victimId",
	18: "killType",
	19: "laneType",
	20: "teamId",
	21: "multiKillLength",
	22: "killerTeamId",
	23: "monsterType",
	24: "monsterSubType",
	25: "buildingType",
	26: "towerType",
	27: "afterId",
	28: "beforeId",
	29: "goldGain",
	30: "gameId",
	31: "winningTeam",
	32: "transformType",
	33: "name",
	34: "shutdownBounty",
	35: "actualStartTime",
	36: "featType",
	37: "featValue",
}

// Decode decodes MatchV5EventsTimeLineDto from json.
func (s *MatchV5EventsTimeLineDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5EventsTimeLineDto to nil")
	}
	var requiredBitSet [5]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.Timestamp = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "realTimestamp":
			if err := func() error {
				s.RealTimestamp.Reset()
				if err := s.RealTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"realTimestamp\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "itemId":
			if err := func() error {
				s.ItemId.Reset()
				if err := s.ItemId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"itemId\"")
			}
		case "participantId":
			if err := func() error {
				s.ParticipantId.Reset()
				if err := s.ParticipantId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participantId\"")
			}
		case "levelUpType":
			if err := func() error {
				s.LevelUpType.Reset()
				if err := s.LevelUpType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"levelUpType\"")
			}
		case "skillSlot":
			if err := func() error {
				s.SkillSlot.Reset()
				if err := s.SkillSlot.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skillSlot\"")
			}
		case "creatorId":
			if err := func() error {
				s.CreatorId.Reset()
				if err := s.CreatorId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creatorId\"")
			}
		case "wardType":
			if err := func() error {
				s.WardType.Reset()
				if err := s.WardType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wardType\"")
			}
		case "level":
			if err := func() error {
				s.Level.Reset()
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "assistingParticipantIds":
			if err := func() error {
				s.AssistingParticipantIds = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int32
					v, err := d.Int32()
					elem = int32(v)
					if err != nil {
						return err
					}
					s.AssistingParticipantIds = append(s.AssistingParticipantIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assistingParticipantIds\"")
			}
		case "bounty":
			if err := func() error {
				s.Bounty.Reset()
				if err := s.Bounty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bounty\"")
			}
		case "killStreakLength":
			if err := func() error {
				s.KillStreakLength.Reset()
				if err := s.KillStreakLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"killStreakLength\"")
			}
		case "killerId":
			if err := func() error {
				s.KillerId.Reset()
				if err := s.KillerId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"killerId\"")
			}
		case "position":
			if err := func() error {
				s.Position.Reset()
				if err := s.Position.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "victimDamageDealt":
			if err := func() error {
				s.VictimDamageDealt = make([]MatchV5MatchTimelineVictimDamage, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MatchV5MatchTimelineVictimDamage
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VictimDamageDealt = append(s.VictimDamageDealt, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"victimDamageDealt\"")
			}
		case "victimDamageReceived":
			if err := func() error {
				s.VictimDamageReceived = make([]MatchV5MatchTimelineVictimDamage, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MatchV5MatchTimelineVictimDamage
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VictimDamageReceived = append(s.VictimDamageReceived, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"victimDamageReceived\"")
			}
		case "victimId":
			if err := func() error {
				s.VictimId.Reset()
				if err := s.VictimId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"victimId\"")
			}
		case "killType":
			if err := func() error {
				s.KillType.Reset()
				if err := s.KillType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"killType\"")
			}
		case "laneType":
			if err := func() error {
				s.LaneType.Reset()
				if err := s.LaneType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"laneType\"")
			}
		case "teamId":
			if err := func() error {
				s.TeamId.Reset()
				if err := s.TeamId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamId\"")
			}
		case "multiKillLength":
			if err := func() error {
				s.MultiKillLength.Reset()
				if err := s.MultiKillLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"multiKillLength\"")
			}
		case "killerTeamId":
			if err := func() error {
				s.KillerTeamId.Reset()
				if err := s.KillerTeamId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"killerTeamId\"")
			}
		case "monsterType":
			if err := func() error {
				s.MonsterType.Reset()
				if err := s.MonsterType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monsterType\"")
			}
		case "monsterSubType":
			if err := func() error {
				s.MonsterSubType.Reset()
				if err := s.MonsterSubType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monsterSubType\"")
			}
		case "buildingType":
			if err := func() error {
				s.BuildingType.Reset()
				if err := s.BuildingType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buildingType\"")
			}
		case "towerType":
			if err := func() error {
				s.TowerType.Reset()
				if err := s.TowerType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"towerType\"")
			}
		case "afterId":
			if err := func() error {
				s.AfterId.Reset()
				if err := s.AfterId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"afterId\"")
			}
		case "beforeId":
			if err := func() error {
				s.BeforeId.Reset()
				if err := s.BeforeId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"beforeId\"")
			}
		case "goldGain":
			if err := func() error {
				s.GoldGain.Reset()
				if err := s.GoldGain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"goldGain\"")
			}
		case "gameId":
			if err := func() error {
				s.GameId.Reset()
				if err := s.GameId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameId\"")
			}
		case "winningTeam":
			if err := func() error {
				s.WinningTeam.Reset()
				if err := s.WinningTeam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"winningTeam\"")
			}
		case "transformType":
			if err := func() error {
				s.TransformType.Reset()
				if err := s.TransformType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transformType\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "shutdownBounty":
			if err := func() error {
				s.ShutdownBounty.Reset()
				if err := s.ShutdownBounty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shutdownBounty\"")
			}
		case "actualStartTime":
			if err := func() error {
				s.ActualStartTime.Reset()
				if err := s.ActualStartTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actualStartTime\"")
			}
		case "featType":
			if err := func() error {
				s.FeatType.Reset()
				if err := s.FeatType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featType\"")
			}
		case "featValue":
			if err := func() error {
				s.FeatValue.Reset()
				if err := s.FeatValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featValue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5EventsTimeLineDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [5]uint8{
		0b00000101,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchV5EventsTimeLineDto) {
					name = jsonFieldsNameOfMatchV5EventsTimeLineDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5EventsTimeLineDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5EventsTimeLineDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5FeatDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5FeatDto) encodeFields(e *jx.Encoder) {
	{
		if s.FeatState.Set {
			e.FieldStart("featState")
			s.FeatState.Encode(e)
		}
	}
}

var jsonFieldsNameOfMatchV5FeatDto = [1]string{
	0: "featState",
}

// Decode decodes MatchV5FeatDto from json.
func (s *MatchV5FeatDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5FeatDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "featState":
			if err := func() error {
				s.FeatState.Reset()
				if err := s.FeatState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featState\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5FeatDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5FeatDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5FeatDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5FeatsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5FeatsDto) encodeFields(e *jx.Encoder) {
	{
		if s.EPICMONSTERKILL.Set {
			e.FieldStart("EPIC_MONSTER_KILL")
			s.EPICMONSTERKILL.Encode(e)
		}
	}
	{
		if s.FIRSTBLOOD.Set {
			e.FieldStart("FIRST_BLOOD")
			s.FIRSTBLOOD.Encode(e)
		}
	}
	{
		if s.FIRSTTURRET.Set {
			e.FieldStart("FIRST_TURRET")
			s.FIRSTTURRET.Encode(e)
		}
	}
}

var jsonFieldsNameOfMatchV5FeatsDto = [3]string{
	0: "EPIC_MONSTER_KILL",
	1: "FIRST_BLOOD",
	2: "FIRST_TURRET",
}

// Decode decodes MatchV5FeatsDto from json.
func (s *MatchV5FeatsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5FeatsDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "EPIC_MONSTER_KILL":
			if err := func() error {
				s.EPICMONSTERKILL.Reset()
				if err := s.EPICMONSTERKILL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"EPIC_MONSTER_KILL\"")
			}
		case "FIRST_BLOOD":
			if err := func() error {
				s.FIRSTBLOOD.Reset()
				if err := s.FIRSTBLOOD.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"FIRST_BLOOD\"")
			}
		case "FIRST_TURRET":
			if err := func() error {
				s.FIRSTTURRET.Reset()
				if err := s.FIRSTTURRET.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"FIRST_TURRET\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5FeatsDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5FeatsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5FeatsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5FramesTimeLineDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5FramesTimeLineDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("events")
		e.ArrStart()
		for _, elem := range s.Events {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.ParticipantFrames.Set {
			e.FieldStart("participantFrames")
			s.ParticipantFrames.Encode(e)
		}
	}
	{
		e.FieldStart("timestamp")
		e.Int32(s.Timestamp)
	}
}

var jsonFieldsNameOfMatchV5FramesTimeLineDto = [3]string{
	0: "events",
	1: "participantFrames",
	2: "timestamp",
}

// Decode decodes MatchV5FramesTimeLineDto from json.
func (s *MatchV5FramesTimeLineDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5FramesTimeLineDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "events":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Events = make([]MatchV5EventsTimeLineDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MatchV5EventsTimeLineDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "participantFrames":
			if err := func() error {
				s.ParticipantFrames.Reset()
				if err := s.ParticipantFrames.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participantFrames\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Timestamp = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5FramesTimeLineDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchV5FramesTimeLineDto) {
					name = jsonFieldsNameOfMatchV5FramesTimeLineDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5FramesTimeLineDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5FramesTimeLineDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s MatchV5FramesTimeLineDtoParticipantFrames) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s MatchV5FramesTimeLineDtoParticipantFrames) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes MatchV5FramesTimeLineDtoParticipantFrames from json.
func (s *MatchV5FramesTimeLineDtoParticipantFrames) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5FramesTimeLineDtoParticipantFrames to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem MatchV5ParticipantFrameDto
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5FramesTimeLineDtoParticipantFrames")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MatchV5FramesTimeLineDtoParticipantFrames) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5FramesTimeLineDtoParticipantFrames) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MatchV5GetMatchIdsByPUUIDOKApplicationJSON as json.
func (s MatchV5GetMatchIdsByPUUIDOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []string(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes MatchV5GetMatchIdsByPUUIDOKApplicationJSON from json.
func (s *MatchV5GetMatchIdsByPUUIDOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5GetMatchIdsByPUUIDOKApplicationJSON to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = MatchV5GetMatchIdsByPUUIDOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MatchV5GetMatchIdsByPUUIDOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5GetMatchIdsByPUUIDOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5InfoDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5InfoDto) encodeFields(e *jx.Encoder) {
	{
		if s.EndOfGameResult.Set {
			e.FieldStart("endOfGameResult")
			s.EndOfGameResult.Encode(e)
		}
	}
	{
		e.FieldStart("gameCreation")
		e.Int64(s.GameCreation)
	}
	{
		e.FieldStart("gameDuration")
		e.Int64(s.GameDuration)
	}
	{
		if s.GameEndTimestamp.Set {
			e.FieldStart("gameEndTimestamp")
			s.GameEndTimestamp.Encode(e)
		}
	}
	{
		e.FieldStart("gameId")
		e.Int64(s.GameId)
	}
	{
		e.FieldStart("gameMode")
		e.Str(s.GameMode)
	}
	{
		e.FieldStart("gameName")
		e.Str(s.GameName)
	}
	{
		e.FieldStart("gameStartTimestamp")
		e.Int64(s.GameStartTimestamp)
	}
	{
		e.FieldStart("gameType")
		e.Str(s.GameType)
	}
	{
		e.FieldStart("gameVersion")
		e.Str(s.GameVersion)
	}
	{
		e.FieldStart("mapId")
		e.Int32(s.MapId)
	}
	{
		e.FieldStart("participants")
		e.ArrStart()
		for _, elem := range s.Participants {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("platformId")
		e.Str(s.PlatformId)
	}
	{
		e.FieldStart("queueId")
		e.Int32(s.QueueId)
	}
	{
		e.FieldStart("teams")
		e.ArrStart()
		for _, elem := range s.Teams {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.TournamentCode.Set {
			e.FieldStart("tournamentCode")
			s.TournamentCode.Encode(e)
		}
	}
	{
		if s.GameModeMutators != nil {
			e.FieldStart("gameModeMutators")
			e.ArrStart()
			for _, elem := range s.GameModeMutators {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfMatchV5InfoDto = [17]string{
	0:  "endOfGameResult",
	1:  "gameCreation",
	2:  "gameDuration",
	3:  "gameEndTimestamp",
	4:  "gameId",
	5:  "gameMode",
	6:  "gameName",
	7:  "gameStartTimestamp",
	8:  "gameType",
	9:  "gameVersion",
	10: "mapId",
	11: "participants",
	12: "platformId",
	13: "queueId",
	14: "teams",
	15: "tournamentCode",
	16: "gameModeMutators",
}

// Decode decodes MatchV5InfoDto from json.
func (s *MatchV5InfoDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5InfoDto to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "endOfGameResult":
			if err := func() error {
				s.EndOfGameResult.Reset()
				if err := s.EndOfGameResult.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endOfGameResult\"")
			}
		case "gameCreation":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.GameCreation = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameCreation\"")
			}
		case "gameDuration":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.GameDuration = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameDuration\"")
			}
		case "gameEndTimestamp":
			if err := func() error {
				s.GameEndTimestamp.Reset()
				if err := s.GameEndTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameEndTimestamp\"")
			}
		case "gameId":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.GameId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameId\"")
			}
		case "gameMode":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.GameMode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameMode\"")
			}
		case "gameName":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.GameName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameName\"")
			}
		case "gameStartTimestamp":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int64()
				s.GameStartTimestamp = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameStartTimestamp\"")
			}
		case "gameType":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GameType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameType\"")
			}
		case "gameVersion":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GameVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameVersion\"")
			}
		case "mapId":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.MapId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mapId\"")
			}
		case "participants":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				s.Participants = make([]MatchV5ParticipantDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MatchV5ParticipantDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Participants = append(s.Participants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participants\"")
			}
		case "platformId":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.PlatformId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platformId\"")
			}
		case "queueId":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.QueueId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queueId\"")
			}
		case "teams":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				s.Teams = make([]MatchV5TeamDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MatchV5TeamDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		case "tournamentCode":
			if err := func() error {
				s.TournamentCode.Reset()
				if err := s.TournamentCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tournamentCode\"")
			}
		case "gameModeMutators":
			if err := func() error {
				s.GameModeMutators = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.GameModeMutators = append(s.GameModeMutators, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameModeMutators\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5InfoDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11110110,
		0b01111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchV5InfoDto) {
					name = jsonFieldsNameOfMatchV5InfoDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5InfoDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5InfoDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5InfoTimeLineDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5InfoTimeLineDto) encodeFields(e *jx.Encoder) {
	{
		if s.EndOfGameResult.Set {
			e.FieldStart("endOfGameResult")
			s.EndOfGameResult.Encode(e)
		}
	}
	{
		e.FieldStart("frameInterval")
		e.Int64(s.FrameInterval)
	}
	{
		if s.GameId.Set {
			e.FieldStart("gameId")
			s.GameId.Encode(e)
		}
	}
	{
		if s.Participants != nil {
			e.FieldStart("participants")
			e.ArrStart()
			for _, elem := range s.Participants {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("frames")
		e.ArrStart()
		for _, elem := range s.Frames {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfMatchV5InfoTimeLineDto = [5]string{
	0: "endOfGameResult",
	1: "frameInterval",
	2: "gameId",
	3: "participants",
	4: "frames",
}

// Decode decodes MatchV5InfoTimeLineDto from json.
func (s *MatchV5InfoTimeLineDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5InfoTimeLineDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "endOfGameResult":
			if err := func() error {
				s.EndOfGameResult.Reset()
				if err := s.EndOfGameResult.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endOfGameResult\"")
			}
		case "frameInterval":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.FrameInterval = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frameInterval\"")
			}
		case "gameId":
			if err := func() error {
				s.GameId.Reset()
				if err := s.GameId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameId\"")
			}
		case "participants":
			if err := func() error {
				s.Participants = make([]MatchV5ParticipantTimeLineDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MatchV5ParticipantTimeLineDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Participants = append(s.Participants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participants\"")
			}
		case "frames":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Frames = make([]MatchV5FramesTimeLineDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MatchV5FramesTimeLineDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Frames = append(s.Frames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frames\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5InfoTimeLineDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchV5InfoTimeLineDto) {
					name = jsonFieldsNameOfMatchV5InfoTimeLineDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5InfoTimeLineDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5InfoTimeLineDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5MatchDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5MatchDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		e.FieldStart("info")
		s.Info.Encode(e)
	}
}

var jsonFieldsNameOfMatchV5MatchDto = [2]string{
	0: "metadata",
	1: "info",
}

// Decode decodes MatchV5MatchDto from json.
func (s *MatchV5MatchDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5MatchDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "info":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5MatchDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchV5MatchDto) {
					name = jsonFieldsNameOfMatchV5MatchDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5MatchDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5MatchDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5MatchTimelineVictimDamage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5MatchTimelineVictimDamage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("basic")
		e.Bool(s.Basic)
	}
	{
		e.FieldStart("magicDamage")
		e.Int32(s.MagicDamage)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("participantId")
		e.Int32(s.ParticipantId)
	}
	{
		e.FieldStart("physicalDamage")
		e.Int32(s.PhysicalDamage)
	}
	{
		e.FieldStart("spellName")
		e.Str(s.SpellName)
	}
	{
		e.FieldStart("spellSlot")
		e.Int32(s.SpellSlot)
	}
	{
		e.FieldStart("trueDamage")
		e.Int32(s.TrueDamage)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfMatchV5MatchTimelineVictimDamage = [9]string{
	0: "basic",
	1: "magicDamage",
	2: "name",
	3: "participantId",
	4: "physicalDamage",
	5: "spellName",
	6: "spellSlot",
	7: "trueDamage",
	8: "type",
}

// Decode decodes MatchV5MatchTimelineVictimDamage from json.
func (s *MatchV5MatchTimelineVictimDamage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5MatchTimelineVictimDamage to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "basic":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Basic = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"basic\"")
			}
		case "magicDamage":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.MagicDamage = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"magicDamage\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "participantId":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.ParticipantId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participantId\"")
			}
		case "physicalDamage":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.PhysicalDamage = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physicalDamage\"")
			}
		case "spellName":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.SpellName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spellName\"")
			}
		case "spellSlot":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.SpellSlot = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spellSlot\"")
			}
		case "trueDamage":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.TrueDamage = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trueDamage\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5MatchTimelineVictimDamage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchV5MatchTimelineVictimDamage) {
					name = jsonFieldsNameOfMatchV5MatchTimelineVictimDamage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5MatchTimelineVictimDamage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5MatchTimelineVictimDamage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5MetadataDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5MetadataDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dataVersion")
		e.Str(s.DataVersion)
	}
	{
		e.FieldStart("matchId")
		e.Str(s.MatchId)
	}
	{
		e.FieldStart("participants")
		e.ArrStart()
		for _, elem := range s.Participants {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfMatchV5MetadataDto = [3]string{
	0: "dataVersion",
	1: "matchId",
	2: "participants",
}

// Decode decodes MatchV5MetadataDto from json.
func (s *MatchV5MetadataDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5MetadataDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataVersion":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DataVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataVersion\"")
			}
		case "matchId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.MatchId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchId\"")
			}
		case "participants":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Participants = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Participants = append(s.Participants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participants\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5MetadataDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchV5MetadataDto) {
					name = jsonFieldsNameOfMatchV5MetadataDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5MetadataDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5MetadataDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5MetadataTimeLineDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5MetadataTimeLineDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dataVersion")
		e.Str(s.DataVersion)
	}
	{
		e.FieldStart("matchId")
		e.Str(s.MatchId)
	}
	{
		e.FieldStart("participants")
		e.ArrStart()
		for _, elem := range s.Participants {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfMatchV5MetadataTimeLineDto = [3]string{
	0: "dataVersion",
	1: "matchId",
	2: "participants",
}

// Decode decodes MatchV5MetadataTimeLineDto from json.
func (s *MatchV5MetadataTimeLineDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5MetadataTimeLineDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataVersion":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DataVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataVersion\"")
			}
		case "matchId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.MatchId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchId\"")
			}
		case "participants":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Participants = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Participants = append(s.Participants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participants\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5MetadataTimeLineDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchV5MetadataTimeLineDto) {
					name = jsonFieldsNameOfMatchV5MetadataTimeLineDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5MetadataTimeLineDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5MetadataTimeLineDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5MissionsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5MissionsDto) encodeFields(e *jx.Encoder) {
	{
		if s.PlayerScore0.Set {
			e.FieldStart("playerScore0")
			s.PlayerScore0.Encode(e)
		}
	}
	{
		if s.PlayerScore1.Set {
			e.FieldStart("playerScore1")
			s.PlayerScore1.Encode(e)
		}
	}
	{
		if s.PlayerScore2.Set {
			e.FieldStart("playerScore2")
			s.PlayerScore2.Encode(e)
		}
	}
	{
		if s.PlayerScore3.Set {
			e.FieldStart("playerScore3")
			s.PlayerScore3.Encode(e)
		}
	}
	{
		if s.PlayerScore4.Set {
			e.FieldStart("playerScore4")
			s.PlayerScore4.Encode(e)
		}
	}
	{
		if s.PlayerScore5.Set {
			e.FieldStart("playerScore5")
			s.PlayerScore5.Encode(e)
		}
	}
	{
		if s.PlayerScore6.Set {
			e.FieldStart("playerScore6")
			s.PlayerScore6.Encode(e)
		}
	}
	{
		if s.PlayerScore7.Set {
			e.FieldStart("playerScore7")
			s.PlayerScore7.Encode(e)
		}
	}
	{
		if s.PlayerScore8.Set {
			e.FieldStart("playerScore8")
			s.PlayerScore8.Encode(e)
		}
	}
	{
		if s.PlayerScore9.Set {
			e.FieldStart("playerScore9")
			s.PlayerScore9.Encode(e)
		}
	}
	{
		if s.PlayerScore10.Set {
			e.FieldStart("playerScore10")
			s.PlayerScore10.Encode(e)
		}
	}
	{
		if s.PlayerScore11.Set {
			e.FieldStart("playerScore11")
			s.PlayerScore11.Encode(e)
		}
	}
}

var jsonFieldsNameOfMatchV5MissionsDto = [12]string{
	0:  "playerScore0",
	1:  "playerScore1",
	2:  "playerScore2",
	3:  "playerScore3",
	4:  "playerScore4",
	5:  "playerScore5",
	6:  "playerScore6",
	7:  "playerScore7",
	8:  "playerScore8",
	9:  "playerScore9",
	10: "playerScore10",
	11: "playerScore11",
}

// Decode decodes MatchV5MissionsDto from json.
func (s *MatchV5MissionsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5MissionsDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "playerScore0":
			if err := func() error {
				s.PlayerScore0.Reset()
				if err := s.PlayerScore0.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore0\"")
			}
		case "playerScore1":
			if err := func() error {
				s.PlayerScore1.Reset()
				if err := s.PlayerScore1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore1\"")
			}
		case "playerScore2":
			if err := func() error {
				s.PlayerScore2.Reset()
				if err := s.PlayerScore2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore2\"")
			}
		case "playerScore3":
			if err := func() error {
				s.PlayerScore3.Reset()
				if err := s.PlayerScore3.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore3\"")
			}
		case "playerScore4":
			if err := func() error {
				s.PlayerScore4.Reset()
				if err := s.PlayerScore4.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore4\"")
			}
		case "playerScore5":
			if err := func() error {
				s.PlayerScore5.Reset()
				if err := s.PlayerScore5.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore5\"")
			}
		case "playerScore6":
			if err := func() error {
				s.PlayerScore6.Reset()
				if err := s.PlayerScore6.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore6\"")
			}
		case "playerScore7":
			if err := func() error {
				s.PlayerScore7.Reset()
				if err := s.PlayerScore7.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore7\"")
			}
		case "playerScore8":
			if err := func() error {
				s.PlayerScore8.Reset()
				if err := s.PlayerScore8.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore8\"")
			}
		case "playerScore9":
			if err := func() error {
				s.PlayerScore9.Reset()
				if err := s.PlayerScore9.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore9\"")
			}
		case "playerScore10":
			if err := func() error {
				s.PlayerScore10.Reset()
				if err := s.PlayerScore10.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore10\"")
			}
		case "playerScore11":
			if err := func() error {
				s.PlayerScore11.Reset()
				if err := s.PlayerScore11.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore11\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5MissionsDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5MissionsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5MissionsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5ObjectiveDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5ObjectiveDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("first")
		e.Bool(s.First)
	}
	{
		e.FieldStart("kills")
		e.Int32(s.Kills)
	}
}

var jsonFieldsNameOfMatchV5ObjectiveDto = [2]string{
	0: "first",
	1: "kills",
}

// Decode decodes MatchV5ObjectiveDto from json.
func (s *MatchV5ObjectiveDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5ObjectiveDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "first":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.First = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first\"")
			}
		case "kills":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Kills = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kills\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5ObjectiveDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchV5ObjectiveDto) {
					name = jsonFieldsNameOfMatchV5ObjectiveDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5ObjectiveDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5ObjectiveDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5ObjectivesDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5ObjectivesDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("baron")
		s.Baron.Encode(e)
	}
	{
		e.FieldStart("champion")
		s.Champion.Encode(e)
	}
	{
		e.FieldStart("dragon")
		s.Dragon.Encode(e)
	}
	{
		if s.Horde.Set {
			e.FieldStart("horde")
			s.Horde.Encode(e)
		}
	}
	{
		e.FieldStart("inhibitor")
		s.Inhibitor.Encode(e)
	}
	{
		e.FieldStart("riftHerald")
		s.RiftHerald.Encode(e)
	}
	{
		e.FieldStart("tower")
		s.Tower.Encode(e)
	}
	{
		if s.Atakhan.Set {
			e.FieldStart("atakhan")
			s.Atakhan.Encode(e)
		}
	}
}

var jsonFieldsNameOfMatchV5ObjectivesDto = [8]string{
	0: "baron",
	1: "champion",
	2: "dragon",
	3: "horde",
	4: "inhibitor",
	5: "riftHerald",
	6: "tower",
	7: "atakhan",
}

// Decode decodes MatchV5ObjectivesDto from json.
func (s *MatchV5ObjectivesDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5ObjectivesDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "baron":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Baron.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"baron\"")
			}
		case "champion":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Champion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"champion\"")
			}
		case "dragon":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Dragon.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dragon\"")
			}
		case "horde":
			if err := func() error {
				s.Horde.Reset()
				if err := s.Horde.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"horde\"")
			}
		case "inhibitor":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Inhibitor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inhibitor\"")
			}
		case "riftHerald":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.RiftHerald.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"riftHerald\"")
			}
		case "tower":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Tower.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tower\"")
			}
		case "atakhan":
			if err := func() error {
				s.Atakhan.Reset()
				if err := s.Atakhan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"atakhan\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5ObjectivesDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01110111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchV5ObjectivesDto) {
					name = jsonFieldsNameOfMatchV5ObjectivesDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5ObjectivesDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5ObjectivesDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5ParticipantDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5ParticipantDto) encodeFields(e *jx.Encoder) {
	{
		if s.AllInPings.Set {
			e.FieldStart("allInPings")
			s.AllInPings.Encode(e)
		}
	}
	{
		if s.AssistMePings.Set {
			e.FieldStart("assistMePings")
			s.AssistMePings.Encode(e)
		}
	}
	{
		e.FieldStart("assists")
		e.Int32(s.Assists)
	}
	{
		e.FieldStart("baronKills")
		e.Int32(s.BaronKills)
	}
	{
		if s.BountyLevel.Set {
			e.FieldStart("bountyLevel")
			s.BountyLevel.Encode(e)
		}
	}
	{
		e.FieldStart("champExperience")
		e.Int32(s.ChampExperience)
	}
	{
		e.FieldStart("champLevel")
		e.Int32(s.ChampLevel)
	}
	{
		e.FieldStart("championId")
		e.Int32(s.ChampionId)
	}
	{
		e.FieldStart("championName")
		e.Str(s.ChampionName)
	}
	{
		if s.CommandPings.Set {
			e.FieldStart("commandPings")
			s.CommandPings.Encode(e)
		}
	}
	{
		e.FieldStart("championTransform")
		e.Int32(s.ChampionTransform)
	}
	{
		e.FieldStart("consumablesPurchased")
		e.Int32(s.ConsumablesPurchased)
	}
	{
		if s.Challenges.Set {
			e.FieldStart("challenges")
			s.Challenges.Encode(e)
		}
	}
	{
		if s.DamageDealtToBuildings.Set {
			e.FieldStart("damageDealtToBuildings")
			s.DamageDealtToBuildings.Encode(e)
		}
	}
	{
		e.FieldStart("damageDealtToObjectives")
		e.Int32(s.DamageDealtToObjectives)
	}
	{
		e.FieldStart("damageDealtToTurrets")
		e.Int32(s.DamageDealtToTurrets)
	}
	{
		e.FieldStart("damageSelfMitigated")
		e.Int32(s.DamageSelfMitigated)
	}
	{
		e.FieldStart("deaths")
		e.Int32(s.Deaths)
	}
	{
		e.FieldStart("detectorWardsPlaced")
		e.Int32(s.DetectorWardsPlaced)
	}
	{
		e.FieldStart("doubleKills")
		e.Int32(s.DoubleKills)
	}
	{
		e.FieldStart("dragonKills")
		e.Int32(s.DragonKills)
	}
	{
		if s.EligibleForProgression.Set {
			e.FieldStart("eligibleForProgression")
			s.EligibleForProgression.Encode(e)
		}
	}
	{
		if s.EnemyMissingPings.Set {
			e.FieldStart("enemyMissingPings")
			s.EnemyMissingPings.Encode(e)
		}
	}
	{
		if s.EnemyVisionPings.Set {
			e.FieldStart("enemyVisionPings")
			s.EnemyVisionPings.Encode(e)
		}
	}
	{
		e.FieldStart("firstBloodAssist")
		e.Bool(s.FirstBloodAssist)
	}
	{
		e.FieldStart("firstBloodKill")
		e.Bool(s.FirstBloodKill)
	}
	{
		e.FieldStart("firstTowerAssist")
		e.Bool(s.FirstTowerAssist)
	}
	{
		e.FieldStart("firstTowerKill")
		e.Bool(s.FirstTowerKill)
	}
	{
		e.FieldStart("gameEndedInEarlySurrender")
		e.Bool(s.GameEndedInEarlySurrender)
	}
	{
		e.FieldStart("gameEndedInSurrender")
		e.Bool(s.GameEndedInSurrender)
	}
	{
		if s.HoldPings.Set {
			e.FieldStart("holdPings")
			s.HoldPings.Encode(e)
		}
	}
	{
		if s.GetBackPings.Set {
			e.FieldStart("getBackPings")
			s.GetBackPings.Encode(e)
		}
	}
	{
		e.FieldStart("goldEarned")
		e.Int32(s.GoldEarned)
	}
	{
		e.FieldStart("goldSpent")
		e.Int32(s.GoldSpent)
	}
	{
		e.FieldStart("individualPosition")
		e.Str(s.IndividualPosition)
	}
	{
		e.FieldStart("inhibitorKills")
		e.Int32(s.InhibitorKills)
	}
	{
		if s.InhibitorTakedowns.Set {
			e.FieldStart("inhibitorTakedowns")
			s.InhibitorTakedowns.Encode(e)
		}
	}
	{
		if s.InhibitorsLost.Set {
			e.FieldStart("inhibitorsLost")
			s.InhibitorsLost.Encode(e)
		}
	}
	{
		e.FieldStart("item0")
		e.Int32(s.Item0)
	}
	{
		e.FieldStart("item1")
		e.Int32(s.Item1)
	}
	{
		e.FieldStart("item2")
		e.Int32(s.Item2)
	}
	{
		e.FieldStart("item3")
		e.Int32(s.Item3)
	}
	{
		e.FieldStart("item4")
		e.Int32(s.Item4)
	}
	{
		e.FieldStart("item5")
		e.Int32(s.Item5)
	}
	{
		e.FieldStart("item6")
		e.Int32(s.Item6)
	}
	{
		e.FieldStart("itemsPurchased")
		e.Int32(s.ItemsPurchased)
	}
	{
		e.FieldStart("killingSprees")
		e.Int32(s.KillingSprees)
	}
	{
		e.FieldStart("kills")
		e.Int32(s.Kills)
	}
	{
		e.FieldStart("lane")
		e.Str(s.Lane)
	}
	{
		e.FieldStart("largestCriticalStrike")
		e.Int32(s.LargestCriticalStrike)
	}
	{
		e.FieldStart("largestKillingSpree")
		e.Int32(s.LargestKillingSpree)
	}
	{
		e.FieldStart("largestMultiKill")
		e.Int32(s.LargestMultiKill)
	}
	{
		e.FieldStart("longestTimeSpentLiving")
		e.Int32(s.LongestTimeSpentLiving)
	}
	{
		e.FieldStart("magicDamageDealt")
		e.Int32(s.MagicDamageDealt)
	}
	{
		e.FieldStart("magicDamageDealtToChampions")
		e.Int32(s.MagicDamageDealtToChampions)
	}
	{
		e.FieldStart("magicDamageTaken")
		e.Int32(s.MagicDamageTaken)
	}
	{
		if s.Missions.Set {
			e.FieldStart("missions")
			s.Missions.Encode(e)
		}
	}
	{
		e.FieldStart("neutralMinionsKilled")
		e.Int32(s.NeutralMinionsKilled)
	}
	{
		if s.NeedVisionPings.Set {
			e.FieldStart("needVisionPings")
			s.NeedVisionPings.Encode(e)
		}
	}
	{
		e.FieldStart("nexusKills")
		e.Int32(s.NexusKills)
	}
	{
		if s.NexusTakedowns.Set {
			e.FieldStart("nexusTakedowns")
			s.NexusTakedowns.Encode(e)
		}
	}
	{
		if s.NexusLost.Set {
			e.FieldStart("nexusLost")
			s.NexusLost.Encode(e)
		}
	}
	{
		e.FieldStart("objectivesStolen")
		e.Int32(s.ObjectivesStolen)
	}
	{
		e.FieldStart("objectivesStolenAssists")
		e.Int32(s.ObjectivesStolenAssists)
	}
	{
		if s.OnMyWayPings.Set {
			e.FieldStart("onMyWayPings")
			s.OnMyWayPings.Encode(e)
		}
	}
	{
		e.FieldStart("participantId")
		e.Int32(s.ParticipantId)
	}
	{
		if s.PlayerScore0.Set {
			e.FieldStart("playerScore0")
			s.PlayerScore0.Encode(e)
		}
	}
	{
		if s.PlayerScore1.Set {
			e.FieldStart("playerScore1")
			s.PlayerScore1.Encode(e)
		}
	}
	{
		if s.PlayerScore2.Set {
			e.FieldStart("playerScore2")
			s.PlayerScore2.Encode(e)
		}
	}
	{
		if s.PlayerScore3.Set {
			e.FieldStart("playerScore3")
			s.PlayerScore3.Encode(e)
		}
	}
	{
		if s.PlayerScore4.Set {
			e.FieldStart("playerScore4")
			s.PlayerScore4.Encode(e)
		}
	}
	{
		if s.PlayerScore5.Set {
			e.FieldStart("playerScore5")
			s.PlayerScore5.Encode(e)
		}
	}
	{
		if s.PlayerScore6.Set {
			e.FieldStart("playerScore6")
			s.PlayerScore6.Encode(e)
		}
	}
	{
		if s.PlayerScore7.Set {
			e.FieldStart("playerScore7")
			s.PlayerScore7.Encode(e)
		}
	}
	{
		if s.PlayerScore8.Set {
			e.FieldStart("playerScore8")
			s.PlayerScore8.Encode(e)
		}
	}
	{
		if s.PlayerScore9.Set {
			e.FieldStart("playerScore9")
			s.PlayerScore9.Encode(e)
		}
	}
	{
		if s.PlayerScore10.Set {
			e.FieldStart("playerScore10")
			s.PlayerScore10.Encode(e)
		}
	}
	{
		if s.PlayerScore11.Set {
			e.FieldStart("playerScore11")
			s.PlayerScore11.Encode(e)
		}
	}
	{
		e.FieldStart("pentaKills")
		e.Int32(s.PentaKills)
	}
	{
		e.FieldStart("perks")
		s.Perks.Encode(e)
	}
	{
		e.FieldStart("physicalDamageDealt")
		e.Int32(s.PhysicalDamageDealt)
	}
	{
		e.FieldStart("physicalDamageDealtToChampions")
		e.Int32(s.PhysicalDamageDealtToChampions)
	}
	{
		e.FieldStart("physicalDamageTaken")
		e.Int32(s.PhysicalDamageTaken)
	}
	{
		if s.Placement.Set {
			e.FieldStart("placement")
			s.Placement.Encode(e)
		}
	}
	{
		if s.PlayerAugment1.Set {
			e.FieldStart("playerAugment1")
			s.PlayerAugment1.Encode(e)
		}
	}
	{
		if s.PlayerAugment2.Set {
			e.FieldStart("playerAugment2")
			s.PlayerAugment2.Encode(e)
		}
	}
	{
		if s.PlayerAugment3.Set {
			e.FieldStart("playerAugment3")
			s.PlayerAugment3.Encode(e)
		}
	}
	{
		if s.PlayerAugment4.Set {
			e.FieldStart("playerAugment4")
			s.PlayerAugment4.Encode(e)
		}
	}
	{
		if s.PlayerSubteamId.Set {
			e.FieldStart("playerSubteamId")
			s.PlayerSubteamId.Encode(e)
		}
	}
	{
		if s.PushPings.Set {
			e.FieldStart("pushPings")
			s.PushPings.Encode(e)
		}
	}
	{
		e.FieldStart("profileIcon")
		e.Int32(s.ProfileIcon)
	}
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		e.FieldStart("quadraKills")
		e.Int32(s.QuadraKills)
	}
	{
		if s.RiotIdGameName.Set {
			e.FieldStart("riotIdGameName")
			s.RiotIdGameName.Encode(e)
		}
	}
	{
		if s.RiotIdTagline.Set {
			e.FieldStart("riotIdTagline")
			s.RiotIdTagline.Encode(e)
		}
	}
	{
		e.FieldStart("role")
		e.Str(s.Role)
	}
	{
		e.FieldStart("sightWardsBoughtInGame")
		e.Int32(s.SightWardsBoughtInGame)
	}
	{
		e.FieldStart("spell1Casts")
		e.Int32(s.Spell1Casts)
	}
	{
		e.FieldStart("spell2Casts")
		e.Int32(s.Spell2Casts)
	}
	{
		e.FieldStart("spell3Casts")
		e.Int32(s.Spell3Casts)
	}
	{
		e.FieldStart("spell4Casts")
		e.Int32(s.Spell4Casts)
	}
	{
		if s.SubteamPlacement.Set {
			e.FieldStart("subteamPlacement")
			s.SubteamPlacement.Encode(e)
		}
	}
	{
		e.FieldStart("summoner1Casts")
		e.Int32(s.Summoner1Casts)
	}
	{
		e.FieldStart("summoner1Id")
		e.Int32(s.Summoner1Id)
	}
	{
		e.FieldStart("summoner2Casts")
		e.Int32(s.Summoner2Casts)
	}
	{
		e.FieldStart("summoner2Id")
		e.Int32(s.Summoner2Id)
	}
	{
		e.FieldStart("summonerId")
		e.Str(s.SummonerId)
	}
	{
		e.FieldStart("summonerLevel")
		e.Int32(s.SummonerLevel)
	}
	{
		e.FieldStart("summonerName")
		e.Str(s.SummonerName)
	}
	{
		e.FieldStart("teamEarlySurrendered")
		e.Bool(s.TeamEarlySurrendered)
	}
	{
		e.FieldStart("teamId")
		e.Int32(s.TeamId)
	}
	{
		e.FieldStart("teamPosition")
		e.Str(s.TeamPosition)
	}
	{
		e.FieldStart("timeCCingOthers")
		e.Int32(s.TimeCCingOthers)
	}
	{
		e.FieldStart("timePlayed")
		e.Int32(s.TimePlayed)
	}
	{
		if s.TotalAllyJungleMinionsKilled.Set {
			e.FieldStart("totalAllyJungleMinionsKilled")
			s.TotalAllyJungleMinionsKilled.Encode(e)
		}
	}
	{
		e.FieldStart("totalDamageDealt")
		e.Int32(s.TotalDamageDealt)
	}
	{
		e.FieldStart("totalDamageDealtToChampions")
		e.Int32(s.TotalDamageDealtToChampions)
	}
	{
		e.FieldStart("totalDamageShieldedOnTeammates")
		e.Int32(s.TotalDamageShieldedOnTeammates)
	}
	{
		e.FieldStart("totalDamageTaken")
		e.Int32(s.TotalDamageTaken)
	}
	{
		if s.TotalEnemyJungleMinionsKilled.Set {
			e.FieldStart("totalEnemyJungleMinionsKilled")
			s.TotalEnemyJungleMinionsKilled.Encode(e)
		}
	}
	{
		e.FieldStart("totalHeal")
		e.Int32(s.TotalHeal)
	}
	{
		e.FieldStart("totalHealsOnTeammates")
		e.Int32(s.TotalHealsOnTeammates)
	}
	{
		e.FieldStart("totalMinionsKilled")
		e.Int32(s.TotalMinionsKilled)
	}
	{
		e.FieldStart("totalTimeCCDealt")
		e.Int32(s.TotalTimeCCDealt)
	}
	{
		e.FieldStart("totalTimeSpentDead")
		e.Int32(s.TotalTimeSpentDead)
	}
	{
		e.FieldStart("totalUnitsHealed")
		e.Int32(s.TotalUnitsHealed)
	}
	{
		e.FieldStart("tripleKills")
		e.Int32(s.TripleKills)
	}
	{
		e.FieldStart("trueDamageDealt")
		e.Int32(s.TrueDamageDealt)
	}
	{
		e.FieldStart("trueDamageDealtToChampions")
		e.Int32(s.TrueDamageDealtToChampions)
	}
	{
		e.FieldStart("trueDamageTaken")
		e.Int32(s.TrueDamageTaken)
	}
	{
		e.FieldStart("turretKills")
		e.Int32(s.TurretKills)
	}
	{
		if s.TurretTakedowns.Set {
			e.FieldStart("turretTakedowns")
			s.TurretTakedowns.Encode(e)
		}
	}
	{
		if s.TurretsLost.Set {
			e.FieldStart("turretsLost")
			s.TurretsLost.Encode(e)
		}
	}
	{
		e.FieldStart("unrealKills")
		e.Int32(s.UnrealKills)
	}
	{
		e.FieldStart("visionScore")
		e.Int32(s.VisionScore)
	}
	{
		if s.VisionClearedPings.Set {
			e.FieldStart("visionClearedPings")
			s.VisionClearedPings.Encode(e)
		}
	}
	{
		e.FieldStart("visionWardsBoughtInGame")
		e.Int32(s.VisionWardsBoughtInGame)
	}
	{
		e.FieldStart("wardsKilled")
		e.Int32(s.WardsKilled)
	}
	{
		e.FieldStart("wardsPlaced")
		e.Int32(s.WardsPlaced)
	}
	{
		e.FieldStart("win")
		e.Bool(s.Win)
	}
	{
		if s.BaitPings.Set {
			e.FieldStart("baitPings")
			s.BaitPings.Encode(e)
		}
	}
	{
		if s.DangerPings.Set {
			e.FieldStart("dangerPings")
			s.DangerPings.Encode(e)
		}
	}
	{
		if s.BasicPings.Set {
			e.FieldStart("basicPings")
			s.BasicPings.Encode(e)
		}
	}
	{
		if s.PlayerAugment5.Set {
			e.FieldStart("playerAugment5")
			s.PlayerAugment5.Encode(e)
		}
	}
	{
		if s.PlayerAugment6.Set {
			e.FieldStart("playerAugment6")
			s.PlayerAugment6.Encode(e)
		}
	}
	{
		if s.RiotIdName.Set {
			e.FieldStart("riotIdName")
			s.RiotIdName.Encode(e)
		}
	}
	{
		if s.RetreatPings.Set {
			e.FieldStart("retreatPings")
			s.RetreatPings.Encode(e)
		}
	}
	{
		if s.ChampionSkinId.Set {
			e.FieldStart("championSkinId")
			s.ChampionSkinId.Encode(e)
		}
	}
}

var jsonFieldsNameOfMatchV5ParticipantDto = [148]string{
	0:   "allInPings",
	1:   "assistMePings",
	2:   "assists",
	3:   "baronKills",
	4:   "bountyLevel",
	5:   "champExperience",
	6:   "champLevel",
	7:   "championId",
	8:   "championName",
	9:   "commandPings",
	10:  "championTransform",
	11:  "consumablesPurchased",
	12:  "challenges",
	13:  "damageDealtToBuildings",
	14:  "damageDealtToObjectives",
	15:  "damageDealtToTurrets",
	16:  "damageSelfMitigated",
	17:  "deaths",
	18:  "detectorWardsPlaced",
	19:  "doubleKills",
	20:  "dragonKills",
	21:  "eligibleForProgression",
	22:  "enemyMissingPings",
	23:  "enemyVisionPings",
	24:  "firstBloodAssist",
	25:  "firstBloodKill",
	26:  "firstTowerAssist",
	27:  "firstTowerKill",
	28:  "gameEndedInEarlySurrender",
	29:  "gameEndedInSurrender",
	30:  "holdPings",
	31:  "getBackPings",
	32:  "goldEarned",
	33:  "goldSpent",
	34:  "individualPosition",
	35:  "inhibitorKills",
	36:  "inhibitorTakedowns",
	37:  "inhibitorsLost",
	38:  "item0",
	39:  "item1",
	40:  "item2",
	41:  "item3",
	42:  "item4",
	43:  "item5",
	44:  "item6",
	45:  "itemsPurchased",
	46:  "killingSprees",
	47:  "kills",
	48:  "lane",
	49:  "largestCriticalStrike",
	50:  "largestKillingSpree",
	51:  "largestMultiKill",
	52:  "longestTimeSpentLiving",
	53:  "magicDamageDealt",
	54:  "magicDamageDealtToChampions",
	55:  "magicDamageTaken",
	56:  "missions",
	57:  "neutralMinionsKilled",
	58:  "needVisionPings",
	59:  "nexusKills",
	60:  "nexusTakedowns",
	61:  "nexusLost",
	62:  "objectivesStolen",
	63:  "objectivesStolenAssists",
	64:  "onMyWayPings",
	65:  "participantId",
	66:  "playerScore0",
	67:  "playerScore1",
	68:  "playerScore2",
	69:  "playerScore3",
	70:  "playerScore4",
	71:  "playerScore5",
	72:  "playerScore6",
	73:  "playerScore7",
	74:  "playerScore8",
	75:  "playerScore9",
	76:  "playerScore10",
	77:  "playerScore11",
	78:  "pentaKills",
	79:  "perks",
	80:  "physicalDamageDealt",
	81:  "physicalDamageDealtToChampions",
	82:  "physicalDamageTaken",
	83:  "placement",
	84:  "playerAugment1",
	85:  "playerAugment2",
	86:  "playerAugment3",
	87:  "playerAugment4",
	88:  "playerSubteamId",
	89:  "pushPings",
	90:  "profileIcon",
	91:  "puuid",
	92:  "quadraKills",
	93:  "riotIdGameName",
	94:  "riotIdTagline",
	95:  "role",
	96:  "sightWardsBoughtInGame",
	97:  "spell1Casts",
	98:  "spell2Casts",
	99:  "spell3Casts",
	100: "spell4Casts",
	101: "subteamPlacement",
	102: "summoner1Casts",
	103: "summoner1Id",
	104: "summoner2Casts",
	105: "summoner2Id",
	106: "summonerId",
	107: "summonerLevel",
	108: "summonerName",
	109: "teamEarlySurrendered",
	110: "teamId",
	111: "teamPosition",
	112: "timeCCingOthers",
	113: "timePlayed",
	114: "totalAllyJungleMinionsKilled",
	115: "totalDamageDealt",
	116: "totalDamageDealtToChampions",
	117: "totalDamageShieldedOnTeammates",
	118: "totalDamageTaken",
	119: "totalEnemyJungleMinionsKilled",
	120: "totalHeal",
	121: "totalHealsOnTeammates",
	122: "totalMinionsKilled",
	123: "totalTimeCCDealt",
	124: "totalTimeSpentDead",
	125: "totalUnitsHealed",
	126: "tripleKills",
	127: "trueDamageDealt",
	128: "trueDamageDealtToChampions",
	129: "trueDamageTaken",
	130: "turretKills",
	131: "turretTakedowns",
	132: "turretsLost",
	133: "unrealKills",
	134: "visionScore",
	135: "visionClearedPings",
	136: "visionWardsBoughtInGame",
	137: "wardsKilled",
	138: "wardsPlaced",
	139: "win",
	140: "baitPings",
	141: "dangerPings",
	142: "basicPings",
	143: "playerAugment5",
	144: "playerAugment6",
	145: "riotIdName",
	146: "retreatPings",
	147: "championSkinId",
}

// Decode decodes MatchV5ParticipantDto from json.
func (s *MatchV5ParticipantDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5ParticipantDto to nil")
	}
	var requiredBitSet [19]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allInPings":
			if err := func() error {
				s.AllInPings.Reset()
				if err := s.AllInPings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allInPings\"")
			}
		case "assistMePings":
			if err := func() error {
				s.AssistMePings.Reset()
				if err := s.AssistMePings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assistMePings\"")
			}
		case "assists":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Assists = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assists\"")
			}
		case "baronKills":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.BaronKills = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"baronKills\"")
			}
		case "bountyLevel":
			if err := func() error {
				s.BountyLevel.Reset()
				if err := s.BountyLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bountyLevel\"")
			}
		case "champExperience":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.ChampExperience = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"champExperience\"")
			}
		case "champLevel":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.ChampLevel = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"champLevel\"")
			}
		case "championId":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.ChampionId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"championId\"")
			}
		case "championName":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ChampionName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"championName\"")
			}
		case "commandPings":
			if err := func() error {
				s.CommandPings.Reset()
				if err := s.CommandPings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commandPings\"")
			}
		case "championTransform":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.ChampionTransform = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"championTransform\"")
			}
		case "consumablesPurchased":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.ConsumablesPurchased = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumablesPurchased\"")
			}
		case "challenges":
			if err := func() error {
				s.Challenges.Reset()
				if err := s.Challenges.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"challenges\"")
			}
		case "damageDealtToBuildings":
			if err := func() error {
				s.DamageDealtToBuildings.Reset()
				if err := s.DamageDealtToBuildings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damageDealtToBuildings\"")
			}
		case "damageDealtToObjectives":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.DamageDealtToObjectives = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damageDealtToObjectives\"")
			}
		case "damageDealtToTurrets":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.DamageDealtToTurrets = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damageDealtToTurrets\"")
			}
		case "damageSelfMitigated":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.DamageSelfMitigated = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damageSelfMitigated\"")
			}
		case "deaths":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Deaths = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deaths\"")
			}
		case "detectorWardsPlaced":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.DetectorWardsPlaced = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detectorWardsPlaced\"")
			}
		case "doubleKills":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.DoubleKills = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"doubleKills\"")
			}
		case "dragonKills":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.DragonKills = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dragonKills\"")
			}
		case "eligibleForProgression":
			if err := func() error {
				s.EligibleForProgression.Reset()
				if err := s.EligibleForProgression.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eligibleForProgression\"")
			}
		case "enemyMissingPings":
			if err := func() error {
				s.EnemyMissingPings.Reset()
				if err := s.EnemyMissingPings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enemyMissingPings\"")
			}
		case "enemyVisionPings":
			if err := func() error {
				s.EnemyVisionPings.Reset()
				if err := s.EnemyVisionPings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enemyVisionPings\"")
			}
		case "firstBloodAssist":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.FirstBloodAssist = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstBloodAssist\"")
			}
		case "firstBloodKill":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.FirstBloodKill = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstBloodKill\"")
			}
		case "firstTowerAssist":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.FirstTowerAssist = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstTowerAssist\"")
			}
		case "firstTowerKill":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.FirstTowerKill = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstTowerKill\"")
			}
		case "gameEndedInEarlySurrender":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.GameEndedInEarlySurrender = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameEndedInEarlySurrender\"")
			}
		case "gameEndedInSurrender":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.GameEndedInSurrender = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameEndedInSurrender\"")
			}
		case "holdPings":
			if err := func() error {
				s.HoldPings.Reset()
				if err := s.HoldPings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"holdPings\"")
			}
		case "getBackPings":
			if err := func() error {
				s.GetBackPings.Reset()
				if err := s.GetBackPings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"getBackPings\"")
			}
		case "goldEarned":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.GoldEarned = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"goldEarned\"")
			}
		case "goldSpent":
			requiredBitSet[4] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.GoldSpent = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"goldSpent\"")
			}
		case "individualPosition":
			requiredBitSet[4] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.IndividualPosition = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"individualPosition\"")
			}
		case "inhibitorKills":
			requiredBitSet[4] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.InhibitorKills = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inhibitorKills\"")
			}
		case "inhibitorTakedowns":
			if err := func() error {
				s.InhibitorTakedowns.Reset()
				if err := s.InhibitorTakedowns.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inhibitorTakedowns\"")
			}
		case "inhibitorsLost":
			if err := func() error {
				s.InhibitorsLost.Reset()
				if err := s.InhibitorsLost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inhibitorsLost\"")
			}
		case "item0":
			requiredBitSet[4] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.Item0 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item0\"")
			}
		case "item1":
			requiredBitSet[4] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.Item1 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item1\"")
			}
		case "item2":
			requiredBitSet[5] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Item2 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item2\"")
			}
		case "item3":
			requiredBitSet[5] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Item3 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item3\"")
			}
		case "item4":
			requiredBitSet[5] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Item4 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item4\"")
			}
		case "item5":
			requiredBitSet[5] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Item5 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item5\"")
			}
		case "item6":
			requiredBitSet[5] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Item6 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item6\"")
			}
		case "itemsPurchased":
			requiredBitSet[5] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.ItemsPurchased = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"itemsPurchased\"")
			}
		case "killingSprees":
			requiredBitSet[5] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.KillingSprees = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"killingSprees\"")
			}
		case "kills":
			requiredBitSet[5] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.Kills = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kills\"")
			}
		case "lane":
			requiredBitSet[6] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Lane = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lane\"")
			}
		case "largestCriticalStrike":
			requiredBitSet[6] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.LargestCriticalStrike = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"largestCriticalStrike\"")
			}
		case "largestKillingSpree":
			requiredBitSet[6] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.LargestKillingSpree = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"largestKillingSpree\"")
			}
		case "largestMultiKill":
			requiredBitSet[6] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.LargestMultiKill = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"largestMultiKill\"")
			}
		case "longestTimeSpentLiving":
			requiredBitSet[6] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.LongestTimeSpentLiving = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longestTimeSpentLiving\"")
			}
		case "magicDamageDealt":
			requiredBitSet[6] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.MagicDamageDealt = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"magicDamageDealt\"")
			}
		case "magicDamageDealtToChampions":
			requiredBitSet[6] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.MagicDamageDealtToChampions = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"magicDamageDealtToChampions\"")
			}
		case "magicDamageTaken":
			requiredBitSet[6] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.MagicDamageTaken = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"magicDamageTaken\"")
			}
		case "missions":
			if err := func() error {
				s.Missions.Reset()
				if err := s.Missions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"missions\"")
			}
		case "neutralMinionsKilled":
			requiredBitSet[7] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.NeutralMinionsKilled = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"neutralMinionsKilled\"")
			}
		case "needVisionPings":
			if err := func() error {
				s.NeedVisionPings.Reset()
				if err := s.NeedVisionPings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"needVisionPings\"")
			}
		case "nexusKills":
			requiredBitSet[7] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.NexusKills = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nexusKills\"")
			}
		case "nexusTakedowns":
			if err := func() error {
				s.NexusTakedowns.Reset()
				if err := s.NexusTakedowns.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nexusTakedowns\"")
			}
		case "nexusLost":
			if err := func() error {
				s.NexusLost.Reset()
				if err := s.NexusLost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nexusLost\"")
			}
		case "objectivesStolen":
			requiredBitSet[7] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.ObjectivesStolen = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectivesStolen\"")
			}
		case "objectivesStolenAssists":
			requiredBitSet[7] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.ObjectivesStolenAssists = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectivesStolenAssists\"")
			}
		case "onMyWayPings":
			if err := func() error {
				s.OnMyWayPings.Reset()
				if err := s.OnMyWayPings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onMyWayPings\"")
			}
		case "participantId":
			requiredBitSet[8] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.ParticipantId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participantId\"")
			}
		case "playerScore0":
			if err := func() error {
				s.PlayerScore0.Reset()
				if err := s.PlayerScore0.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore0\"")
			}
		case "playerScore1":
			if err := func() error {
				s.PlayerScore1.Reset()
				if err := s.PlayerScore1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore1\"")
			}
		case "playerScore2":
			if err := func() error {
				s.PlayerScore2.Reset()
				if err := s.PlayerScore2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore2\"")
			}
		case "playerScore3":
			if err := func() error {
				s.PlayerScore3.Reset()
				if err := s.PlayerScore3.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore3\"")
			}
		case "playerScore4":
			if err := func() error {
				s.PlayerScore4.Reset()
				if err := s.PlayerScore4.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore4\"")
			}
		case "playerScore5":
			if err := func() error {
				s.PlayerScore5.Reset()
				if err := s.PlayerScore5.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore5\"")
			}
		case "playerScore6":
			if err := func() error {
				s.PlayerScore6.Reset()
				if err := s.PlayerScore6.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore6\"")
			}
		case "playerScore7":
			if err := func() error {
				s.PlayerScore7.Reset()
				if err := s.PlayerScore7.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore7\"")
			}
		case "playerScore8":
			if err := func() error {
				s.PlayerScore8.Reset()
				if err := s.PlayerScore8.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore8\"")
			}
		case "playerScore9":
			if err := func() error {
				s.PlayerScore9.Reset()
				if err := s.PlayerScore9.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore9\"")
			}
		case "playerScore10":
			if err := func() error {
				s.PlayerScore10.Reset()
				if err := s.PlayerScore10.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore10\"")
			}
		case "playerScore11":
			if err := func() error {
				s.PlayerScore11.Reset()
				if err := s.PlayerScore11.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerScore11\"")
			}
		case "pentaKills":
			requiredBitSet[9] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.PentaKills = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pentaKills\"")
			}
		case "perks":
			requiredBitSet[9] |= 1 << 7
			if err := func() error {
				if err := s.Perks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perks\"")
			}
		case "physicalDamageDealt":
			requiredBitSet[10] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.PhysicalDamageDealt = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physicalDamageDealt\"")
			}
		case "physicalDamageDealtToChampions":
			requiredBitSet[10] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.PhysicalDamageDealtToChampions = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physicalDamageDealtToChampions\"")
			}
		case "physicalDamageTaken":
			requiredBitSet[10] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.PhysicalDamageTaken = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physicalDamageTaken\"")
			}
		case "placement":
			if err := func() error {
				s.Placement.Reset()
				if err := s.Placement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"placement\"")
			}
		case "playerAugment1":
			if err := func() error {
				s.PlayerAugment1.Reset()
				if err := s.PlayerAugment1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerAugment1\"")
			}
		case "playerAugment2":
			if err := func() error {
				s.PlayerAugment2.Reset()
				if err := s.PlayerAugment2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerAugment2\"")
			}
		case "playerAugment3":
			if err := func() error {
				s.PlayerAugment3.Reset()
				if err := s.PlayerAugment3.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerAugment3\"")
			}
		case "playerAugment4":
			if err := func() error {
				s.PlayerAugment4.Reset()
				if err := s.PlayerAugment4.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerAugment4\"")
			}
		case "playerSubteamId":
			if err := func() error {
				s.PlayerSubteamId.Reset()
				if err := s.PlayerSubteamId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerSubteamId\"")
			}
		case "pushPings":
			if err := func() error {
				s.PushPings.Reset()
				if err := s.PushPings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pushPings\"")
			}
		case "profileIcon":
			requiredBitSet[11] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.ProfileIcon = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileIcon\"")
			}
		case "puuid":
			requiredBitSet[11] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "quadraKills":
			requiredBitSet[11] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.QuadraKills = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quadraKills\"")
			}
		case "riotIdGameName":
			if err := func() error {
				s.RiotIdGameName.Reset()
				if err := s.RiotIdGameName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"riotIdGameName\"")
			}
		case "riotIdTagline":
			if err := func() error {
				s.RiotIdTagline.Reset()
				if err := s.RiotIdTagline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"riotIdTagline\"")
			}
		case "role":
			requiredBitSet[11] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Role = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "sightWardsBoughtInGame":
			requiredBitSet[12] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.SightWardsBoughtInGame = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sightWardsBoughtInGame\"")
			}
		case "spell1Casts":
			requiredBitSet[12] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Spell1Casts = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spell1Casts\"")
			}
		case "spell2Casts":
			requiredBitSet[12] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Spell2Casts = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spell2Casts\"")
			}
		case "spell3Casts":
			requiredBitSet[12] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Spell3Casts = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spell3Casts\"")
			}
		case "spell4Casts":
			requiredBitSet[12] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Spell4Casts = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spell4Casts\"")
			}
		case "subteamPlacement":
			if err := func() error {
				s.SubteamPlacement.Reset()
				if err := s.SubteamPlacement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subteamPlacement\"")
			}
		case "summoner1Casts":
			requiredBitSet[12] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.Summoner1Casts = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summoner1Casts\"")
			}
		case "summoner1Id":
			requiredBitSet[12] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.Summoner1Id = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summoner1Id\"")
			}
		case "summoner2Casts":
			requiredBitSet[13] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Summoner2Casts = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summoner2Casts\"")
			}
		case "summoner2Id":
			requiredBitSet[13] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Summoner2Id = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summoner2Id\"")
			}
		case "summonerId":
			requiredBitSet[13] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SummonerId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summonerId\"")
			}
		case "summonerLevel":
			requiredBitSet[13] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.SummonerLevel = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summonerLevel\"")
			}
		case "summonerName":
			requiredBitSet[13] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SummonerName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summonerName\"")
			}
		case "teamEarlySurrendered":
			requiredBitSet[13] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.TeamEarlySurrendered = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamEarlySurrendered\"")
			}
		case "teamId":
			requiredBitSet[13] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.TeamId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamId\"")
			}
		case "teamPosition":
			requiredBitSet[13] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.TeamPosition = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamPosition\"")
			}
		case "timeCCingOthers":
			requiredBitSet[14] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.TimeCCingOthers = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeCCingOthers\"")
			}
		case "timePlayed":
			requiredBitSet[14] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.TimePlayed = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timePlayed\"")
			}
		case "totalAllyJungleMinionsKilled":
			if err := func() error {
				s.TotalAllyJungleMinionsKilled.Reset()
				if err := s.TotalAllyJungleMinionsKilled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAllyJungleMinionsKilled\"")
			}
		case "totalDamageDealt":
			requiredBitSet[14] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.TotalDamageDealt = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalDamageDealt\"")
			}
		case "totalDamageDealtToChampions":
			requiredBitSet[14] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.TotalDamageDealtToChampions = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalDamageDealtToChampions\"")
			}
		case "totalDamageShieldedOnTeammates":
			requiredBitSet[14] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.TotalDamageShieldedOnTeammates = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalDamageShieldedOnTeammates\"")
			}
		case "totalDamageTaken":
			requiredBitSet[14] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.TotalDamageTaken = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalDamageTaken\"")
			}
		case "totalEnemyJungleMinionsKilled":
			if err := func() error {
				s.TotalEnemyJungleMinionsKilled.Reset()
				if err := s.TotalEnemyJungleMinionsKilled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalEnemyJungleMinionsKilled\"")
			}
		case "totalHeal":
			requiredBitSet[15] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.TotalHeal = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalHeal\"")
			}
		case "totalHealsOnTeammates":
			requiredBitSet[15] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.TotalHealsOnTeammates = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalHealsOnTeammates\"")
			}
		case "totalMinionsKilled":
			requiredBitSet[15] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.TotalMinionsKilled = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalMinionsKilled\"")
			}
		case "totalTimeCCDealt":
			requiredBitSet[15] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.TotalTimeCCDealt = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalTimeCCDealt\"")
			}
		case "totalTimeSpentDead":
			requiredBitSet[15] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.TotalTimeSpentDead = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalTimeSpentDead\"")
			}
		case "totalUnitsHealed":
			requiredBitSet[15] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.TotalUnitsHealed = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalUnitsHealed\"")
			}
		case "tripleKills":
			requiredBitSet[15] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.TripleKills = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tripleKills\"")
			}
		case "trueDamageDealt":
			requiredBitSet[15] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.TrueDamageDealt = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trueDamageDealt\"")
			}
		case "trueDamageDealtToChampions":
			requiredBitSet[16] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.TrueDamageDealtToChampions = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trueDamageDealtToChampions\"")
			}
		case "trueDamageTaken":
			requiredBitSet[16] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.TrueDamageTaken = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trueDamageTaken\"")
			}
		case "turretKills":
			requiredBitSet[16] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.TurretKills = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"turretKills\"")
			}
		case "turretTakedowns":
			if err := func() error {
				s.TurretTakedowns.Reset()
				if err := s.TurretTakedowns.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"turretTakedowns\"")
			}
		case "turretsLost":
			if err := func() error {
				s.TurretsLost.Reset()
				if err := s.TurretsLost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"turretsLost\"")
			}
		case "unrealKills":
			requiredBitSet[16] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.UnrealKills = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unrealKills\"")
			}
		case "visionScore":
			requiredBitSet[16] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.VisionScore = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visionScore\"")
			}
		case "visionClearedPings":
			if err := func() error {
				s.VisionClearedPings.Reset()
				if err := s.VisionClearedPings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visionClearedPings\"")
			}
		case "visionWardsBoughtInGame":
			requiredBitSet[17] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.VisionWardsBoughtInGame = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visionWardsBoughtInGame\"")
			}
		case "wardsKilled":
			requiredBitSet[17] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.WardsKilled = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wardsKilled\"")
			}
		case "wardsPlaced":
			requiredBitSet[17] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.WardsPlaced = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wardsPlaced\"")
			}
		case "win":
			requiredBitSet[17] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Win = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"win\"")
			}
		case "baitPings":
			if err := func() error {
				s.BaitPings.Reset()
				if err := s.BaitPings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"baitPings\"")
			}
		case "dangerPings":
			if err := func() error {
				s.DangerPings.Reset()
				if err := s.DangerPings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dangerPings\"")
			}
		case "basicPings":
			if err := func() error {
				s.BasicPings.Reset()
				if err := s.BasicPings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"basicPings\"")
			}
		case "playerAugment5":
			if err := func() error {
				s.PlayerAugment5.Reset()
				if err := s.PlayerAugment5.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerAugment5\"")
			}
		case "playerAugment6":
			if err := func() error {
				s.PlayerAugment6.Reset()
				if err := s.PlayerAugment6.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerAugment6\"")
			}
		case "riotIdName":
			if err := func() error {
				s.RiotIdName.Reset()
				if err := s.RiotIdName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"riotIdName\"")
			}
		case "retreatPings":
			if err := func() error {
				s.RetreatPings.Reset()
				if err := s.RetreatPings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"retreatPings\"")
			}
		case "championSkinId":
			if err := func() error {
				s.ChampionSkinId.Reset()
				if err := s.ChampionSkinId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"championSkinId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5ParticipantDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [19]uint8{
		0b11101100,
		0b11001101,
		0b00011111,
		0b00111111,
		0b11001111,
		0b11111111,
		0b11111111,
		0b11001010,
		0b00000010,
		0b11000000,
		0b00000111,
		0b10011100,
		0b11011111,
		0b11111111,
		0b01111011,
		0b11111111,
		0b01100111,
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchV5ParticipantDto) {
					name = jsonFieldsNameOfMatchV5ParticipantDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5ParticipantDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5ParticipantDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5ParticipantFrameDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5ParticipantFrameDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("championStats")
		s.ChampionStats.Encode(e)
	}
	{
		e.FieldStart("currentGold")
		e.Int32(s.CurrentGold)
	}
	{
		e.FieldStart("damageStats")
		s.DamageStats.Encode(e)
	}
	{
		e.FieldStart("goldPerSecond")
		e.Int32(s.GoldPerSecond)
	}
	{
		e.FieldStart("jungleMinionsKilled")
		e.Int32(s.JungleMinionsKilled)
	}
	{
		e.FieldStart("level")
		e.Int32(s.Level)
	}
	{
		e.FieldStart("minionsKilled")
		e.Int32(s.MinionsKilled)
	}
	{
		e.FieldStart("participantId")
		e.Int32(s.ParticipantId)
	}
	{
		e.FieldStart("position")
		s.Position.Encode(e)
	}
	{
		e.FieldStart("timeEnemySpentControlled")
		e.Int32(s.TimeEnemySpentControlled)
	}
	{
		e.FieldStart("totalGold")
		e.Int32(s.TotalGold)
	}
	{
		e.FieldStart("xp")
		e.Int32(s.Xp)
	}
}

var jsonFieldsNameOfMatchV5ParticipantFrameDto = [12]string{
	0:  "championStats",
	1:  "currentGold",
	2:  "damageStats",
	3:  "goldPerSecond",
	4:  "jungleMinionsKilled",
	5:  "level",
	6:  "minionsKilled",
	7:  "participantId",
	8:  "position",
	9:  "timeEnemySpentControlled",
	10: "totalGold",
	11: "xp",
}

// Decode decodes MatchV5ParticipantFrameDto from json.
func (s *MatchV5ParticipantFrameDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5ParticipantFrameDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "championStats":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ChampionStats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"championStats\"")
			}
		case "currentGold":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.CurrentGold = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentGold\"")
			}
		case "damageStats":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.DamageStats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damageStats\"")
			}
		case "goldPerSecond":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.GoldPerSecond = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"goldPerSecond\"")
			}
		case "jungleMinionsKilled":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.JungleMinionsKilled = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jungleMinionsKilled\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.Level = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "minionsKilled":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.MinionsKilled = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minionsKilled\"")
			}
		case "participantId":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.ParticipantId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participantId\"")
			}
		case "position":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Position.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"position\"")
			}
		case "timeEnemySpentControlled":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.TimeEnemySpentControlled = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeEnemySpentControlled\"")
			}
		case "totalGold":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.TotalGold = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalGold\"")
			}
		case "xp":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Xp = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5ParticipantFrameDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchV5ParticipantFrameDto) {
					name = jsonFieldsNameOfMatchV5ParticipantFrameDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5ParticipantFrameDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5ParticipantFrameDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5ParticipantTimeLineDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5ParticipantTimeLineDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("participantId")
		e.Int32(s.ParticipantId)
	}
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
}

var jsonFieldsNameOfMatchV5ParticipantTimeLineDto = [2]string{
	0: "participantId",
	1: "puuid",
}

// Decode decodes MatchV5ParticipantTimeLineDto from json.
func (s *MatchV5ParticipantTimeLineDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5ParticipantTimeLineDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "participantId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ParticipantId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participantId\"")
			}
		case "puuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5ParticipantTimeLineDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchV5ParticipantTimeLineDto) {
					name = jsonFieldsNameOfMatchV5ParticipantTimeLineDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5ParticipantTimeLineDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5ParticipantTimeLineDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5PerkStatsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5PerkStatsDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("defense")
		e.Int32(s.Defense)
	}
	{
		e.FieldStart("flex")
		e.Int32(s.Flex)
	}
	{
		e.FieldStart("offense")
		e.Int32(s.Offense)
	}
}

var jsonFieldsNameOfMatchV5PerkStatsDto = [3]string{
	0: "defense",
	1: "flex",
	2: "offense",
}

// Decode decodes MatchV5PerkStatsDto from json.
func (s *MatchV5PerkStatsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5PerkStatsDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "defense":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Defense = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defense\"")
			}
		case "flex":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Flex = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flex\"")
			}
		case "offense":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Offense = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offense\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5PerkStatsDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchV5PerkStatsDto) {
					name = jsonFieldsNameOfMatchV5PerkStatsDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5PerkStatsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5PerkStatsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5PerkStyleDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5PerkStyleDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("selections")
		e.ArrStart()
		for _, elem := range s.Selections {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("style")
		e.Int32(s.Style)
	}
}

var jsonFieldsNameOfMatchV5PerkStyleDto = [3]string{
	0: "description",
	1: "selections",
	2: "style",
}

// Decode decodes MatchV5PerkStyleDto from json.
func (s *MatchV5PerkStyleDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5PerkStyleDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "selections":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Selections = make([]MatchV5PerkStyleSelectionDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MatchV5PerkStyleSelectionDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Selections = append(s.Selections, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selections\"")
			}
		case "style":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Style = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"style\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5PerkStyleDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchV5PerkStyleDto) {
					name = jsonFieldsNameOfMatchV5PerkStyleDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5PerkStyleDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5PerkStyleDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5PerkStyleSelectionDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5PerkStyleSelectionDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("perk")
		e.Int32(s.Perk)
	}
	{
		e.FieldStart("var1")
		e.Int32(s.Var1)
	}
	{
		e.FieldStart("var2")
		e.Int32(s.Var2)
	}
	{
		e.FieldStart("var3")
		e.Int32(s.Var3)
	}
}

var jsonFieldsNameOfMatchV5PerkStyleSelectionDto = [4]string{
	0: "perk",
	1: "var1",
	2: "var2",
	3: "var3",
}

// Decode decodes MatchV5PerkStyleSelectionDto from json.
func (s *MatchV5PerkStyleSelectionDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5PerkStyleSelectionDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "perk":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Perk = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perk\"")
			}
		case "var1":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Var1 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"var1\"")
			}
		case "var2":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Var2 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"var2\"")
			}
		case "var3":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Var3 = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"var3\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5PerkStyleSelectionDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchV5PerkStyleSelectionDto) {
					name = jsonFieldsNameOfMatchV5PerkStyleSelectionDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5PerkStyleSelectionDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5PerkStyleSelectionDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5PerksDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5PerksDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("statPerks")
		s.StatPerks.Encode(e)
	}
	{
		e.FieldStart("styles")
		e.ArrStart()
		for _, elem := range s.Styles {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfMatchV5PerksDto = [2]string{
	0: "statPerks",
	1: "styles",
}

// Decode decodes MatchV5PerksDto from json.
func (s *MatchV5PerksDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5PerksDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "statPerks":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.StatPerks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statPerks\"")
			}
		case "styles":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Styles = make([]MatchV5PerkStyleDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MatchV5PerkStyleDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Styles = append(s.Styles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"styles\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5PerksDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchV5PerksDto) {
					name = jsonFieldsNameOfMatchV5PerksDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5PerksDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5PerksDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5PositionDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5PositionDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("x")
		e.Int32(s.X)
	}
	{
		e.FieldStart("y")
		e.Int32(s.Y)
	}
}

var jsonFieldsNameOfMatchV5PositionDto = [2]string{
	0: "x",
	1: "y",
}

// Decode decodes MatchV5PositionDto from json.
func (s *MatchV5PositionDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5PositionDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.X = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Y = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5PositionDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchV5PositionDto) {
					name = jsonFieldsNameOfMatchV5PositionDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5PositionDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5PositionDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5TeamDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5TeamDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("bans")
		e.ArrStart()
		for _, elem := range s.Bans {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("objectives")
		s.Objectives.Encode(e)
	}
	{
		e.FieldStart("teamId")
		e.Int32(s.TeamId)
	}
	{
		e.FieldStart("win")
		e.Bool(s.Win)
	}
	{
		if s.Feats.Set {
			e.FieldStart("feats")
			s.Feats.Encode(e)
		}
	}
}

var jsonFieldsNameOfMatchV5TeamDto = [5]string{
	0: "bans",
	1: "objectives",
	2: "teamId",
	3: "win",
	4: "feats",
}

// Decode decodes MatchV5TeamDto from json.
func (s *MatchV5TeamDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5TeamDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bans":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Bans = make([]MatchV5BanDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MatchV5BanDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Bans = append(s.Bans, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bans\"")
			}
		case "objectives":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Objectives.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectives\"")
			}
		case "teamId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.TeamId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamId\"")
			}
		case "win":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Win = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"win\"")
			}
		case "feats":
			if err := func() error {
				s.Feats.Reset()
				if err := s.Feats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5TeamDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchV5TeamDto) {
					name = jsonFieldsNameOfMatchV5TeamDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5TeamDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5TeamDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchV5TimelineDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchV5TimelineDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		e.FieldStart("info")
		s.Info.Encode(e)
	}
}

var jsonFieldsNameOfMatchV5TimelineDto = [2]string{
	0: "metadata",
	1: "info",
}

// Decode decodes MatchV5TimelineDto from json.
func (s *MatchV5TimelineDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchV5TimelineDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "info":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchV5TimelineDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchV5TimelineDto) {
					name = jsonFieldsNameOfMatchV5TimelineDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchV5TimelineDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchV5TimelineDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChampionMasteryV4RewardConfigDto as json.
func (o OptChampionMasteryV4RewardConfigDto) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChampionMasteryV4RewardConfigDto from json.
func (o *OptChampionMasteryV4RewardConfigDto) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChampionMasteryV4RewardConfigDto to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChampionMasteryV4RewardConfigDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChampionMasteryV4RewardConfigDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LeagueExpV4MiniSeriesDTO as json.
func (o OptLeagueExpV4MiniSeriesDTO) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LeagueExpV4MiniSeriesDTO from json.
func (o *OptLeagueExpV4MiniSeriesDTO) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLeagueExpV4MiniSeriesDTO to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLeagueExpV4MiniSeriesDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLeagueExpV4MiniSeriesDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LeagueV4MiniSeriesDTO as json.
func (o OptLeagueV4MiniSeriesDTO) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LeagueV4MiniSeriesDTO from json.
func (o *OptLeagueV4MiniSeriesDTO) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLeagueV4MiniSeriesDTO to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLeagueV4MiniSeriesDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLeagueV4MiniSeriesDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LolChallengesV1ChallengeConfigInfoDtoTracking as json.
func (o OptLolChallengesV1ChallengeConfigInfoDtoTracking) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes LolChallengesV1ChallengeConfigInfoDtoTracking from json.
func (o *OptLolChallengesV1ChallengeConfigInfoDtoTracking) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLolChallengesV1ChallengeConfigInfoDtoTracking to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLolChallengesV1ChallengeConfigInfoDtoTracking) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLolChallengesV1ChallengeConfigInfoDtoTracking) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LolStatusV4StatusDtoIncidentSeverity as json.
func (o OptLolStatusV4StatusDtoIncidentSeverity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes LolStatusV4StatusDtoIncidentSeverity from json.
func (o *OptLolStatusV4StatusDtoIncidentSeverity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLolStatusV4StatusDtoIncidentSeverity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLolStatusV4StatusDtoIncidentSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLolStatusV4StatusDtoIncidentSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LolStatusV4StatusDtoMaintenanceStatus as json.
func (o OptLolStatusV4StatusDtoMaintenanceStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes LolStatusV4StatusDtoMaintenanceStatus from json.
func (o *OptLolStatusV4StatusDtoMaintenanceStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLolStatusV4StatusDtoMaintenanceStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLolStatusV4StatusDtoMaintenanceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLolStatusV4StatusDtoMaintenanceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MatchV5ChallengesDto as json.
func (o OptMatchV5ChallengesDto) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MatchV5ChallengesDto from json.
func (o *OptMatchV5ChallengesDto) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMatchV5ChallengesDto to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMatchV5ChallengesDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMatchV5ChallengesDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MatchV5ChallengesDtoFasterSupportQuestCompletion as json.
func (o OptMatchV5ChallengesDtoFasterSupportQuestCompletion) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes MatchV5ChallengesDtoFasterSupportQuestCompletion from json.
func (o *OptMatchV5ChallengesDtoFasterSupportQuestCompletion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMatchV5ChallengesDtoFasterSupportQuestCompletion to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMatchV5ChallengesDtoFasterSupportQuestCompletion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMatchV5ChallengesDtoFasterSupportQuestCompletion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MatchV5ChallengesDtoHadAfkTeammate as json.
func (o OptMatchV5ChallengesDtoHadAfkTeammate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes MatchV5ChallengesDtoHadAfkTeammate from json.
func (o *OptMatchV5ChallengesDtoHadAfkTeammate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMatchV5ChallengesDtoHadAfkTeammate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMatchV5ChallengesDtoHadAfkTeammate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMatchV5ChallengesDtoHadAfkTeammate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MatchV5ChallengesDtoHighestCrowdControlScore as json.
func (o OptMatchV5ChallengesDtoHighestCrowdControlScore) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes MatchV5ChallengesDtoHighestCrowdControlScore from json.
func (o *OptMatchV5ChallengesDtoHighestCrowdControlScore) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMatchV5ChallengesDtoHighestCrowdControlScore to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMatchV5ChallengesDtoHighestCrowdControlScore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMatchV5ChallengesDtoHighestCrowdControlScore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MatchV5ChallengesDtoHighestWardKills as json.
func (o OptMatchV5ChallengesDtoHighestWardKills) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes MatchV5ChallengesDtoHighestWardKills from json.
func (o *OptMatchV5ChallengesDtoHighestWardKills) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMatchV5ChallengesDtoHighestWardKills to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMatchV5ChallengesDtoHighestWardKills) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMatchV5ChallengesDtoHighestWardKills) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MatchV5ChallengesDtoLaningPhaseGoldExpAdvantage as json.
func (o OptMatchV5ChallengesDtoLaningPhaseGoldExpAdvantage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes MatchV5ChallengesDtoLaningPhaseGoldExpAdvantage from json.
func (o *OptMatchV5ChallengesDtoLaningPhaseGoldExpAdvantage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMatchV5ChallengesDtoLaningPhaseGoldExpAdvantage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMatchV5ChallengesDtoLaningPhaseGoldExpAdvantage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMatchV5ChallengesDtoLaningPhaseGoldExpAdvantage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MatchV5ChallengesDtoPlayedChampSelectPosition as json.
func (o OptMatchV5ChallengesDtoPlayedChampSelectPosition) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes MatchV5ChallengesDtoPlayedChampSelectPosition from json.
func (o *OptMatchV5ChallengesDtoPlayedChampSelectPosition) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMatchV5ChallengesDtoPlayedChampSelectPosition to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMatchV5ChallengesDtoPlayedChampSelectPosition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMatchV5ChallengesDtoPlayedChampSelectPosition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MatchV5FeatDto as json.
func (o OptMatchV5FeatDto) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MatchV5FeatDto from json.
func (o *OptMatchV5FeatDto) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMatchV5FeatDto to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMatchV5FeatDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMatchV5FeatDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MatchV5FeatsDto as json.
func (o OptMatchV5FeatsDto) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MatchV5FeatsDto from json.
func (o *OptMatchV5FeatsDto) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMatchV5FeatsDto to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMatchV5FeatsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMatchV5FeatsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MatchV5FramesTimeLineDtoParticipantFrames as json.
func (o OptMatchV5FramesTimeLineDtoParticipantFrames) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MatchV5FramesTimeLineDtoParticipantFrames from json.
func (o *OptMatchV5FramesTimeLineDtoParticipantFrames) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMatchV5FramesTimeLineDtoParticipantFrames to nil")
	}
	o.Set = true
	o.Value = make(MatchV5FramesTimeLineDtoParticipantFrames)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMatchV5FramesTimeLineDtoParticipantFrames) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMatchV5FramesTimeLineDtoParticipantFrames) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MatchV5MissionsDto as json.
func (o OptMatchV5MissionsDto) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MatchV5MissionsDto from json.
func (o *OptMatchV5MissionsDto) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMatchV5MissionsDto to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMatchV5MissionsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMatchV5MissionsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MatchV5ObjectiveDto as json.
func (o OptMatchV5ObjectiveDto) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MatchV5ObjectiveDto from json.
func (o *OptMatchV5ObjectiveDto) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMatchV5ObjectiveDto to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMatchV5ObjectiveDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMatchV5ObjectiveDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MatchV5PositionDto as json.
func (o OptMatchV5PositionDto) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MatchV5PositionDto from json.
func (o *OptMatchV5PositionDto) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMatchV5PositionDto to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMatchV5PositionDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMatchV5PositionDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpectatorTftV5Perks as json.
func (o OptSpectatorTftV5Perks) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpectatorTftV5Perks from json.
func (o *OptSpectatorTftV5Perks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpectatorTftV5Perks to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpectatorTftV5Perks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpectatorTftV5Perks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpectatorV5Perks as json.
func (o OptSpectatorV5Perks) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpectatorV5Perks from json.
func (o *OptSpectatorV5Perks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpectatorV5Perks to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpectatorV5Perks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpectatorV5Perks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TftLeagueV1LeagueEntryDTORatedTier as json.
func (o OptTftLeagueV1LeagueEntryDTORatedTier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TftLeagueV1LeagueEntryDTORatedTier from json.
func (o *OptTftLeagueV1LeagueEntryDTORatedTier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTftLeagueV1LeagueEntryDTORatedTier to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTftLeagueV1LeagueEntryDTORatedTier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTftLeagueV1LeagueEntryDTORatedTier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TftLeagueV1MiniSeriesDTO as json.
func (o OptTftLeagueV1MiniSeriesDTO) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TftLeagueV1MiniSeriesDTO from json.
func (o *OptTftLeagueV1MiniSeriesDTO) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTftLeagueV1MiniSeriesDTO to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTftLeagueV1MiniSeriesDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTftLeagueV1MiniSeriesDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TftMatchV1ParticipantDtoSkillTree as json.
func (o OptTftMatchV1ParticipantDtoSkillTree) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TftMatchV1ParticipantDtoSkillTree from json.
func (o *OptTftMatchV1ParticipantDtoSkillTree) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTftMatchV1ParticipantDtoSkillTree to nil")
	}
	o.Set = true
	o.Value = make(TftMatchV1ParticipantDtoSkillTree)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTftMatchV1ParticipantDtoSkillTree) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTftMatchV1ParticipantDtoSkillTree) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TftMatchV1ParticipantMissionsDto as json.
func (o OptTftMatchV1ParticipantMissionsDto) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TftMatchV1ParticipantMissionsDto from json.
func (o *OptTftMatchV1ParticipantMissionsDto) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTftMatchV1ParticipantMissionsDto to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTftMatchV1ParticipantMissionsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTftMatchV1ParticipantMissionsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TournamentV5TournamentCodeUpdateParametersV5 as json.
func (o OptTournamentV5TournamentCodeUpdateParametersV5) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TournamentV5TournamentCodeUpdateParametersV5 from json.
func (o *OptTournamentV5TournamentCodeUpdateParametersV5) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTournamentV5TournamentCodeUpdateParametersV5 to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTournamentV5TournamentCodeUpdateParametersV5) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTournamentV5TournamentCodeUpdateParametersV5) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValConsoleMatchV1AbilityCastsDto as json.
func (o OptValConsoleMatchV1AbilityCastsDto) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ValConsoleMatchV1AbilityCastsDto from json.
func (o *OptValConsoleMatchV1AbilityCastsDto) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptValConsoleMatchV1AbilityCastsDto to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptValConsoleMatchV1AbilityCastsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptValConsoleMatchV1AbilityCastsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValConsoleMatchV1PlayerStatsDto as json.
func (o OptValConsoleMatchV1PlayerStatsDto) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ValConsoleMatchV1PlayerStatsDto from json.
func (o *OptValConsoleMatchV1PlayerStatsDto) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptValConsoleMatchV1PlayerStatsDto to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptValConsoleMatchV1PlayerStatsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptValConsoleMatchV1PlayerStatsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValContentV1LocalizedNamesDto as json.
func (o OptValContentV1LocalizedNamesDto) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ValContentV1LocalizedNamesDto from json.
func (o *OptValContentV1LocalizedNamesDto) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptValContentV1LocalizedNamesDto to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptValContentV1LocalizedNamesDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptValContentV1LocalizedNamesDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValMatchV1AbilityCastsDto as json.
func (o OptValMatchV1AbilityCastsDto) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ValMatchV1AbilityCastsDto from json.
func (o *OptValMatchV1AbilityCastsDto) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptValMatchV1AbilityCastsDto to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptValMatchV1AbilityCastsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptValMatchV1AbilityCastsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValMatchV1PlayerStatsDto as json.
func (o OptValMatchV1PlayerStatsDto) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ValMatchV1PlayerStatsDto from json.
func (o *OptValMatchV1PlayerStatsDto) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptValMatchV1PlayerStatsDto to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptValMatchV1PlayerStatsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptValMatchV1PlayerStatsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValRankedV1LeaderboardDtoTierDetails as json.
func (o OptValRankedV1LeaderboardDtoTierDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ValRankedV1LeaderboardDtoTierDetails from json.
func (o *OptValRankedV1LeaderboardDtoTierDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptValRankedV1LeaderboardDtoTierDetails to nil")
	}
	o.Set = true
	o.Value = make(ValRankedV1LeaderboardDtoTierDetails)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptValRankedV1LeaderboardDtoTierDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptValRankedV1LeaderboardDtoTierDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpectatorTftV5BannedChampion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpectatorTftV5BannedChampion) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("pickTurn")
		e.Int32(s.PickTurn)
	}
	{
		e.FieldStart("championId")
		e.Int64(s.ChampionId)
	}
	{
		e.FieldStart("teamId")
		e.Int64(s.TeamId)
	}
}

var jsonFieldsNameOfSpectatorTftV5BannedChampion = [3]string{
	0: "pickTurn",
	1: "championId",
	2: "teamId",
}

// Decode decodes SpectatorTftV5BannedChampion from json.
func (s *SpectatorTftV5BannedChampion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpectatorTftV5BannedChampion to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pickTurn":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.PickTurn = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pickTurn\"")
			}
		case "championId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.ChampionId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"championId\"")
			}
		case "teamId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.TeamId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpectatorTftV5BannedChampion")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpectatorTftV5BannedChampion) {
					name = jsonFieldsNameOfSpectatorTftV5BannedChampion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpectatorTftV5BannedChampion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpectatorTftV5BannedChampion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpectatorTftV5CurrentGameInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpectatorTftV5CurrentGameInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("gameId")
		e.Int64(s.GameId)
	}
	{
		e.FieldStart("gameType")
		e.Str(s.GameType)
	}
	{
		e.FieldStart("gameStartTime")
		e.Int64(s.GameStartTime)
	}
	{
		e.FieldStart("mapId")
		e.Int64(s.MapId)
	}
	{
		e.FieldStart("gameLength")
		e.Int64(s.GameLength)
	}
	{
		e.FieldStart("platformId")
		e.Str(s.PlatformId)
	}
	{
		e.FieldStart("gameMode")
		e.Str(s.GameMode)
	}
	{
		e.FieldStart("bannedChampions")
		e.ArrStart()
		for _, elem := range s.BannedChampions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.GameQueueConfigId.Set {
			e.FieldStart("gameQueueConfigId")
			s.GameQueueConfigId.Encode(e)
		}
	}
	{
		e.FieldStart("observers")
		s.Observers.Encode(e)
	}
	{
		e.FieldStart("participants")
		e.ArrStart()
		for _, elem := range s.Participants {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSpectatorTftV5CurrentGameInfo = [11]string{
	0:  "gameId",
	1:  "gameType",
	2:  "gameStartTime",
	3:  "mapId",
	4:  "gameLength",
	5:  "platformId",
	6:  "gameMode",
	7:  "bannedChampions",
	8:  "gameQueueConfigId",
	9:  "observers",
	10: "participants",
}

// Decode decodes SpectatorTftV5CurrentGameInfo from json.
func (s *SpectatorTftV5CurrentGameInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpectatorTftV5CurrentGameInfo to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "gameId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.GameId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameId\"")
			}
		case "gameType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GameType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameType\"")
			}
		case "gameStartTime":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.GameStartTime = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameStartTime\"")
			}
		case "mapId":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int64()
				s.MapId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mapId\"")
			}
		case "gameLength":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.GameLength = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameLength\"")
			}
		case "platformId":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.PlatformId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platformId\"")
			}
		case "gameMode":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.GameMode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameMode\"")
			}
		case "bannedChampions":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.BannedChampions = make([]SpectatorTftV5BannedChampion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SpectatorTftV5BannedChampion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BannedChampions = append(s.BannedChampions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bannedChampions\"")
			}
		case "gameQueueConfigId":
			if err := func() error {
				s.GameQueueConfigId.Reset()
				if err := s.GameQueueConfigId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameQueueConfigId\"")
			}
		case "observers":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Observers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observers\"")
			}
		case "participants":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				s.Participants = make([]SpectatorTftV5CurrentGameParticipant, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SpectatorTftV5CurrentGameParticipant
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Participants = append(s.Participants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participants\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpectatorTftV5CurrentGameInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpectatorTftV5CurrentGameInfo) {
					name = jsonFieldsNameOfSpectatorTftV5CurrentGameInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpectatorTftV5CurrentGameInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpectatorTftV5CurrentGameInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpectatorTftV5CurrentGameParticipant) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpectatorTftV5CurrentGameParticipant) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("championId")
		e.Int64(s.ChampionId)
	}
	{
		if s.Perks.Set {
			e.FieldStart("perks")
			s.Perks.Encode(e)
		}
	}
	{
		e.FieldStart("profileIconId")
		e.Int64(s.ProfileIconId)
	}
	{
		e.FieldStart("teamId")
		e.Int64(s.TeamId)
	}
	{
		if s.Puuid.Set {
			e.FieldStart("puuid")
			s.Puuid.Encode(e)
		}
	}
	{
		e.FieldStart("spell1Id")
		e.Int64(s.Spell1Id)
	}
	{
		e.FieldStart("spell2Id")
		e.Int64(s.Spell2Id)
	}
	{
		e.FieldStart("gameCustomizationObjects")
		e.ArrStart()
		for _, elem := range s.GameCustomizationObjects {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.RiotId.Set {
			e.FieldStart("riotId")
			s.RiotId.Encode(e)
		}
	}
}

var jsonFieldsNameOfSpectatorTftV5CurrentGameParticipant = [9]string{
	0: "championId",
	1: "perks",
	2: "profileIconId",
	3: "teamId",
	4: "puuid",
	5: "spell1Id",
	6: "spell2Id",
	7: "gameCustomizationObjects",
	8: "riotId",
}

// Decode decodes SpectatorTftV5CurrentGameParticipant from json.
func (s *SpectatorTftV5CurrentGameParticipant) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpectatorTftV5CurrentGameParticipant to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "championId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ChampionId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"championId\"")
			}
		case "perks":
			if err := func() error {
				s.Perks.Reset()
				if err := s.Perks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perks\"")
			}
		case "profileIconId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.ProfileIconId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileIconId\"")
			}
		case "teamId":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int64()
				s.TeamId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamId\"")
			}
		case "puuid":
			if err := func() error {
				s.Puuid.Reset()
				if err := s.Puuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "spell1Id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.Spell1Id = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spell1Id\"")
			}
		case "spell2Id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int64()
				s.Spell2Id = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spell2Id\"")
			}
		case "gameCustomizationObjects":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.GameCustomizationObjects = make([]SpectatorTftV5GameCustomizationObject, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SpectatorTftV5GameCustomizationObject
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.GameCustomizationObjects = append(s.GameCustomizationObjects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameCustomizationObjects\"")
			}
		case "riotId":
			if err := func() error {
				s.RiotId.Reset()
				if err := s.RiotId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"riotId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpectatorTftV5CurrentGameParticipant")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11101101,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpectatorTftV5CurrentGameParticipant) {
					name = jsonFieldsNameOfSpectatorTftV5CurrentGameParticipant[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpectatorTftV5CurrentGameParticipant) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpectatorTftV5CurrentGameParticipant) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpectatorTftV5FeaturedGameInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpectatorTftV5FeaturedGameInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("gameMode")
		s.GameMode.Encode(e)
	}
	{
		e.FieldStart("gameLength")
		e.Int64(s.GameLength)
	}
	{
		e.FieldStart("mapId")
		e.Int64(s.MapId)
	}
	{
		e.FieldStart("gameType")
		s.GameType.Encode(e)
	}
	{
		e.FieldStart("bannedChampions")
		e.ArrStart()
		for _, elem := range s.BannedChampions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("gameId")
		e.Int64(s.GameId)
	}
	{
		e.FieldStart("observers")
		s.Observers.Encode(e)
	}
	{
		e.FieldStart("gameQueueConfigId")
		e.Int64(s.GameQueueConfigId)
	}
	{
		e.FieldStart("participants")
		e.ArrStart()
		for _, elem := range s.Participants {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("platformId")
		e.Str(s.PlatformId)
	}
}

var jsonFieldsNameOfSpectatorTftV5FeaturedGameInfo = [10]string{
	0: "gameMode",
	1: "gameLength",
	2: "mapId",
	3: "gameType",
	4: "bannedChampions",
	5: "gameId",
	6: "observers",
	7: "gameQueueConfigId",
	8: "participants",
	9: "platformId",
}

// Decode decodes SpectatorTftV5FeaturedGameInfo from json.
func (s *SpectatorTftV5FeaturedGameInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpectatorTftV5FeaturedGameInfo to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "gameMode":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.GameMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameMode\"")
			}
		case "gameLength":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.GameLength = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameLength\"")
			}
		case "mapId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.MapId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mapId\"")
			}
		case "gameType":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.GameType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameType\"")
			}
		case "bannedChampions":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.BannedChampions = make([]SpectatorTftV5BannedChampion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SpectatorTftV5BannedChampion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BannedChampions = append(s.BannedChampions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bannedChampions\"")
			}
		case "gameId":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.GameId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameId\"")
			}
		case "observers":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Observers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observers\"")
			}
		case "gameQueueConfigId":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int64()
				s.GameQueueConfigId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameQueueConfigId\"")
			}
		case "participants":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.Participants = make([]SpectatorTftV5Participant, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SpectatorTftV5Participant
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Participants = append(s.Participants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participants\"")
			}
		case "platformId":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PlatformId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platformId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpectatorTftV5FeaturedGameInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpectatorTftV5FeaturedGameInfo) {
					name = jsonFieldsNameOfSpectatorTftV5FeaturedGameInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpectatorTftV5FeaturedGameInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpectatorTftV5FeaturedGameInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpectatorTftV5FeaturedGameInfoGameMode as json.
func (s SpectatorTftV5FeaturedGameInfoGameMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpectatorTftV5FeaturedGameInfoGameMode from json.
func (s *SpectatorTftV5FeaturedGameInfoGameMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpectatorTftV5FeaturedGameInfoGameMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpectatorTftV5FeaturedGameInfoGameMode(v) {
	case SpectatorTftV5FeaturedGameInfoGameModeTFT:
		*s = SpectatorTftV5FeaturedGameInfoGameModeTFT
	default:
		*s = SpectatorTftV5FeaturedGameInfoGameMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpectatorTftV5FeaturedGameInfoGameMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpectatorTftV5FeaturedGameInfoGameMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpectatorTftV5FeaturedGameInfoGameType as json.
func (s SpectatorTftV5FeaturedGameInfoGameType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpectatorTftV5FeaturedGameInfoGameType from json.
func (s *SpectatorTftV5FeaturedGameInfoGameType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpectatorTftV5FeaturedGameInfoGameType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpectatorTftV5FeaturedGameInfoGameType(v) {
	case SpectatorTftV5FeaturedGameInfoGameTypeMATCHED:
		*s = SpectatorTftV5FeaturedGameInfoGameTypeMATCHED
	default:
		*s = SpectatorTftV5FeaturedGameInfoGameType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpectatorTftV5FeaturedGameInfoGameType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpectatorTftV5FeaturedGameInfoGameType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpectatorTftV5FeaturedGames) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpectatorTftV5FeaturedGames) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("gameList")
		e.ArrStart()
		for _, elem := range s.GameList {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.ClientRefreshInterval.Set {
			e.FieldStart("clientRefreshInterval")
			s.ClientRefreshInterval.Encode(e)
		}
	}
}

var jsonFieldsNameOfSpectatorTftV5FeaturedGames = [2]string{
	0: "gameList",
	1: "clientRefreshInterval",
}

// Decode decodes SpectatorTftV5FeaturedGames from json.
func (s *SpectatorTftV5FeaturedGames) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpectatorTftV5FeaturedGames to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "gameList":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.GameList = make([]SpectatorTftV5FeaturedGameInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SpectatorTftV5FeaturedGameInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.GameList = append(s.GameList, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameList\"")
			}
		case "clientRefreshInterval":
			if err := func() error {
				s.ClientRefreshInterval.Reset()
				if err := s.ClientRefreshInterval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientRefreshInterval\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpectatorTftV5FeaturedGames")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpectatorTftV5FeaturedGames) {
					name = jsonFieldsNameOfSpectatorTftV5FeaturedGames[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpectatorTftV5FeaturedGames) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpectatorTftV5FeaturedGames) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpectatorTftV5GameCustomizationObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpectatorTftV5GameCustomizationObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("category")
		e.Str(s.Category)
	}
	{
		e.FieldStart("content")
		e.Str(s.Content)
	}
}

var jsonFieldsNameOfSpectatorTftV5GameCustomizationObject = [2]string{
	0: "category",
	1: "content",
}

// Decode decodes SpectatorTftV5GameCustomizationObject from json.
func (s *SpectatorTftV5GameCustomizationObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpectatorTftV5GameCustomizationObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "category":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Category = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpectatorTftV5GameCustomizationObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpectatorTftV5GameCustomizationObject) {
					name = jsonFieldsNameOfSpectatorTftV5GameCustomizationObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpectatorTftV5GameCustomizationObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpectatorTftV5GameCustomizationObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpectatorTftV5Observer) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpectatorTftV5Observer) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("encryptionKey")
		e.Str(s.EncryptionKey)
	}
}

var jsonFieldsNameOfSpectatorTftV5Observer = [1]string{
	0: "encryptionKey",
}

// Decode decodes SpectatorTftV5Observer from json.
func (s *SpectatorTftV5Observer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpectatorTftV5Observer to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "encryptionKey":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EncryptionKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encryptionKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpectatorTftV5Observer")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpectatorTftV5Observer) {
					name = jsonFieldsNameOfSpectatorTftV5Observer[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpectatorTftV5Observer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpectatorTftV5Observer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpectatorTftV5Participant) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpectatorTftV5Participant) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("spell2Id")
		e.Int64(s.Spell2Id)
	}
	{
		e.FieldStart("profileIconId")
		e.Int64(s.ProfileIconId)
	}
	{
		if s.Puuid.Set {
			e.FieldStart("puuid")
			s.Puuid.Encode(e)
		}
	}
	{
		e.FieldStart("championId")
		e.Int64(s.ChampionId)
	}
	{
		e.FieldStart("teamId")
		e.Int64(s.TeamId)
	}
	{
		e.FieldStart("spell1Id")
		e.Int64(s.Spell1Id)
	}
	{
		if s.RiotId.Set {
			e.FieldStart("riotId")
			s.RiotId.Encode(e)
		}
	}
}

var jsonFieldsNameOfSpectatorTftV5Participant = [7]string{
	0: "spell2Id",
	1: "profileIconId",
	2: "puuid",
	3: "championId",
	4: "teamId",
	5: "spell1Id",
	6: "riotId",
}

// Decode decodes SpectatorTftV5Participant from json.
func (s *SpectatorTftV5Participant) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpectatorTftV5Participant to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "spell2Id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.Spell2Id = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spell2Id\"")
			}
		case "profileIconId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.ProfileIconId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileIconId\"")
			}
		case "puuid":
			if err := func() error {
				s.Puuid.Reset()
				if err := s.Puuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "championId":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int64()
				s.ChampionId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"championId\"")
			}
		case "teamId":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.TeamId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamId\"")
			}
		case "spell1Id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.Spell1Id = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spell1Id\"")
			}
		case "riotId":
			if err := func() error {
				s.RiotId.Reset()
				if err := s.RiotId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"riotId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpectatorTftV5Participant")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpectatorTftV5Participant) {
					name = jsonFieldsNameOfSpectatorTftV5Participant[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpectatorTftV5Participant) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpectatorTftV5Participant) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpectatorTftV5Perks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpectatorTftV5Perks) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("perkIds")
		e.ArrStart()
		for _, elem := range s.PerkIds {
			e.Int64(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("perkStyle")
		e.Int64(s.PerkStyle)
	}
	{
		e.FieldStart("perkSubStyle")
		e.Int64(s.PerkSubStyle)
	}
}

var jsonFieldsNameOfSpectatorTftV5Perks = [3]string{
	0: "perkIds",
	1: "perkStyle",
	2: "perkSubStyle",
}

// Decode decodes SpectatorTftV5Perks from json.
func (s *SpectatorTftV5Perks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpectatorTftV5Perks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "perkIds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.PerkIds = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int64
					v, err := d.Int64()
					elem = int64(v)
					if err != nil {
						return err
					}
					s.PerkIds = append(s.PerkIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perkIds\"")
			}
		case "perkStyle":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.PerkStyle = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perkStyle\"")
			}
		case "perkSubStyle":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.PerkSubStyle = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perkSubStyle\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpectatorTftV5Perks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpectatorTftV5Perks) {
					name = jsonFieldsNameOfSpectatorTftV5Perks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpectatorTftV5Perks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpectatorTftV5Perks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpectatorV5BannedChampion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpectatorV5BannedChampion) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("pickTurn")
		e.Int32(s.PickTurn)
	}
	{
		e.FieldStart("championId")
		e.Int64(s.ChampionId)
	}
	{
		e.FieldStart("teamId")
		e.Int64(s.TeamId)
	}
}

var jsonFieldsNameOfSpectatorV5BannedChampion = [3]string{
	0: "pickTurn",
	1: "championId",
	2: "teamId",
}

// Decode decodes SpectatorV5BannedChampion from json.
func (s *SpectatorV5BannedChampion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpectatorV5BannedChampion to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pickTurn":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.PickTurn = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pickTurn\"")
			}
		case "championId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.ChampionId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"championId\"")
			}
		case "teamId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.TeamId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpectatorV5BannedChampion")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpectatorV5BannedChampion) {
					name = jsonFieldsNameOfSpectatorV5BannedChampion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpectatorV5BannedChampion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpectatorV5BannedChampion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpectatorV5CurrentGameInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpectatorV5CurrentGameInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("gameId")
		e.Int64(s.GameId)
	}
	{
		e.FieldStart("gameType")
		e.Str(s.GameType)
	}
	{
		e.FieldStart("gameStartTime")
		e.Int64(s.GameStartTime)
	}
	{
		e.FieldStart("mapId")
		e.Int64(s.MapId)
	}
	{
		e.FieldStart("gameLength")
		e.Int64(s.GameLength)
	}
	{
		e.FieldStart("platformId")
		e.Str(s.PlatformId)
	}
	{
		e.FieldStart("gameMode")
		e.Str(s.GameMode)
	}
	{
		e.FieldStart("bannedChampions")
		e.ArrStart()
		for _, elem := range s.BannedChampions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.GameQueueConfigId.Set {
			e.FieldStart("gameQueueConfigId")
			s.GameQueueConfigId.Encode(e)
		}
	}
	{
		e.FieldStart("observers")
		s.Observers.Encode(e)
	}
	{
		e.FieldStart("participants")
		e.ArrStart()
		for _, elem := range s.Participants {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSpectatorV5CurrentGameInfo = [11]string{
	0:  "gameId",
	1:  "gameType",
	2:  "gameStartTime",
	3:  "mapId",
	4:  "gameLength",
	5:  "platformId",
	6:  "gameMode",
	7:  "bannedChampions",
	8:  "gameQueueConfigId",
	9:  "observers",
	10: "participants",
}

// Decode decodes SpectatorV5CurrentGameInfo from json.
func (s *SpectatorV5CurrentGameInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpectatorV5CurrentGameInfo to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "gameId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.GameId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameId\"")
			}
		case "gameType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GameType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameType\"")
			}
		case "gameStartTime":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.GameStartTime = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameStartTime\"")
			}
		case "mapId":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int64()
				s.MapId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mapId\"")
			}
		case "gameLength":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.GameLength = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameLength\"")
			}
		case "platformId":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.PlatformId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platformId\"")
			}
		case "gameMode":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.GameMode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameMode\"")
			}
		case "bannedChampions":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.BannedChampions = make([]SpectatorV5BannedChampion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SpectatorV5BannedChampion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BannedChampions = append(s.BannedChampions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bannedChampions\"")
			}
		case "gameQueueConfigId":
			if err := func() error {
				s.GameQueueConfigId.Reset()
				if err := s.GameQueueConfigId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameQueueConfigId\"")
			}
		case "observers":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Observers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observers\"")
			}
		case "participants":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				s.Participants = make([]SpectatorV5CurrentGameParticipant, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SpectatorV5CurrentGameParticipant
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Participants = append(s.Participants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participants\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpectatorV5CurrentGameInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpectatorV5CurrentGameInfo) {
					name = jsonFieldsNameOfSpectatorV5CurrentGameInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpectatorV5CurrentGameInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpectatorV5CurrentGameInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpectatorV5CurrentGameParticipant) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpectatorV5CurrentGameParticipant) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("championId")
		e.Int64(s.ChampionId)
	}
	{
		if s.Perks.Set {
			e.FieldStart("perks")
			s.Perks.Encode(e)
		}
	}
	{
		e.FieldStart("profileIconId")
		e.Int64(s.ProfileIconId)
	}
	{
		e.FieldStart("bot")
		e.Bool(s.Bot)
	}
	{
		e.FieldStart("teamId")
		e.Int64(s.TeamId)
	}
	{
		if s.Puuid.Set {
			e.FieldStart("puuid")
			s.Puuid.Encode(e)
		}
	}
	{
		e.FieldStart("spell1Id")
		e.Int64(s.Spell1Id)
	}
	{
		e.FieldStart("spell2Id")
		e.Int64(s.Spell2Id)
	}
	{
		e.FieldStart("gameCustomizationObjects")
		e.ArrStart()
		for _, elem := range s.GameCustomizationObjects {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.RiotId.Set {
			e.FieldStart("riotId")
			s.RiotId.Encode(e)
		}
	}
}

var jsonFieldsNameOfSpectatorV5CurrentGameParticipant = [10]string{
	0: "championId",
	1: "perks",
	2: "profileIconId",
	3: "bot",
	4: "teamId",
	5: "puuid",
	6: "spell1Id",
	7: "spell2Id",
	8: "gameCustomizationObjects",
	9: "riotId",
}

// Decode decodes SpectatorV5CurrentGameParticipant from json.
func (s *SpectatorV5CurrentGameParticipant) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpectatorV5CurrentGameParticipant to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "championId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ChampionId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"championId\"")
			}
		case "perks":
			if err := func() error {
				s.Perks.Reset()
				if err := s.Perks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perks\"")
			}
		case "profileIconId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.ProfileIconId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileIconId\"")
			}
		case "bot":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Bot = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bot\"")
			}
		case "teamId":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.TeamId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamId\"")
			}
		case "puuid":
			if err := func() error {
				s.Puuid.Reset()
				if err := s.Puuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "spell1Id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int64()
				s.Spell1Id = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spell1Id\"")
			}
		case "spell2Id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int64()
				s.Spell2Id = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spell2Id\"")
			}
		case "gameCustomizationObjects":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.GameCustomizationObjects = make([]SpectatorV5GameCustomizationObject, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SpectatorV5GameCustomizationObject
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.GameCustomizationObjects = append(s.GameCustomizationObjects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameCustomizationObjects\"")
			}
		case "riotId":
			if err := func() error {
				s.RiotId.Reset()
				if err := s.RiotId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"riotId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpectatorV5CurrentGameParticipant")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11011101,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpectatorV5CurrentGameParticipant) {
					name = jsonFieldsNameOfSpectatorV5CurrentGameParticipant[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpectatorV5CurrentGameParticipant) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpectatorV5CurrentGameParticipant) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpectatorV5FeaturedGameInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpectatorV5FeaturedGameInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("gameMode")
		s.GameMode.Encode(e)
	}
	{
		e.FieldStart("gameLength")
		e.Int64(s.GameLength)
	}
	{
		e.FieldStart("mapId")
		e.Int64(s.MapId)
	}
	{
		e.FieldStart("gameType")
		s.GameType.Encode(e)
	}
	{
		e.FieldStart("bannedChampions")
		e.ArrStart()
		for _, elem := range s.BannedChampions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("gameId")
		e.Int64(s.GameId)
	}
	{
		e.FieldStart("observers")
		s.Observers.Encode(e)
	}
	{
		e.FieldStart("gameQueueConfigId")
		e.Int64(s.GameQueueConfigId)
	}
	{
		e.FieldStart("participants")
		e.ArrStart()
		for _, elem := range s.Participants {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("platformId")
		e.Str(s.PlatformId)
	}
}

var jsonFieldsNameOfSpectatorV5FeaturedGameInfo = [10]string{
	0: "gameMode",
	1: "gameLength",
	2: "mapId",
	3: "gameType",
	4: "bannedChampions",
	5: "gameId",
	6: "observers",
	7: "gameQueueConfigId",
	8: "participants",
	9: "platformId",
}

// Decode decodes SpectatorV5FeaturedGameInfo from json.
func (s *SpectatorV5FeaturedGameInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpectatorV5FeaturedGameInfo to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "gameMode":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.GameMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameMode\"")
			}
		case "gameLength":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.GameLength = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameLength\"")
			}
		case "mapId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.MapId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mapId\"")
			}
		case "gameType":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.GameType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameType\"")
			}
		case "bannedChampions":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.BannedChampions = make([]SpectatorV5BannedChampion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SpectatorV5BannedChampion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BannedChampions = append(s.BannedChampions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bannedChampions\"")
			}
		case "gameId":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.GameId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameId\"")
			}
		case "observers":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Observers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"observers\"")
			}
		case "gameQueueConfigId":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int64()
				s.GameQueueConfigId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameQueueConfigId\"")
			}
		case "participants":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.Participants = make([]SpectatorV5Participant, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SpectatorV5Participant
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Participants = append(s.Participants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participants\"")
			}
		case "platformId":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PlatformId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platformId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpectatorV5FeaturedGameInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpectatorV5FeaturedGameInfo) {
					name = jsonFieldsNameOfSpectatorV5FeaturedGameInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpectatorV5FeaturedGameInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpectatorV5FeaturedGameInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpectatorV5FeaturedGameInfoGameMode as json.
func (s SpectatorV5FeaturedGameInfoGameMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpectatorV5FeaturedGameInfoGameMode from json.
func (s *SpectatorV5FeaturedGameInfoGameMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpectatorV5FeaturedGameInfoGameMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpectatorV5FeaturedGameInfoGameMode(v) {
	case SpectatorV5FeaturedGameInfoGameModeCLASSIC:
		*s = SpectatorV5FeaturedGameInfoGameModeCLASSIC
	case SpectatorV5FeaturedGameInfoGameModeODIN:
		*s = SpectatorV5FeaturedGameInfoGameModeODIN
	case SpectatorV5FeaturedGameInfoGameModeARAM:
		*s = SpectatorV5FeaturedGameInfoGameModeARAM
	case SpectatorV5FeaturedGameInfoGameModeTUTORIAL:
		*s = SpectatorV5FeaturedGameInfoGameModeTUTORIAL
	case SpectatorV5FeaturedGameInfoGameModeONEFORALL:
		*s = SpectatorV5FeaturedGameInfoGameModeONEFORALL
	case SpectatorV5FeaturedGameInfoGameModeASCENSION:
		*s = SpectatorV5FeaturedGameInfoGameModeASCENSION
	case SpectatorV5FeaturedGameInfoGameModeFIRSTBLOOD:
		*s = SpectatorV5FeaturedGameInfoGameModeFIRSTBLOOD
	case SpectatorV5FeaturedGameInfoGameModeKINGPORO:
		*s = SpectatorV5FeaturedGameInfoGameModeKINGPORO
	default:
		*s = SpectatorV5FeaturedGameInfoGameMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpectatorV5FeaturedGameInfoGameMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpectatorV5FeaturedGameInfoGameMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpectatorV5FeaturedGameInfoGameType as json.
func (s SpectatorV5FeaturedGameInfoGameType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpectatorV5FeaturedGameInfoGameType from json.
func (s *SpectatorV5FeaturedGameInfoGameType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpectatorV5FeaturedGameInfoGameType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpectatorV5FeaturedGameInfoGameType(v) {
	case SpectatorV5FeaturedGameInfoGameTypeCUSTOMGAME:
		*s = SpectatorV5FeaturedGameInfoGameTypeCUSTOMGAME
	case SpectatorV5FeaturedGameInfoGameTypeMATCHEDGAME:
		*s = SpectatorV5FeaturedGameInfoGameTypeMATCHEDGAME
	case SpectatorV5FeaturedGameInfoGameTypeTUTORIALGAME:
		*s = SpectatorV5FeaturedGameInfoGameTypeTUTORIALGAME
	default:
		*s = SpectatorV5FeaturedGameInfoGameType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpectatorV5FeaturedGameInfoGameType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpectatorV5FeaturedGameInfoGameType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpectatorV5FeaturedGames) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpectatorV5FeaturedGames) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("gameList")
		e.ArrStart()
		for _, elem := range s.GameList {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.ClientRefreshInterval.Set {
			e.FieldStart("clientRefreshInterval")
			s.ClientRefreshInterval.Encode(e)
		}
	}
}

var jsonFieldsNameOfSpectatorV5FeaturedGames = [2]string{
	0: "gameList",
	1: "clientRefreshInterval",
}

// Decode decodes SpectatorV5FeaturedGames from json.
func (s *SpectatorV5FeaturedGames) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpectatorV5FeaturedGames to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "gameList":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.GameList = make([]SpectatorV5FeaturedGameInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SpectatorV5FeaturedGameInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.GameList = append(s.GameList, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameList\"")
			}
		case "clientRefreshInterval":
			if err := func() error {
				s.ClientRefreshInterval.Reset()
				if err := s.ClientRefreshInterval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientRefreshInterval\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpectatorV5FeaturedGames")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpectatorV5FeaturedGames) {
					name = jsonFieldsNameOfSpectatorV5FeaturedGames[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpectatorV5FeaturedGames) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpectatorV5FeaturedGames) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpectatorV5GameCustomizationObject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpectatorV5GameCustomizationObject) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("category")
		e.Str(s.Category)
	}
	{
		e.FieldStart("content")
		e.Str(s.Content)
	}
}

var jsonFieldsNameOfSpectatorV5GameCustomizationObject = [2]string{
	0: "category",
	1: "content",
}

// Decode decodes SpectatorV5GameCustomizationObject from json.
func (s *SpectatorV5GameCustomizationObject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpectatorV5GameCustomizationObject to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "category":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Category = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpectatorV5GameCustomizationObject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpectatorV5GameCustomizationObject) {
					name = jsonFieldsNameOfSpectatorV5GameCustomizationObject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpectatorV5GameCustomizationObject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpectatorV5GameCustomizationObject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpectatorV5Observer) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpectatorV5Observer) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("encryptionKey")
		e.Str(s.EncryptionKey)
	}
}

var jsonFieldsNameOfSpectatorV5Observer = [1]string{
	0: "encryptionKey",
}

// Decode decodes SpectatorV5Observer from json.
func (s *SpectatorV5Observer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpectatorV5Observer to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "encryptionKey":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EncryptionKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encryptionKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpectatorV5Observer")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpectatorV5Observer) {
					name = jsonFieldsNameOfSpectatorV5Observer[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpectatorV5Observer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpectatorV5Observer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpectatorV5Participant) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpectatorV5Participant) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("bot")
		e.Bool(s.Bot)
	}
	{
		e.FieldStart("spell2Id")
		e.Int64(s.Spell2Id)
	}
	{
		e.FieldStart("profileIconId")
		e.Int64(s.ProfileIconId)
	}
	{
		if s.Puuid.Set {
			e.FieldStart("puuid")
			s.Puuid.Encode(e)
		}
	}
	{
		e.FieldStart("championId")
		e.Int64(s.ChampionId)
	}
	{
		e.FieldStart("teamId")
		e.Int64(s.TeamId)
	}
	{
		e.FieldStart("spell1Id")
		e.Int64(s.Spell1Id)
	}
	{
		if s.RiotId.Set {
			e.FieldStart("riotId")
			s.RiotId.Encode(e)
		}
	}
}

var jsonFieldsNameOfSpectatorV5Participant = [8]string{
	0: "bot",
	1: "spell2Id",
	2: "profileIconId",
	3: "puuid",
	4: "championId",
	5: "teamId",
	6: "spell1Id",
	7: "riotId",
}

// Decode decodes SpectatorV5Participant from json.
func (s *SpectatorV5Participant) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpectatorV5Participant to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bot":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Bot = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bot\"")
			}
		case "spell2Id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Spell2Id = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spell2Id\"")
			}
		case "profileIconId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.ProfileIconId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileIconId\"")
			}
		case "puuid":
			if err := func() error {
				s.Puuid.Reset()
				if err := s.Puuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "championId":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.ChampionId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"championId\"")
			}
		case "teamId":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.TeamId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamId\"")
			}
		case "spell1Id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int64()
				s.Spell1Id = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spell1Id\"")
			}
		case "riotId":
			if err := func() error {
				s.RiotId.Reset()
				if err := s.RiotId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"riotId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpectatorV5Participant")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01110111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpectatorV5Participant) {
					name = jsonFieldsNameOfSpectatorV5Participant[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpectatorV5Participant) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpectatorV5Participant) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpectatorV5Perks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpectatorV5Perks) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("perkIds")
		e.ArrStart()
		for _, elem := range s.PerkIds {
			e.Int64(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("perkStyle")
		e.Int64(s.PerkStyle)
	}
	{
		e.FieldStart("perkSubStyle")
		e.Int64(s.PerkSubStyle)
	}
}

var jsonFieldsNameOfSpectatorV5Perks = [3]string{
	0: "perkIds",
	1: "perkStyle",
	2: "perkSubStyle",
}

// Decode decodes SpectatorV5Perks from json.
func (s *SpectatorV5Perks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpectatorV5Perks to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "perkIds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.PerkIds = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int64
					v, err := d.Int64()
					elem = int64(v)
					if err != nil {
						return err
					}
					s.PerkIds = append(s.PerkIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perkIds\"")
			}
		case "perkStyle":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.PerkStyle = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perkStyle\"")
			}
		case "perkSubStyle":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.PerkSubStyle = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perkSubStyle\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpectatorV5Perks")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpectatorV5Perks) {
					name = jsonFieldsNameOfSpectatorV5Perks[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpectatorV5Perks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpectatorV5Perks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SummonerV4SummonerDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SummonerV4SummonerDTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("profileIconId")
		e.Int32(s.ProfileIconId)
	}
	{
		e.FieldStart("revisionDate")
		e.Int64(s.RevisionDate)
	}
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		e.FieldStart("summonerLevel")
		e.Int64(s.SummonerLevel)
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
}

var jsonFieldsNameOfSummonerV4SummonerDTO = [5]string{
	0: "profileIconId",
	1: "revisionDate",
	2: "puuid",
	3: "summonerLevel",
	4: "id",
}

// Decode decodes SummonerV4SummonerDTO from json.
func (s *SummonerV4SummonerDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SummonerV4SummonerDTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "profileIconId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ProfileIconId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileIconId\"")
			}
		case "revisionDate":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.RevisionDate = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"revisionDate\"")
			}
		case "puuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "summonerLevel":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int64()
				s.SummonerLevel = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summonerLevel\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SummonerV4SummonerDTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSummonerV4SummonerDTO) {
					name = jsonFieldsNameOfSummonerV4SummonerDTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SummonerV4SummonerDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SummonerV4SummonerDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TftLeagueV1GetLeagueEntriesByPUUIDOKApplicationJSON as json.
func (s TftLeagueV1GetLeagueEntriesByPUUIDOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []TftLeagueV1LeagueEntryDTO(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes TftLeagueV1GetLeagueEntriesByPUUIDOKApplicationJSON from json.
func (s *TftLeagueV1GetLeagueEntriesByPUUIDOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftLeagueV1GetLeagueEntriesByPUUIDOKApplicationJSON to nil")
	}
	var unwrapped []TftLeagueV1LeagueEntryDTO
	if err := func() error {
		unwrapped = make([]TftLeagueV1LeagueEntryDTO, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem TftLeagueV1LeagueEntryDTO
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TftLeagueV1GetLeagueEntriesByPUUIDOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TftLeagueV1GetLeagueEntriesByPUUIDOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftLeagueV1GetLeagueEntriesByPUUIDOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TftLeagueV1GetLeagueEntriesOKApplicationJSON as json.
func (s TftLeagueV1GetLeagueEntriesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []TftLeagueV1LeagueEntryDTO(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes TftLeagueV1GetLeagueEntriesOKApplicationJSON from json.
func (s *TftLeagueV1GetLeagueEntriesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftLeagueV1GetLeagueEntriesOKApplicationJSON to nil")
	}
	var unwrapped []TftLeagueV1LeagueEntryDTO
	if err := func() error {
		unwrapped = make([]TftLeagueV1LeagueEntryDTO, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem TftLeagueV1LeagueEntryDTO
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TftLeagueV1GetLeagueEntriesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TftLeagueV1GetLeagueEntriesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftLeagueV1GetLeagueEntriesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TftLeagueV1GetTopRatedLadderOKApplicationJSON as json.
func (s TftLeagueV1GetTopRatedLadderOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []TftLeagueV1TopRatedLadderEntryDto(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes TftLeagueV1GetTopRatedLadderOKApplicationJSON from json.
func (s *TftLeagueV1GetTopRatedLadderOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftLeagueV1GetTopRatedLadderOKApplicationJSON to nil")
	}
	var unwrapped []TftLeagueV1TopRatedLadderEntryDto
	if err := func() error {
		unwrapped = make([]TftLeagueV1TopRatedLadderEntryDto, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem TftLeagueV1TopRatedLadderEntryDto
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TftLeagueV1GetTopRatedLadderOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TftLeagueV1GetTopRatedLadderOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftLeagueV1GetTopRatedLadderOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TftLeagueV1LeagueEntryDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TftLeagueV1LeagueEntryDTO) encodeFields(e *jx.Encoder) {
	{
		if s.Puuid.Set {
			e.FieldStart("puuid")
			s.Puuid.Encode(e)
		}
	}
	{
		if s.LeagueId.Set {
			e.FieldStart("leagueId")
			s.LeagueId.Encode(e)
		}
	}
	{
		e.FieldStart("queueType")
		e.Str(s.QueueType)
	}
	{
		if s.RatedTier.Set {
			e.FieldStart("ratedTier")
			s.RatedTier.Encode(e)
		}
	}
	{
		if s.RatedRating.Set {
			e.FieldStart("ratedRating")
			s.RatedRating.Encode(e)
		}
	}
	{
		if s.Tier.Set {
			e.FieldStart("tier")
			s.Tier.Encode(e)
		}
	}
	{
		if s.Rank.Set {
			e.FieldStart("rank")
			s.Rank.Encode(e)
		}
	}
	{
		if s.LeaguePoints.Set {
			e.FieldStart("leaguePoints")
			s.LeaguePoints.Encode(e)
		}
	}
	{
		e.FieldStart("wins")
		e.Int32(s.Wins)
	}
	{
		e.FieldStart("losses")
		e.Int32(s.Losses)
	}
	{
		if s.HotStreak.Set {
			e.FieldStart("hotStreak")
			s.HotStreak.Encode(e)
		}
	}
	{
		if s.Veteran.Set {
			e.FieldStart("veteran")
			s.Veteran.Encode(e)
		}
	}
	{
		if s.FreshBlood.Set {
			e.FieldStart("freshBlood")
			s.FreshBlood.Encode(e)
		}
	}
	{
		if s.Inactive.Set {
			e.FieldStart("inactive")
			s.Inactive.Encode(e)
		}
	}
	{
		if s.MiniSeries.Set {
			e.FieldStart("miniSeries")
			s.MiniSeries.Encode(e)
		}
	}
}

var jsonFieldsNameOfTftLeagueV1LeagueEntryDTO = [15]string{
	0:  "puuid",
	1:  "leagueId",
	2:  "queueType",
	3:  "ratedTier",
	4:  "ratedRating",
	5:  "tier",
	6:  "rank",
	7:  "leaguePoints",
	8:  "wins",
	9:  "losses",
	10: "hotStreak",
	11: "veteran",
	12: "freshBlood",
	13: "inactive",
	14: "miniSeries",
}

// Decode decodes TftLeagueV1LeagueEntryDTO from json.
func (s *TftLeagueV1LeagueEntryDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftLeagueV1LeagueEntryDTO to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "puuid":
			if err := func() error {
				s.Puuid.Reset()
				if err := s.Puuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "leagueId":
			if err := func() error {
				s.LeagueId.Reset()
				if err := s.LeagueId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leagueId\"")
			}
		case "queueType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.QueueType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queueType\"")
			}
		case "ratedTier":
			if err := func() error {
				s.RatedTier.Reset()
				if err := s.RatedTier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ratedTier\"")
			}
		case "ratedRating":
			if err := func() error {
				s.RatedRating.Reset()
				if err := s.RatedRating.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ratedRating\"")
			}
		case "tier":
			if err := func() error {
				s.Tier.Reset()
				if err := s.Tier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier\"")
			}
		case "rank":
			if err := func() error {
				s.Rank.Reset()
				if err := s.Rank.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rank\"")
			}
		case "leaguePoints":
			if err := func() error {
				s.LeaguePoints.Reset()
				if err := s.LeaguePoints.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leaguePoints\"")
			}
		case "wins":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Wins = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wins\"")
			}
		case "losses":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Losses = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"losses\"")
			}
		case "hotStreak":
			if err := func() error {
				s.HotStreak.Reset()
				if err := s.HotStreak.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hotStreak\"")
			}
		case "veteran":
			if err := func() error {
				s.Veteran.Reset()
				if err := s.Veteran.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"veteran\"")
			}
		case "freshBlood":
			if err := func() error {
				s.FreshBlood.Reset()
				if err := s.FreshBlood.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"freshBlood\"")
			}
		case "inactive":
			if err := func() error {
				s.Inactive.Reset()
				if err := s.Inactive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inactive\"")
			}
		case "miniSeries":
			if err := func() error {
				s.MiniSeries.Reset()
				if err := s.MiniSeries.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"miniSeries\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TftLeagueV1LeagueEntryDTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000100,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTftLeagueV1LeagueEntryDTO) {
					name = jsonFieldsNameOfTftLeagueV1LeagueEntryDTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TftLeagueV1LeagueEntryDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftLeagueV1LeagueEntryDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TftLeagueV1LeagueEntryDTORatedTier as json.
func (s TftLeagueV1LeagueEntryDTORatedTier) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TftLeagueV1LeagueEntryDTORatedTier from json.
func (s *TftLeagueV1LeagueEntryDTORatedTier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftLeagueV1LeagueEntryDTORatedTier to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TftLeagueV1LeagueEntryDTORatedTier(v) {
	case TftLeagueV1LeagueEntryDTORatedTierORANGE:
		*s = TftLeagueV1LeagueEntryDTORatedTierORANGE
	case TftLeagueV1LeagueEntryDTORatedTierPURPLE:
		*s = TftLeagueV1LeagueEntryDTORatedTierPURPLE
	case TftLeagueV1LeagueEntryDTORatedTierBLUE:
		*s = TftLeagueV1LeagueEntryDTORatedTierBLUE
	case TftLeagueV1LeagueEntryDTORatedTierGREEN:
		*s = TftLeagueV1LeagueEntryDTORatedTierGREEN
	case TftLeagueV1LeagueEntryDTORatedTierGRAY:
		*s = TftLeagueV1LeagueEntryDTORatedTierGRAY
	default:
		*s = TftLeagueV1LeagueEntryDTORatedTier(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TftLeagueV1LeagueEntryDTORatedTier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftLeagueV1LeagueEntryDTORatedTier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TftLeagueV1LeagueItemDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TftLeagueV1LeagueItemDTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("freshBlood")
		e.Bool(s.FreshBlood)
	}
	{
		e.FieldStart("wins")
		e.Int32(s.Wins)
	}
	{
		if s.MiniSeries.Set {
			e.FieldStart("miniSeries")
			s.MiniSeries.Encode(e)
		}
	}
	{
		e.FieldStart("inactive")
		e.Bool(s.Inactive)
	}
	{
		e.FieldStart("veteran")
		e.Bool(s.Veteran)
	}
	{
		e.FieldStart("hotStreak")
		e.Bool(s.HotStreak)
	}
	{
		e.FieldStart("rank")
		e.Str(s.Rank)
	}
	{
		e.FieldStart("leaguePoints")
		e.Int32(s.LeaguePoints)
	}
	{
		e.FieldStart("losses")
		e.Int32(s.Losses)
	}
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
}

var jsonFieldsNameOfTftLeagueV1LeagueItemDTO = [10]string{
	0: "freshBlood",
	1: "wins",
	2: "miniSeries",
	3: "inactive",
	4: "veteran",
	5: "hotStreak",
	6: "rank",
	7: "leaguePoints",
	8: "losses",
	9: "puuid",
}

// Decode decodes TftLeagueV1LeagueItemDTO from json.
func (s *TftLeagueV1LeagueItemDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftLeagueV1LeagueItemDTO to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "freshBlood":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.FreshBlood = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"freshBlood\"")
			}
		case "wins":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Wins = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wins\"")
			}
		case "miniSeries":
			if err := func() error {
				s.MiniSeries.Reset()
				if err := s.MiniSeries.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"miniSeries\"")
			}
		case "inactive":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Inactive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inactive\"")
			}
		case "veteran":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Veteran = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"veteran\"")
			}
		case "hotStreak":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.HotStreak = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hotStreak\"")
			}
		case "rank":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Rank = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rank\"")
			}
		case "leaguePoints":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.LeaguePoints = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leaguePoints\"")
			}
		case "losses":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Losses = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"losses\"")
			}
		case "puuid":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TftLeagueV1LeagueItemDTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111011,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTftLeagueV1LeagueItemDTO) {
					name = jsonFieldsNameOfTftLeagueV1LeagueItemDTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TftLeagueV1LeagueItemDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftLeagueV1LeagueItemDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TftLeagueV1LeagueListDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TftLeagueV1LeagueListDTO) encodeFields(e *jx.Encoder) {
	{
		if s.LeagueId.Set {
			e.FieldStart("leagueId")
			s.LeagueId.Encode(e)
		}
	}
	{
		e.FieldStart("entries")
		e.ArrStart()
		for _, elem := range s.Entries {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("tier")
		e.Str(s.Tier)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Queue.Set {
			e.FieldStart("queue")
			s.Queue.Encode(e)
		}
	}
}

var jsonFieldsNameOfTftLeagueV1LeagueListDTO = [5]string{
	0: "leagueId",
	1: "entries",
	2: "tier",
	3: "name",
	4: "queue",
}

// Decode decodes TftLeagueV1LeagueListDTO from json.
func (s *TftLeagueV1LeagueListDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftLeagueV1LeagueListDTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "leagueId":
			if err := func() error {
				s.LeagueId.Reset()
				if err := s.LeagueId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leagueId\"")
			}
		case "entries":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Entries = make([]TftLeagueV1LeagueItemDTO, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TftLeagueV1LeagueItemDTO
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Entries = append(s.Entries, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entries\"")
			}
		case "tier":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tier = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "queue":
			if err := func() error {
				s.Queue.Reset()
				if err := s.Queue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TftLeagueV1LeagueListDTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTftLeagueV1LeagueListDTO) {
					name = jsonFieldsNameOfTftLeagueV1LeagueListDTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TftLeagueV1LeagueListDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftLeagueV1LeagueListDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TftLeagueV1MiniSeriesDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TftLeagueV1MiniSeriesDTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("losses")
		e.Int32(s.Losses)
	}
	{
		e.FieldStart("progress")
		e.Str(s.Progress)
	}
	{
		e.FieldStart("target")
		e.Int32(s.Target)
	}
	{
		e.FieldStart("wins")
		e.Int32(s.Wins)
	}
}

var jsonFieldsNameOfTftLeagueV1MiniSeriesDTO = [4]string{
	0: "losses",
	1: "progress",
	2: "target",
	3: "wins",
}

// Decode decodes TftLeagueV1MiniSeriesDTO from json.
func (s *TftLeagueV1MiniSeriesDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftLeagueV1MiniSeriesDTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "losses":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Losses = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"losses\"")
			}
		case "progress":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Progress = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress\"")
			}
		case "target":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Target = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target\"")
			}
		case "wins":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Wins = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wins\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TftLeagueV1MiniSeriesDTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTftLeagueV1MiniSeriesDTO) {
					name = jsonFieldsNameOfTftLeagueV1MiniSeriesDTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TftLeagueV1MiniSeriesDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftLeagueV1MiniSeriesDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TftLeagueV1TopRatedLadderEntryDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TftLeagueV1TopRatedLadderEntryDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		e.FieldStart("ratedTier")
		s.RatedTier.Encode(e)
	}
	{
		e.FieldStart("ratedRating")
		e.Int32(s.RatedRating)
	}
	{
		e.FieldStart("wins")
		e.Int32(s.Wins)
	}
	{
		e.FieldStart("previousUpdateLadderPosition")
		e.Int32(s.PreviousUpdateLadderPosition)
	}
}

var jsonFieldsNameOfTftLeagueV1TopRatedLadderEntryDto = [5]string{
	0: "puuid",
	1: "ratedTier",
	2: "ratedRating",
	3: "wins",
	4: "previousUpdateLadderPosition",
}

// Decode decodes TftLeagueV1TopRatedLadderEntryDto from json.
func (s *TftLeagueV1TopRatedLadderEntryDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftLeagueV1TopRatedLadderEntryDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "puuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "ratedTier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.RatedTier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ratedTier\"")
			}
		case "ratedRating":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.RatedRating = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ratedRating\"")
			}
		case "wins":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Wins = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wins\"")
			}
		case "previousUpdateLadderPosition":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.PreviousUpdateLadderPosition = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previousUpdateLadderPosition\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TftLeagueV1TopRatedLadderEntryDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTftLeagueV1TopRatedLadderEntryDto) {
					name = jsonFieldsNameOfTftLeagueV1TopRatedLadderEntryDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TftLeagueV1TopRatedLadderEntryDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftLeagueV1TopRatedLadderEntryDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TftLeagueV1TopRatedLadderEntryDtoRatedTier as json.
func (s TftLeagueV1TopRatedLadderEntryDtoRatedTier) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TftLeagueV1TopRatedLadderEntryDtoRatedTier from json.
func (s *TftLeagueV1TopRatedLadderEntryDtoRatedTier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftLeagueV1TopRatedLadderEntryDtoRatedTier to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TftLeagueV1TopRatedLadderEntryDtoRatedTier(v) {
	case TftLeagueV1TopRatedLadderEntryDtoRatedTierORANGE:
		*s = TftLeagueV1TopRatedLadderEntryDtoRatedTierORANGE
	case TftLeagueV1TopRatedLadderEntryDtoRatedTierPURPLE:
		*s = TftLeagueV1TopRatedLadderEntryDtoRatedTierPURPLE
	case TftLeagueV1TopRatedLadderEntryDtoRatedTierBLUE:
		*s = TftLeagueV1TopRatedLadderEntryDtoRatedTierBLUE
	case TftLeagueV1TopRatedLadderEntryDtoRatedTierGREEN:
		*s = TftLeagueV1TopRatedLadderEntryDtoRatedTierGREEN
	case TftLeagueV1TopRatedLadderEntryDtoRatedTierGRAY:
		*s = TftLeagueV1TopRatedLadderEntryDtoRatedTierGRAY
	default:
		*s = TftLeagueV1TopRatedLadderEntryDtoRatedTier(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TftLeagueV1TopRatedLadderEntryDtoRatedTier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftLeagueV1TopRatedLadderEntryDtoRatedTier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TftMatchV1CompanionDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TftMatchV1CompanionDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("content_ID")
		e.Str(s.ContentID)
	}
	{
		e.FieldStart("item_ID")
		e.Int32(s.ItemID)
	}
	{
		e.FieldStart("skin_ID")
		e.Int32(s.SkinID)
	}
	{
		e.FieldStart("species")
		e.Str(s.Species)
	}
}

var jsonFieldsNameOfTftMatchV1CompanionDto = [4]string{
	0: "content_ID",
	1: "item_ID",
	2: "skin_ID",
	3: "species",
}

// Decode decodes TftMatchV1CompanionDto from json.
func (s *TftMatchV1CompanionDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftMatchV1CompanionDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content_ID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ContentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_ID\"")
			}
		case "item_ID":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.ItemID = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_ID\"")
			}
		case "skin_ID":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.SkinID = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skin_ID\"")
			}
		case "species":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Species = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"species\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TftMatchV1CompanionDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTftMatchV1CompanionDto) {
					name = jsonFieldsNameOfTftMatchV1CompanionDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TftMatchV1CompanionDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftMatchV1CompanionDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TftMatchV1GetMatchIdsByPUUIDOKApplicationJSON as json.
func (s TftMatchV1GetMatchIdsByPUUIDOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []string(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes TftMatchV1GetMatchIdsByPUUIDOKApplicationJSON from json.
func (s *TftMatchV1GetMatchIdsByPUUIDOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftMatchV1GetMatchIdsByPUUIDOKApplicationJSON to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TftMatchV1GetMatchIdsByPUUIDOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TftMatchV1GetMatchIdsByPUUIDOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftMatchV1GetMatchIdsByPUUIDOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TftMatchV1InfoDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TftMatchV1InfoDto) encodeFields(e *jx.Encoder) {
	{
		if s.EndOfGameResult.Set {
			e.FieldStart("endOfGameResult")
			s.EndOfGameResult.Encode(e)
		}
	}
	{
		if s.GameCreation.Set {
			e.FieldStart("gameCreation")
			s.GameCreation.Encode(e)
		}
	}
	{
		if s.GameId.Set {
			e.FieldStart("gameId")
			s.GameId.Encode(e)
		}
	}
	{
		e.FieldStart("game_datetime")
		e.Int64(s.GameDatetime)
	}
	{
		e.FieldStart("game_length")
		e.Float32(s.GameLength)
	}
	{
		e.FieldStart("game_version")
		e.Str(s.GameVersion)
	}
	{
		if s.GameVariation.Set {
			e.FieldStart("game_variation")
			s.GameVariation.Encode(e)
		}
	}
	{
		if s.MapId.Set {
			e.FieldStart("mapId")
			s.MapId.Encode(e)
		}
	}
	{
		e.FieldStart("participants")
		e.ArrStart()
		for _, elem := range s.Participants {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("queue_id")
		e.Int32(s.QueueID)
	}
	{
		if s.QueueId.Set {
			e.FieldStart("queueId")
			s.QueueId.Encode(e)
		}
	}
	{
		if s.TftGameType.Set {
			e.FieldStart("tft_game_type")
			s.TftGameType.Encode(e)
		}
	}
	{
		if s.TftSetCoreName.Set {
			e.FieldStart("tft_set_core_name")
			s.TftSetCoreName.Encode(e)
		}
	}
	{
		e.FieldStart("tft_set_number")
		e.Int32(s.TftSetNumber)
	}
}

var jsonFieldsNameOfTftMatchV1InfoDto = [14]string{
	0:  "endOfGameResult",
	1:  "gameCreation",
	2:  "gameId",
	3:  "game_datetime",
	4:  "game_length",
	5:  "game_version",
	6:  "game_variation",
	7:  "mapId",
	8:  "participants",
	9:  "queue_id",
	10: "queueId",
	11: "tft_game_type",
	12: "tft_set_core_name",
	13: "tft_set_number",
}

// Decode decodes TftMatchV1InfoDto from json.
func (s *TftMatchV1InfoDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftMatchV1InfoDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "endOfGameResult":
			if err := func() error {
				s.EndOfGameResult.Reset()
				if err := s.EndOfGameResult.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endOfGameResult\"")
			}
		case "gameCreation":
			if err := func() error {
				s.GameCreation.Reset()
				if err := s.GameCreation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameCreation\"")
			}
		case "gameId":
			if err := func() error {
				s.GameId.Reset()
				if err := s.GameId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameId\"")
			}
		case "game_datetime":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int64()
				s.GameDatetime = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_datetime\"")
			}
		case "game_length":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float32()
				s.GameLength = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_length\"")
			}
		case "game_version":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.GameVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_version\"")
			}
		case "game_variation":
			if err := func() error {
				s.GameVariation.Reset()
				if err := s.GameVariation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_variation\"")
			}
		case "mapId":
			if err := func() error {
				s.MapId.Reset()
				if err := s.MapId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mapId\"")
			}
		case "participants":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.Participants = make([]TftMatchV1ParticipantDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TftMatchV1ParticipantDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Participants = append(s.Participants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participants\"")
			}
		case "queue_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.QueueID = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queue_id\"")
			}
		case "queueId":
			if err := func() error {
				s.QueueId.Reset()
				if err := s.QueueId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queueId\"")
			}
		case "tft_game_type":
			if err := func() error {
				s.TftGameType.Reset()
				if err := s.TftGameType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tft_game_type\"")
			}
		case "tft_set_core_name":
			if err := func() error {
				s.TftSetCoreName.Reset()
				if err := s.TftSetCoreName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tft_set_core_name\"")
			}
		case "tft_set_number":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.TftSetNumber = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tft_set_number\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TftMatchV1InfoDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111000,
		0b00100011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTftMatchV1InfoDto) {
					name = jsonFieldsNameOfTftMatchV1InfoDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TftMatchV1InfoDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftMatchV1InfoDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TftMatchV1MatchDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TftMatchV1MatchDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		e.FieldStart("info")
		s.Info.Encode(e)
	}
}

var jsonFieldsNameOfTftMatchV1MatchDto = [2]string{
	0: "metadata",
	1: "info",
}

// Decode decodes TftMatchV1MatchDto from json.
func (s *TftMatchV1MatchDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftMatchV1MatchDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metadata":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "info":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TftMatchV1MatchDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTftMatchV1MatchDto) {
					name = jsonFieldsNameOfTftMatchV1MatchDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TftMatchV1MatchDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftMatchV1MatchDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TftMatchV1MetadataDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TftMatchV1MetadataDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data_version")
		e.Str(s.DataVersion)
	}
	{
		e.FieldStart("match_id")
		e.Str(s.MatchID)
	}
	{
		e.FieldStart("participants")
		e.ArrStart()
		for _, elem := range s.Participants {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfTftMatchV1MetadataDto = [3]string{
	0: "data_version",
	1: "match_id",
	2: "participants",
}

// Decode decodes TftMatchV1MetadataDto from json.
func (s *TftMatchV1MetadataDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftMatchV1MetadataDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data_version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DataVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_version\"")
			}
		case "match_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.MatchID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"match_id\"")
			}
		case "participants":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Participants = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Participants = append(s.Participants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participants\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TftMatchV1MetadataDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTftMatchV1MetadataDto) {
					name = jsonFieldsNameOfTftMatchV1MetadataDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TftMatchV1MetadataDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftMatchV1MetadataDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TftMatchV1ParticipantDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TftMatchV1ParticipantDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("companion")
		s.Companion.Encode(e)
	}
	{
		e.FieldStart("gold_left")
		e.Int32(s.GoldLeft)
	}
	{
		e.FieldStart("last_round")
		e.Int32(s.LastRound)
	}
	{
		e.FieldStart("level")
		e.Int32(s.Level)
	}
	{
		e.FieldStart("placement")
		e.Int32(s.Placement)
	}
	{
		e.FieldStart("players_eliminated")
		e.Int32(s.PlayersEliminated)
	}
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		if s.RiotIdGameName.Set {
			e.FieldStart("riotIdGameName")
			s.RiotIdGameName.Encode(e)
		}
	}
	{
		if s.RiotIdTagline.Set {
			e.FieldStart("riotIdTagline")
			s.RiotIdTagline.Encode(e)
		}
	}
	{
		e.FieldStart("time_eliminated")
		e.Float32(s.TimeEliminated)
	}
	{
		e.FieldStart("total_damage_to_players")
		e.Int32(s.TotalDamageToPlayers)
	}
	{
		e.FieldStart("traits")
		e.ArrStart()
		for _, elem := range s.Traits {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("units")
		e.ArrStart()
		for _, elem := range s.Units {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Win.Set {
			e.FieldStart("win")
			s.Win.Encode(e)
		}
	}
	{
		if s.Augments != nil {
			e.FieldStart("augments")
			e.ArrStart()
			for _, elem := range s.Augments {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PartnerGroupID.Set {
			e.FieldStart("partner_group_id")
			s.PartnerGroupID.Encode(e)
		}
	}
	{
		if s.Missions.Set {
			e.FieldStart("missions")
			s.Missions.Encode(e)
		}
	}
	{
		if s.SkillTree.Set {
			e.FieldStart("skill_tree")
			s.SkillTree.Encode(e)
		}
	}
	{
		if s.PveScore.Set {
			e.FieldStart("pve_score")
			s.PveScore.Encode(e)
		}
	}
	{
		if s.PveWonrun.Set {
			e.FieldStart("pve_wonrun")
			s.PveWonrun.Encode(e)
		}
	}
}

var jsonFieldsNameOfTftMatchV1ParticipantDto = [20]string{
	0:  "companion",
	1:  "gold_left",
	2:  "last_round",
	3:  "level",
	4:  "placement",
	5:  "players_eliminated",
	6:  "puuid",
	7:  "riotIdGameName",
	8:  "riotIdTagline",
	9:  "time_eliminated",
	10: "total_damage_to_players",
	11: "traits",
	12: "units",
	13: "win",
	14: "augments",
	15: "partner_group_id",
	16: "missions",
	17: "skill_tree",
	18: "pve_score",
	19: "pve_wonrun",
}

// Decode decodes TftMatchV1ParticipantDto from json.
func (s *TftMatchV1ParticipantDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftMatchV1ParticipantDto to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "companion":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Companion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"companion\"")
			}
		case "gold_left":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.GoldLeft = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gold_left\"")
			}
		case "last_round":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.LastRound = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_round\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Level = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "placement":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Placement = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"placement\"")
			}
		case "players_eliminated":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.PlayersEliminated = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"players_eliminated\"")
			}
		case "puuid":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "riotIdGameName":
			if err := func() error {
				s.RiotIdGameName.Reset()
				if err := s.RiotIdGameName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"riotIdGameName\"")
			}
		case "riotIdTagline":
			if err := func() error {
				s.RiotIdTagline.Reset()
				if err := s.RiotIdTagline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"riotIdTagline\"")
			}
		case "time_eliminated":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.TimeEliminated = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_eliminated\"")
			}
		case "total_damage_to_players":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.TotalDamageToPlayers = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_damage_to_players\"")
			}
		case "traits":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				s.Traits = make([]TftMatchV1TraitDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TftMatchV1TraitDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Traits = append(s.Traits, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"traits\"")
			}
		case "units":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				s.Units = make([]TftMatchV1UnitDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TftMatchV1UnitDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Units = append(s.Units, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"units\"")
			}
		case "win":
			if err := func() error {
				s.Win.Reset()
				if err := s.Win.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"win\"")
			}
		case "augments":
			if err := func() error {
				s.Augments = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Augments = append(s.Augments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"augments\"")
			}
		case "partner_group_id":
			if err := func() error {
				s.PartnerGroupID.Reset()
				if err := s.PartnerGroupID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partner_group_id\"")
			}
		case "missions":
			if err := func() error {
				s.Missions.Reset()
				if err := s.Missions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"missions\"")
			}
		case "skill_tree":
			if err := func() error {
				s.SkillTree.Reset()
				if err := s.SkillTree.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skill_tree\"")
			}
		case "pve_score":
			if err := func() error {
				s.PveScore.Reset()
				if err := s.PveScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pve_score\"")
			}
		case "pve_wonrun":
			if err := func() error {
				s.PveWonrun.Reset()
				if err := s.PveWonrun.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pve_wonrun\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TftMatchV1ParticipantDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01111111,
		0b00011110,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTftMatchV1ParticipantDto) {
					name = jsonFieldsNameOfTftMatchV1ParticipantDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TftMatchV1ParticipantDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftMatchV1ParticipantDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s TftMatchV1ParticipantDtoSkillTree) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s TftMatchV1ParticipantDtoSkillTree) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int32(elem)
	}
}

// Decode decodes TftMatchV1ParticipantDtoSkillTree from json.
func (s *TftMatchV1ParticipantDtoSkillTree) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftMatchV1ParticipantDtoSkillTree to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int32
		if err := func() error {
			v, err := d.Int32()
			elem = int32(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TftMatchV1ParticipantDtoSkillTree")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TftMatchV1ParticipantDtoSkillTree) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftMatchV1ParticipantDtoSkillTree) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TftMatchV1ParticipantMissionsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TftMatchV1ParticipantMissionsDto) encodeFields(e *jx.Encoder) {
	{
		if s.Assists.Set {
			e.FieldStart("Assists")
			s.Assists.Encode(e)
		}
	}
	{
		if s.DamageDealt.Set {
			e.FieldStart("DamageDealt")
			s.DamageDealt.Encode(e)
		}
	}
	{
		if s.DamageDealtToObjectives.Set {
			e.FieldStart("DamageDealtToObjectives")
			s.DamageDealtToObjectives.Encode(e)
		}
	}
	{
		if s.DamageDealtToTurrets.Set {
			e.FieldStart("DamageDealtToTurrets")
			s.DamageDealtToTurrets.Encode(e)
		}
	}
	{
		if s.DamageTaken.Set {
			e.FieldStart("DamageTaken")
			s.DamageTaken.Encode(e)
		}
	}
	{
		if s.DoubleKills.Set {
			e.FieldStart("DoubleKills")
			s.DoubleKills.Encode(e)
		}
	}
	{
		if s.GoldEarned.Set {
			e.FieldStart("GoldEarned")
			s.GoldEarned.Encode(e)
		}
	}
	{
		if s.GoldSpent.Set {
			e.FieldStart("GoldSpent")
			s.GoldSpent.Encode(e)
		}
	}
	{
		if s.InhibitorsDestroyed.Set {
			e.FieldStart("InhibitorsDestroyed")
			s.InhibitorsDestroyed.Encode(e)
		}
	}
	{
		if s.Kills.Set {
			e.FieldStart("Kills")
			s.Kills.Encode(e)
		}
	}
	{
		if s.LargestKillingSpree.Set {
			e.FieldStart("LargestKillingSpree")
			s.LargestKillingSpree.Encode(e)
		}
	}
	{
		if s.LargestMultiKill.Set {
			e.FieldStart("LargestMultiKill")
			s.LargestMultiKill.Encode(e)
		}
	}
	{
		if s.MagicDamageDealt.Set {
			e.FieldStart("MagicDamageDealt")
			s.MagicDamageDealt.Encode(e)
		}
	}
	{
		if s.MagicDamageDealtToChampions.Set {
			e.FieldStart("MagicDamageDealtToChampions")
			s.MagicDamageDealtToChampions.Encode(e)
		}
	}
	{
		if s.NeutralMinionsKilledTeamJungle.Set {
			e.FieldStart("NeutralMinionsKilledTeamJungle")
			s.NeutralMinionsKilledTeamJungle.Encode(e)
		}
	}
	{
		if s.PhysicalDamageDealt.Set {
			e.FieldStart("PhysicalDamageDealt")
			s.PhysicalDamageDealt.Encode(e)
		}
	}
	{
		if s.PhysicalDamageTaken.Set {
			e.FieldStart("PhysicalDamageTaken")
			s.PhysicalDamageTaken.Encode(e)
		}
	}
	{
		if s.PlayerScore0.Set {
			e.FieldStart("PlayerScore0")
			s.PlayerScore0.Encode(e)
		}
	}
	{
		if s.PlayerScore1.Set {
			e.FieldStart("PlayerScore1")
			s.PlayerScore1.Encode(e)
		}
	}
	{
		if s.PlayerScore2.Set {
			e.FieldStart("PlayerScore2")
			s.PlayerScore2.Encode(e)
		}
	}
	{
		if s.PlayerScore3.Set {
			e.FieldStart("PlayerScore3")
			s.PlayerScore3.Encode(e)
		}
	}
	{
		if s.PlayerScore4.Set {
			e.FieldStart("PlayerScore4")
			s.PlayerScore4.Encode(e)
		}
	}
	{
		if s.PlayerScore5.Set {
			e.FieldStart("PlayerScore5")
			s.PlayerScore5.Encode(e)
		}
	}
	{
		if s.PlayerScore6.Set {
			e.FieldStart("PlayerScore6")
			s.PlayerScore6.Encode(e)
		}
	}
	{
		if s.PlayerScore9.Set {
			e.FieldStart("PlayerScore9")
			s.PlayerScore9.Encode(e)
		}
	}
	{
		if s.PlayerScore10.Set {
			e.FieldStart("PlayerScore10")
			s.PlayerScore10.Encode(e)
		}
	}
	{
		if s.PlayerScore11.Set {
			e.FieldStart("PlayerScore11")
			s.PlayerScore11.Encode(e)
		}
	}
	{
		if s.QuadraKills.Set {
			e.FieldStart("QuadraKills")
			s.QuadraKills.Encode(e)
		}
	}
	{
		if s.Spell1Casts.Set {
			e.FieldStart("Spell1Casts")
			s.Spell1Casts.Encode(e)
		}
	}
	{
		if s.Spell2Casts.Set {
			e.FieldStart("Spell2Casts")
			s.Spell2Casts.Encode(e)
		}
	}
	{
		if s.Spell3Casts.Set {
			e.FieldStart("Spell3Casts")
			s.Spell3Casts.Encode(e)
		}
	}
	{
		if s.Spell4Casts.Set {
			e.FieldStart("Spell4Casts")
			s.Spell4Casts.Encode(e)
		}
	}
	{
		if s.SummonerSpell1Casts.Set {
			e.FieldStart("SummonerSpell1Casts")
			s.SummonerSpell1Casts.Encode(e)
		}
	}
	{
		if s.TimeCCOthers.Set {
			e.FieldStart("TimeCCOthers")
			s.TimeCCOthers.Encode(e)
		}
	}
	{
		if s.TotalMinionsKilled.Set {
			e.FieldStart("TotalMinionsKilled")
			s.TotalMinionsKilled.Encode(e)
		}
	}
	{
		if s.TrueDamageDealtToChampions.Set {
			e.FieldStart("TrueDamageDealtToChampions")
			s.TrueDamageDealtToChampions.Encode(e)
		}
	}
	{
		if s.UnrealKills.Set {
			e.FieldStart("UnrealKills")
			s.UnrealKills.Encode(e)
		}
	}
	{
		if s.VisionScore.Set {
			e.FieldStart("VisionScore")
			s.VisionScore.Encode(e)
		}
	}
	{
		if s.WardsKilled.Set {
			e.FieldStart("WardsKilled")
			s.WardsKilled.Encode(e)
		}
	}
	{
		if s.Deaths.Set {
			e.FieldStart("Deaths")
			s.Deaths.Encode(e)
		}
	}
	{
		if s.KillingSprees.Set {
			e.FieldStart("KillingSprees")
			s.KillingSprees.Encode(e)
		}
	}
	{
		if s.MagicDamageTaken.Set {
			e.FieldStart("MagicDamageTaken")
			s.MagicDamageTaken.Encode(e)
		}
	}
	{
		if s.PentaKills.Set {
			e.FieldStart("PentaKills")
			s.PentaKills.Encode(e)
		}
	}
	{
		if s.PhysicalDamageDealtToChampions.Set {
			e.FieldStart("PhysicalDamageDealtToChampions")
			s.PhysicalDamageDealtToChampions.Encode(e)
		}
	}
	{
		if s.TotalDamageDealtToChampions.Set {
			e.FieldStart("TotalDamageDealtToChampions")
			s.TotalDamageDealtToChampions.Encode(e)
		}
	}
	{
		if s.TripleKills.Set {
			e.FieldStart("TripleKills")
			s.TripleKills.Encode(e)
		}
	}
	{
		if s.TrueDamageDealt.Set {
			e.FieldStart("TrueDamageDealt")
			s.TrueDamageDealt.Encode(e)
		}
	}
	{
		if s.TrueDamageTaken.Set {
			e.FieldStart("TrueDamageTaken")
			s.TrueDamageTaken.Encode(e)
		}
	}
}

var jsonFieldsNameOfTftMatchV1ParticipantMissionsDto = [48]string{
	0:  "Assists",
	1:  "DamageDealt",
	2:  "DamageDealtToObjectives",
	3:  "DamageDealtToTurrets",
	4:  "DamageTaken",
	5:  "DoubleKills",
	6:  "GoldEarned",
	7:  "GoldSpent",
	8:  "InhibitorsDestroyed",
	9:  "Kills",
	10: "LargestKillingSpree",
	11: "LargestMultiKill",
	12: "MagicDamageDealt",
	13: "MagicDamageDealtToChampions",
	14: "NeutralMinionsKilledTeamJungle",
	15: "PhysicalDamageDealt",
	16: "PhysicalDamageTaken",
	17: "PlayerScore0",
	18: "PlayerScore1",
	19: "PlayerScore2",
	20: "PlayerScore3",
	21: "PlayerScore4",
	22: "PlayerScore5",
	23: "PlayerScore6",
	24: "PlayerScore9",
	25: "PlayerScore10",
	26: "PlayerScore11",
	27: "QuadraKills",
	28: "Spell1Casts",
	29: "Spell2Casts",
	30: "Spell3Casts",
	31: "Spell4Casts",
	32: "SummonerSpell1Casts",
	33: "TimeCCOthers",
	34: "TotalMinionsKilled",
	35: "TrueDamageDealtToChampions",
	36: "UnrealKills",
	37: "VisionScore",
	38: "WardsKilled",
	39: "Deaths",
	40: "KillingSprees",
	41: "MagicDamageTaken",
	42: "PentaKills",
	43: "PhysicalDamageDealtToChampions",
	44: "TotalDamageDealtToChampions",
	45: "TripleKills",
	46: "TrueDamageDealt",
	47: "TrueDamageTaken",
}

// Decode decodes TftMatchV1ParticipantMissionsDto from json.
func (s *TftMatchV1ParticipantMissionsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftMatchV1ParticipantMissionsDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Assists":
			if err := func() error {
				s.Assists.Reset()
				if err := s.Assists.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Assists\"")
			}
		case "DamageDealt":
			if err := func() error {
				s.DamageDealt.Reset()
				if err := s.DamageDealt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DamageDealt\"")
			}
		case "DamageDealtToObjectives":
			if err := func() error {
				s.DamageDealtToObjectives.Reset()
				if err := s.DamageDealtToObjectives.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DamageDealtToObjectives\"")
			}
		case "DamageDealtToTurrets":
			if err := func() error {
				s.DamageDealtToTurrets.Reset()
				if err := s.DamageDealtToTurrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DamageDealtToTurrets\"")
			}
		case "DamageTaken":
			if err := func() error {
				s.DamageTaken.Reset()
				if err := s.DamageTaken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DamageTaken\"")
			}
		case "DoubleKills":
			if err := func() error {
				s.DoubleKills.Reset()
				if err := s.DoubleKills.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DoubleKills\"")
			}
		case "GoldEarned":
			if err := func() error {
				s.GoldEarned.Reset()
				if err := s.GoldEarned.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"GoldEarned\"")
			}
		case "GoldSpent":
			if err := func() error {
				s.GoldSpent.Reset()
				if err := s.GoldSpent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"GoldSpent\"")
			}
		case "InhibitorsDestroyed":
			if err := func() error {
				s.InhibitorsDestroyed.Reset()
				if err := s.InhibitorsDestroyed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"InhibitorsDestroyed\"")
			}
		case "Kills":
			if err := func() error {
				s.Kills.Reset()
				if err := s.Kills.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Kills\"")
			}
		case "LargestKillingSpree":
			if err := func() error {
				s.LargestKillingSpree.Reset()
				if err := s.LargestKillingSpree.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"LargestKillingSpree\"")
			}
		case "LargestMultiKill":
			if err := func() error {
				s.LargestMultiKill.Reset()
				if err := s.LargestMultiKill.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"LargestMultiKill\"")
			}
		case "MagicDamageDealt":
			if err := func() error {
				s.MagicDamageDealt.Reset()
				if err := s.MagicDamageDealt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MagicDamageDealt\"")
			}
		case "MagicDamageDealtToChampions":
			if err := func() error {
				s.MagicDamageDealtToChampions.Reset()
				if err := s.MagicDamageDealtToChampions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MagicDamageDealtToChampions\"")
			}
		case "NeutralMinionsKilledTeamJungle":
			if err := func() error {
				s.NeutralMinionsKilledTeamJungle.Reset()
				if err := s.NeutralMinionsKilledTeamJungle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"NeutralMinionsKilledTeamJungle\"")
			}
		case "PhysicalDamageDealt":
			if err := func() error {
				s.PhysicalDamageDealt.Reset()
				if err := s.PhysicalDamageDealt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PhysicalDamageDealt\"")
			}
		case "PhysicalDamageTaken":
			if err := func() error {
				s.PhysicalDamageTaken.Reset()
				if err := s.PhysicalDamageTaken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PhysicalDamageTaken\"")
			}
		case "PlayerScore0":
			if err := func() error {
				s.PlayerScore0.Reset()
				if err := s.PlayerScore0.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PlayerScore0\"")
			}
		case "PlayerScore1":
			if err := func() error {
				s.PlayerScore1.Reset()
				if err := s.PlayerScore1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PlayerScore1\"")
			}
		case "PlayerScore2":
			if err := func() error {
				s.PlayerScore2.Reset()
				if err := s.PlayerScore2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PlayerScore2\"")
			}
		case "PlayerScore3":
			if err := func() error {
				s.PlayerScore3.Reset()
				if err := s.PlayerScore3.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PlayerScore3\"")
			}
		case "PlayerScore4":
			if err := func() error {
				s.PlayerScore4.Reset()
				if err := s.PlayerScore4.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PlayerScore4\"")
			}
		case "PlayerScore5":
			if err := func() error {
				s.PlayerScore5.Reset()
				if err := s.PlayerScore5.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PlayerScore5\"")
			}
		case "PlayerScore6":
			if err := func() error {
				s.PlayerScore6.Reset()
				if err := s.PlayerScore6.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PlayerScore6\"")
			}
		case "PlayerScore9":
			if err := func() error {
				s.PlayerScore9.Reset()
				if err := s.PlayerScore9.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PlayerScore9\"")
			}
		case "PlayerScore10":
			if err := func() error {
				s.PlayerScore10.Reset()
				if err := s.PlayerScore10.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PlayerScore10\"")
			}
		case "PlayerScore11":
			if err := func() error {
				s.PlayerScore11.Reset()
				if err := s.PlayerScore11.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PlayerScore11\"")
			}
		case "QuadraKills":
			if err := func() error {
				s.QuadraKills.Reset()
				if err := s.QuadraKills.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"QuadraKills\"")
			}
		case "Spell1Casts":
			if err := func() error {
				s.Spell1Casts.Reset()
				if err := s.Spell1Casts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Spell1Casts\"")
			}
		case "Spell2Casts":
			if err := func() error {
				s.Spell2Casts.Reset()
				if err := s.Spell2Casts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Spell2Casts\"")
			}
		case "Spell3Casts":
			if err := func() error {
				s.Spell3Casts.Reset()
				if err := s.Spell3Casts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Spell3Casts\"")
			}
		case "Spell4Casts":
			if err := func() error {
				s.Spell4Casts.Reset()
				if err := s.Spell4Casts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Spell4Casts\"")
			}
		case "SummonerSpell1Casts":
			if err := func() error {
				s.SummonerSpell1Casts.Reset()
				if err := s.SummonerSpell1Casts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SummonerSpell1Casts\"")
			}
		case "TimeCCOthers":
			if err := func() error {
				s.TimeCCOthers.Reset()
				if err := s.TimeCCOthers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"TimeCCOthers\"")
			}
		case "TotalMinionsKilled":
			if err := func() error {
				s.TotalMinionsKilled.Reset()
				if err := s.TotalMinionsKilled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"TotalMinionsKilled\"")
			}
		case "TrueDamageDealtToChampions":
			if err := func() error {
				s.TrueDamageDealtToChampions.Reset()
				if err := s.TrueDamageDealtToChampions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"TrueDamageDealtToChampions\"")
			}
		case "UnrealKills":
			if err := func() error {
				s.UnrealKills.Reset()
				if err := s.UnrealKills.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"UnrealKills\"")
			}
		case "VisionScore":
			if err := func() error {
				s.VisionScore.Reset()
				if err := s.VisionScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"VisionScore\"")
			}
		case "WardsKilled":
			if err := func() error {
				s.WardsKilled.Reset()
				if err := s.WardsKilled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"WardsKilled\"")
			}
		case "Deaths":
			if err := func() error {
				s.Deaths.Reset()
				if err := s.Deaths.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Deaths\"")
			}
		case "KillingSprees":
			if err := func() error {
				s.KillingSprees.Reset()
				if err := s.KillingSprees.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"KillingSprees\"")
			}
		case "MagicDamageTaken":
			if err := func() error {
				s.MagicDamageTaken.Reset()
				if err := s.MagicDamageTaken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MagicDamageTaken\"")
			}
		case "PentaKills":
			if err := func() error {
				s.PentaKills.Reset()
				if err := s.PentaKills.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PentaKills\"")
			}
		case "PhysicalDamageDealtToChampions":
			if err := func() error {
				s.PhysicalDamageDealtToChampions.Reset()
				if err := s.PhysicalDamageDealtToChampions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PhysicalDamageDealtToChampions\"")
			}
		case "TotalDamageDealtToChampions":
			if err := func() error {
				s.TotalDamageDealtToChampions.Reset()
				if err := s.TotalDamageDealtToChampions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"TotalDamageDealtToChampions\"")
			}
		case "TripleKills":
			if err := func() error {
				s.TripleKills.Reset()
				if err := s.TripleKills.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"TripleKills\"")
			}
		case "TrueDamageDealt":
			if err := func() error {
				s.TrueDamageDealt.Reset()
				if err := s.TrueDamageDealt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"TrueDamageDealt\"")
			}
		case "TrueDamageTaken":
			if err := func() error {
				s.TrueDamageTaken.Reset()
				if err := s.TrueDamageTaken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"TrueDamageTaken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TftMatchV1ParticipantMissionsDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TftMatchV1ParticipantMissionsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftMatchV1ParticipantMissionsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TftMatchV1TraitDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TftMatchV1TraitDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("num_units")
		e.Int32(s.NumUnits)
	}
	{
		if s.Style.Set {
			e.FieldStart("style")
			s.Style.Encode(e)
		}
	}
	{
		e.FieldStart("tier_current")
		e.Int32(s.TierCurrent)
	}
	{
		if s.TierTotal.Set {
			e.FieldStart("tier_total")
			s.TierTotal.Encode(e)
		}
	}
}

var jsonFieldsNameOfTftMatchV1TraitDto = [5]string{
	0: "name",
	1: "num_units",
	2: "style",
	3: "tier_current",
	4: "tier_total",
}

// Decode decodes TftMatchV1TraitDto from json.
func (s *TftMatchV1TraitDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftMatchV1TraitDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "num_units":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.NumUnits = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"num_units\"")
			}
		case "style":
			if err := func() error {
				s.Style.Reset()
				if err := s.Style.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"style\"")
			}
		case "tier_current":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.TierCurrent = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier_current\"")
			}
		case "tier_total":
			if err := func() error {
				s.TierTotal.Reset()
				if err := s.TierTotal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier_total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TftMatchV1TraitDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTftMatchV1TraitDto) {
					name = jsonFieldsNameOfTftMatchV1TraitDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TftMatchV1TraitDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftMatchV1TraitDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TftMatchV1UnitDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TftMatchV1UnitDto) encodeFields(e *jx.Encoder) {
	{
		if s.Items != nil {
			e.FieldStart("items")
			e.ArrStart()
			for _, elem := range s.Items {
				e.Int32(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("character_id")
		e.Str(s.CharacterID)
	}
	{
		if s.ItemNames != nil {
			e.FieldStart("itemNames")
			e.ArrStart()
			for _, elem := range s.ItemNames {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Chosen.Set {
			e.FieldStart("chosen")
			s.Chosen.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("rarity")
		e.Int32(s.Rarity)
	}
	{
		e.FieldStart("tier")
		e.Int32(s.Tier)
	}
}

var jsonFieldsNameOfTftMatchV1UnitDto = [7]string{
	0: "items",
	1: "character_id",
	2: "itemNames",
	3: "chosen",
	4: "name",
	5: "rarity",
	6: "tier",
}

// Decode decodes TftMatchV1UnitDto from json.
func (s *TftMatchV1UnitDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftMatchV1UnitDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			if err := func() error {
				s.Items = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int32
					v, err := d.Int32()
					elem = int32(v)
					if err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "character_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CharacterID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_id\"")
			}
		case "itemNames":
			if err := func() error {
				s.ItemNames = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ItemNames = append(s.ItemNames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"itemNames\"")
			}
		case "chosen":
			if err := func() error {
				s.Chosen.Reset()
				if err := s.Chosen.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chosen\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "rarity":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.Rarity = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rarity\"")
			}
		case "tier":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.Tier = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TftMatchV1UnitDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01110010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTftMatchV1UnitDto) {
					name = jsonFieldsNameOfTftMatchV1UnitDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TftMatchV1UnitDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftMatchV1UnitDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TftStatusV1ContentDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TftStatusV1ContentDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("locale")
		e.Str(s.Locale)
	}
	{
		e.FieldStart("content")
		e.Str(s.Content)
	}
}

var jsonFieldsNameOfTftStatusV1ContentDto = [2]string{
	0: "locale",
	1: "content",
}

// Decode decodes TftStatusV1ContentDto from json.
func (s *TftStatusV1ContentDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftStatusV1ContentDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "locale":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Locale = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locale\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TftStatusV1ContentDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTftStatusV1ContentDto) {
					name = jsonFieldsNameOfTftStatusV1ContentDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TftStatusV1ContentDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftStatusV1ContentDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TftStatusV1PlatformDataDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TftStatusV1PlatformDataDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("locales")
		e.ArrStart()
		for _, elem := range s.Locales {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("maintenances")
		e.ArrStart()
		for _, elem := range s.Maintenances {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("incidents")
		e.ArrStart()
		for _, elem := range s.Incidents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfTftStatusV1PlatformDataDto = [5]string{
	0: "id",
	1: "name",
	2: "locales",
	3: "maintenances",
	4: "incidents",
}

// Decode decodes TftStatusV1PlatformDataDto from json.
func (s *TftStatusV1PlatformDataDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftStatusV1PlatformDataDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "locales":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Locales = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Locales = append(s.Locales, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locales\"")
			}
		case "maintenances":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Maintenances = make([]TftStatusV1StatusDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TftStatusV1StatusDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Maintenances = append(s.Maintenances, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenances\"")
			}
		case "incidents":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Incidents = make([]TftStatusV1StatusDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TftStatusV1StatusDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Incidents = append(s.Incidents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incidents\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TftStatusV1PlatformDataDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTftStatusV1PlatformDataDto) {
					name = jsonFieldsNameOfTftStatusV1PlatformDataDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TftStatusV1PlatformDataDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftStatusV1PlatformDataDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TftStatusV1StatusDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TftStatusV1StatusDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int32(s.ID)
	}
	{
		e.FieldStart("maintenance_status")
		s.MaintenanceStatus.Encode(e)
	}
	{
		e.FieldStart("incident_severity")
		s.IncidentSeverity.Encode(e)
	}
	{
		e.FieldStart("titles")
		e.ArrStart()
		for _, elem := range s.Titles {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("updates")
		e.ArrStart()
		for _, elem := range s.Updates {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("created_at")
		e.Str(s.CreatedAt)
	}
	{
		e.FieldStart("archive_at")
		e.Str(s.ArchiveAt)
	}
	{
		e.FieldStart("updated_at")
		e.Str(s.UpdatedAt)
	}
	{
		e.FieldStart("platforms")
		e.ArrStart()
		for _, elem := range s.Platforms {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfTftStatusV1StatusDto = [9]string{
	0: "id",
	1: "maintenance_status",
	2: "incident_severity",
	3: "titles",
	4: "updates",
	5: "created_at",
	6: "archive_at",
	7: "updated_at",
	8: "platforms",
}

// Decode decodes TftStatusV1StatusDto from json.
func (s *TftStatusV1StatusDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftStatusV1StatusDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ID = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "maintenance_status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.MaintenanceStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenance_status\"")
			}
		case "incident_severity":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.IncidentSeverity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incident_severity\"")
			}
		case "titles":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Titles = make([]TftStatusV1ContentDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TftStatusV1ContentDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Titles = append(s.Titles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"titles\"")
			}
		case "updates":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Updates = make([]TftStatusV1UpdateDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TftStatusV1UpdateDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Updates = append(s.Updates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updates\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "archive_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ArchiveAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "platforms":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.Platforms = make([]TftStatusV1StatusDtoPlatformsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TftStatusV1StatusDtoPlatformsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Platforms = append(s.Platforms, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platforms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TftStatusV1StatusDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTftStatusV1StatusDto) {
					name = jsonFieldsNameOfTftStatusV1StatusDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TftStatusV1StatusDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftStatusV1StatusDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TftStatusV1StatusDtoIncidentSeverity as json.
func (s TftStatusV1StatusDtoIncidentSeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TftStatusV1StatusDtoIncidentSeverity from json.
func (s *TftStatusV1StatusDtoIncidentSeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftStatusV1StatusDtoIncidentSeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TftStatusV1StatusDtoIncidentSeverity(v) {
	case TftStatusV1StatusDtoIncidentSeverityInfo:
		*s = TftStatusV1StatusDtoIncidentSeverityInfo
	case TftStatusV1StatusDtoIncidentSeverityWarning:
		*s = TftStatusV1StatusDtoIncidentSeverityWarning
	case TftStatusV1StatusDtoIncidentSeverityCritical:
		*s = TftStatusV1StatusDtoIncidentSeverityCritical
	default:
		*s = TftStatusV1StatusDtoIncidentSeverity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TftStatusV1StatusDtoIncidentSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftStatusV1StatusDtoIncidentSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TftStatusV1StatusDtoMaintenanceStatus as json.
func (s TftStatusV1StatusDtoMaintenanceStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TftStatusV1StatusDtoMaintenanceStatus from json.
func (s *TftStatusV1StatusDtoMaintenanceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftStatusV1StatusDtoMaintenanceStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TftStatusV1StatusDtoMaintenanceStatus(v) {
	case TftStatusV1StatusDtoMaintenanceStatusScheduled:
		*s = TftStatusV1StatusDtoMaintenanceStatusScheduled
	case TftStatusV1StatusDtoMaintenanceStatusInProgress:
		*s = TftStatusV1StatusDtoMaintenanceStatusInProgress
	case TftStatusV1StatusDtoMaintenanceStatusComplete:
		*s = TftStatusV1StatusDtoMaintenanceStatusComplete
	default:
		*s = TftStatusV1StatusDtoMaintenanceStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TftStatusV1StatusDtoMaintenanceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftStatusV1StatusDtoMaintenanceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TftStatusV1StatusDtoPlatformsItem as json.
func (s TftStatusV1StatusDtoPlatformsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TftStatusV1StatusDtoPlatformsItem from json.
func (s *TftStatusV1StatusDtoPlatformsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftStatusV1StatusDtoPlatformsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TftStatusV1StatusDtoPlatformsItem(v) {
	case TftStatusV1StatusDtoPlatformsItemWindows:
		*s = TftStatusV1StatusDtoPlatformsItemWindows
	case TftStatusV1StatusDtoPlatformsItemMacos:
		*s = TftStatusV1StatusDtoPlatformsItemMacos
	case TftStatusV1StatusDtoPlatformsItemAndroid:
		*s = TftStatusV1StatusDtoPlatformsItemAndroid
	case TftStatusV1StatusDtoPlatformsItemIos:
		*s = TftStatusV1StatusDtoPlatformsItemIos
	case TftStatusV1StatusDtoPlatformsItemPs4:
		*s = TftStatusV1StatusDtoPlatformsItemPs4
	case TftStatusV1StatusDtoPlatformsItemXbone:
		*s = TftStatusV1StatusDtoPlatformsItemXbone
	case TftStatusV1StatusDtoPlatformsItemSwitch:
		*s = TftStatusV1StatusDtoPlatformsItemSwitch
	default:
		*s = TftStatusV1StatusDtoPlatformsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TftStatusV1StatusDtoPlatformsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftStatusV1StatusDtoPlatformsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TftStatusV1UpdateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TftStatusV1UpdateDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int32(s.ID)
	}
	{
		e.FieldStart("author")
		e.Str(s.Author)
	}
	{
		e.FieldStart("publish")
		e.Bool(s.Publish)
	}
	{
		e.FieldStart("publish_locations")
		e.ArrStart()
		for _, elem := range s.PublishLocations {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("translations")
		e.ArrStart()
		for _, elem := range s.Translations {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("created_at")
		e.Str(s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		e.Str(s.UpdatedAt)
	}
}

var jsonFieldsNameOfTftStatusV1UpdateDto = [7]string{
	0: "id",
	1: "author",
	2: "publish",
	3: "publish_locations",
	4: "translations",
	5: "created_at",
	6: "updated_at",
}

// Decode decodes TftStatusV1UpdateDto from json.
func (s *TftStatusV1UpdateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftStatusV1UpdateDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ID = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "author":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Author = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "publish":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Publish = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publish\"")
			}
		case "publish_locations":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.PublishLocations = make([]TftStatusV1UpdateDtoPublishLocationsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TftStatusV1UpdateDtoPublishLocationsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PublishLocations = append(s.PublishLocations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publish_locations\"")
			}
		case "translations":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Translations = make([]TftStatusV1ContentDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TftStatusV1ContentDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Translations = append(s.Translations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"translations\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TftStatusV1UpdateDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTftStatusV1UpdateDto) {
					name = jsonFieldsNameOfTftStatusV1UpdateDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TftStatusV1UpdateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftStatusV1UpdateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TftStatusV1UpdateDtoPublishLocationsItem as json.
func (s TftStatusV1UpdateDtoPublishLocationsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TftStatusV1UpdateDtoPublishLocationsItem from json.
func (s *TftStatusV1UpdateDtoPublishLocationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftStatusV1UpdateDtoPublishLocationsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TftStatusV1UpdateDtoPublishLocationsItem(v) {
	case TftStatusV1UpdateDtoPublishLocationsItemRiotclient:
		*s = TftStatusV1UpdateDtoPublishLocationsItemRiotclient
	case TftStatusV1UpdateDtoPublishLocationsItemRiotstatus:
		*s = TftStatusV1UpdateDtoPublishLocationsItemRiotstatus
	case TftStatusV1UpdateDtoPublishLocationsItemGame:
		*s = TftStatusV1UpdateDtoPublishLocationsItemGame
	default:
		*s = TftStatusV1UpdateDtoPublishLocationsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TftStatusV1UpdateDtoPublishLocationsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftStatusV1UpdateDtoPublishLocationsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TftSummonerV1SummonerDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TftSummonerV1SummonerDTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		e.FieldStart("profileIconId")
		e.Int32(s.ProfileIconId)
	}
	{
		e.FieldStart("revisionDate")
		e.Int64(s.RevisionDate)
	}
	{
		e.FieldStart("summonerLevel")
		e.Int64(s.SummonerLevel)
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
}

var jsonFieldsNameOfTftSummonerV1SummonerDTO = [5]string{
	0: "puuid",
	1: "profileIconId",
	2: "revisionDate",
	3: "summonerLevel",
	4: "id",
}

// Decode decodes TftSummonerV1SummonerDTO from json.
func (s *TftSummonerV1SummonerDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TftSummonerV1SummonerDTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "puuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "profileIconId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.ProfileIconId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileIconId\"")
			}
		case "revisionDate":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.RevisionDate = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"revisionDate\"")
			}
		case "summonerLevel":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int64()
				s.SummonerLevel = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summonerLevel\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TftSummonerV1SummonerDTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTftSummonerV1SummonerDTO) {
					name = jsonFieldsNameOfTftSummonerV1SummonerDTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TftSummonerV1SummonerDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TftSummonerV1SummonerDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TournamentStubV5CreateTournamentCodeOKApplicationJSON as json.
func (s TournamentStubV5CreateTournamentCodeOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []string(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes TournamentStubV5CreateTournamentCodeOKApplicationJSON from json.
func (s *TournamentStubV5CreateTournamentCodeOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentStubV5CreateTournamentCodeOKApplicationJSON to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TournamentStubV5CreateTournamentCodeOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TournamentStubV5CreateTournamentCodeOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentStubV5CreateTournamentCodeOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TournamentStubV5LobbyEventV5DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TournamentStubV5LobbyEventV5DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("timestamp")
		e.Str(s.Timestamp)
	}
	{
		e.FieldStart("eventType")
		e.Str(s.EventType)
	}
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
}

var jsonFieldsNameOfTournamentStubV5LobbyEventV5DTO = [3]string{
	0: "timestamp",
	1: "eventType",
	2: "puuid",
}

// Decode decodes TournamentStubV5LobbyEventV5DTO from json.
func (s *TournamentStubV5LobbyEventV5DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentStubV5LobbyEventV5DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Timestamp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "eventType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EventType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventType\"")
			}
		case "puuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TournamentStubV5LobbyEventV5DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTournamentStubV5LobbyEventV5DTO) {
					name = jsonFieldsNameOfTournamentStubV5LobbyEventV5DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TournamentStubV5LobbyEventV5DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentStubV5LobbyEventV5DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TournamentStubV5LobbyEventV5DTOWrapper) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TournamentStubV5LobbyEventV5DTOWrapper) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventList")
		e.ArrStart()
		for _, elem := range s.EventList {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfTournamentStubV5LobbyEventV5DTOWrapper = [1]string{
	0: "eventList",
}

// Decode decodes TournamentStubV5LobbyEventV5DTOWrapper from json.
func (s *TournamentStubV5LobbyEventV5DTOWrapper) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentStubV5LobbyEventV5DTOWrapper to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventList":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.EventList = make([]TournamentStubV5LobbyEventV5DTO, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TournamentStubV5LobbyEventV5DTO
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.EventList = append(s.EventList, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventList\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TournamentStubV5LobbyEventV5DTOWrapper")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTournamentStubV5LobbyEventV5DTOWrapper) {
					name = jsonFieldsNameOfTournamentStubV5LobbyEventV5DTOWrapper[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TournamentStubV5LobbyEventV5DTOWrapper) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentStubV5LobbyEventV5DTOWrapper) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TournamentStubV5ProviderRegistrationParametersV5) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TournamentStubV5ProviderRegistrationParametersV5) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("region")
		s.Region.Encode(e)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
}

var jsonFieldsNameOfTournamentStubV5ProviderRegistrationParametersV5 = [2]string{
	0: "region",
	1: "url",
}

// Decode decodes TournamentStubV5ProviderRegistrationParametersV5 from json.
func (s *TournamentStubV5ProviderRegistrationParametersV5) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentStubV5ProviderRegistrationParametersV5 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "region":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TournamentStubV5ProviderRegistrationParametersV5")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTournamentStubV5ProviderRegistrationParametersV5) {
					name = jsonFieldsNameOfTournamentStubV5ProviderRegistrationParametersV5[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TournamentStubV5ProviderRegistrationParametersV5) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentStubV5ProviderRegistrationParametersV5) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TournamentStubV5ProviderRegistrationParametersV5Region as json.
func (s TournamentStubV5ProviderRegistrationParametersV5Region) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TournamentStubV5ProviderRegistrationParametersV5Region from json.
func (s *TournamentStubV5ProviderRegistrationParametersV5Region) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentStubV5ProviderRegistrationParametersV5Region to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TournamentStubV5ProviderRegistrationParametersV5Region(v) {
	case TournamentStubV5ProviderRegistrationParametersV5RegionBR:
		*s = TournamentStubV5ProviderRegistrationParametersV5RegionBR
	case TournamentStubV5ProviderRegistrationParametersV5RegionEUNE:
		*s = TournamentStubV5ProviderRegistrationParametersV5RegionEUNE
	case TournamentStubV5ProviderRegistrationParametersV5RegionEUW:
		*s = TournamentStubV5ProviderRegistrationParametersV5RegionEUW
	case TournamentStubV5ProviderRegistrationParametersV5RegionJP:
		*s = TournamentStubV5ProviderRegistrationParametersV5RegionJP
	case TournamentStubV5ProviderRegistrationParametersV5RegionLAN:
		*s = TournamentStubV5ProviderRegistrationParametersV5RegionLAN
	case TournamentStubV5ProviderRegistrationParametersV5RegionLAS:
		*s = TournamentStubV5ProviderRegistrationParametersV5RegionLAS
	case TournamentStubV5ProviderRegistrationParametersV5RegionNA:
		*s = TournamentStubV5ProviderRegistrationParametersV5RegionNA
	case TournamentStubV5ProviderRegistrationParametersV5RegionOCE:
		*s = TournamentStubV5ProviderRegistrationParametersV5RegionOCE
	case TournamentStubV5ProviderRegistrationParametersV5RegionPBE:
		*s = TournamentStubV5ProviderRegistrationParametersV5RegionPBE
	case TournamentStubV5ProviderRegistrationParametersV5RegionRU:
		*s = TournamentStubV5ProviderRegistrationParametersV5RegionRU
	case TournamentStubV5ProviderRegistrationParametersV5RegionTR:
		*s = TournamentStubV5ProviderRegistrationParametersV5RegionTR
	case TournamentStubV5ProviderRegistrationParametersV5RegionKR:
		*s = TournamentStubV5ProviderRegistrationParametersV5RegionKR
	default:
		*s = TournamentStubV5ProviderRegistrationParametersV5Region(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TournamentStubV5ProviderRegistrationParametersV5Region) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentStubV5ProviderRegistrationParametersV5Region) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TournamentStubV5RegisterProviderDataOKApplicationJSON as json.
func (s TournamentStubV5RegisterProviderDataOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := int32(s)

	e.Int32(unwrapped)
}

// Decode decodes TournamentStubV5RegisterProviderDataOKApplicationJSON from json.
func (s *TournamentStubV5RegisterProviderDataOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentStubV5RegisterProviderDataOKApplicationJSON to nil")
	}
	var unwrapped int32
	if err := func() error {
		v, err := d.Int32()
		unwrapped = int32(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TournamentStubV5RegisterProviderDataOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TournamentStubV5RegisterProviderDataOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentStubV5RegisterProviderDataOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TournamentStubV5RegisterTournamentOKApplicationJSON as json.
func (s TournamentStubV5RegisterTournamentOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := int32(s)

	e.Int32(unwrapped)
}

// Decode decodes TournamentStubV5RegisterTournamentOKApplicationJSON from json.
func (s *TournamentStubV5RegisterTournamentOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentStubV5RegisterTournamentOKApplicationJSON to nil")
	}
	var unwrapped int32
	if err := func() error {
		v, err := d.Int32()
		unwrapped = int32(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TournamentStubV5RegisterTournamentOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TournamentStubV5RegisterTournamentOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentStubV5RegisterTournamentOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TournamentStubV5TournamentCodeParametersV5) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TournamentStubV5TournamentCodeParametersV5) encodeFields(e *jx.Encoder) {
	{
		if s.AllowedParticipants != nil {
			e.FieldStart("allowedParticipants")
			e.ArrStart()
			for _, elem := range s.AllowedParticipants {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("teamSize")
		e.Int32(s.TeamSize)
	}
	{
		e.FieldStart("pickType")
		s.PickType.Encode(e)
	}
	{
		e.FieldStart("mapType")
		s.MapType.Encode(e)
	}
	{
		e.FieldStart("spectatorType")
		s.SpectatorType.Encode(e)
	}
	{
		e.FieldStart("enoughPlayers")
		e.Bool(s.EnoughPlayers)
	}
}

var jsonFieldsNameOfTournamentStubV5TournamentCodeParametersV5 = [7]string{
	0: "allowedParticipants",
	1: "metadata",
	2: "teamSize",
	3: "pickType",
	4: "mapType",
	5: "spectatorType",
	6: "enoughPlayers",
}

// Decode decodes TournamentStubV5TournamentCodeParametersV5 from json.
func (s *TournamentStubV5TournamentCodeParametersV5) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentStubV5TournamentCodeParametersV5 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowedParticipants":
			if err := func() error {
				s.AllowedParticipants = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedParticipants = append(s.AllowedParticipants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedParticipants\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "teamSize":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.TeamSize = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamSize\"")
			}
		case "pickType":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.PickType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pickType\"")
			}
		case "mapType":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.MapType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mapType\"")
			}
		case "spectatorType":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.SpectatorType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spectatorType\"")
			}
		case "enoughPlayers":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.EnoughPlayers = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enoughPlayers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TournamentStubV5TournamentCodeParametersV5")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTournamentStubV5TournamentCodeParametersV5) {
					name = jsonFieldsNameOfTournamentStubV5TournamentCodeParametersV5[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TournamentStubV5TournamentCodeParametersV5) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentStubV5TournamentCodeParametersV5) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TournamentStubV5TournamentCodeParametersV5MapType as json.
func (s TournamentStubV5TournamentCodeParametersV5MapType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TournamentStubV5TournamentCodeParametersV5MapType from json.
func (s *TournamentStubV5TournamentCodeParametersV5MapType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentStubV5TournamentCodeParametersV5MapType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TournamentStubV5TournamentCodeParametersV5MapType(v) {
	case TournamentStubV5TournamentCodeParametersV5MapTypeSUMMONERSRIFT:
		*s = TournamentStubV5TournamentCodeParametersV5MapTypeSUMMONERSRIFT
	case TournamentStubV5TournamentCodeParametersV5MapTypeHOWLINGABYSS:
		*s = TournamentStubV5TournamentCodeParametersV5MapTypeHOWLINGABYSS
	default:
		*s = TournamentStubV5TournamentCodeParametersV5MapType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TournamentStubV5TournamentCodeParametersV5MapType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentStubV5TournamentCodeParametersV5MapType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TournamentStubV5TournamentCodeParametersV5PickType as json.
func (s TournamentStubV5TournamentCodeParametersV5PickType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TournamentStubV5TournamentCodeParametersV5PickType from json.
func (s *TournamentStubV5TournamentCodeParametersV5PickType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentStubV5TournamentCodeParametersV5PickType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TournamentStubV5TournamentCodeParametersV5PickType(v) {
	case TournamentStubV5TournamentCodeParametersV5PickTypeBLINDPICK:
		*s = TournamentStubV5TournamentCodeParametersV5PickTypeBLINDPICK
	case TournamentStubV5TournamentCodeParametersV5PickTypeDRAFTMODE:
		*s = TournamentStubV5TournamentCodeParametersV5PickTypeDRAFTMODE
	case TournamentStubV5TournamentCodeParametersV5PickTypeALLRANDOM:
		*s = TournamentStubV5TournamentCodeParametersV5PickTypeALLRANDOM
	case TournamentStubV5TournamentCodeParametersV5PickTypeTOURNAMENTDRAFT:
		*s = TournamentStubV5TournamentCodeParametersV5PickTypeTOURNAMENTDRAFT
	default:
		*s = TournamentStubV5TournamentCodeParametersV5PickType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TournamentStubV5TournamentCodeParametersV5PickType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentStubV5TournamentCodeParametersV5PickType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TournamentStubV5TournamentCodeParametersV5SpectatorType as json.
func (s TournamentStubV5TournamentCodeParametersV5SpectatorType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TournamentStubV5TournamentCodeParametersV5SpectatorType from json.
func (s *TournamentStubV5TournamentCodeParametersV5SpectatorType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentStubV5TournamentCodeParametersV5SpectatorType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TournamentStubV5TournamentCodeParametersV5SpectatorType(v) {
	case TournamentStubV5TournamentCodeParametersV5SpectatorTypeNONE:
		*s = TournamentStubV5TournamentCodeParametersV5SpectatorTypeNONE
	case TournamentStubV5TournamentCodeParametersV5SpectatorTypeLOBBYONLY:
		*s = TournamentStubV5TournamentCodeParametersV5SpectatorTypeLOBBYONLY
	case TournamentStubV5TournamentCodeParametersV5SpectatorTypeALL:
		*s = TournamentStubV5TournamentCodeParametersV5SpectatorTypeALL
	default:
		*s = TournamentStubV5TournamentCodeParametersV5SpectatorType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TournamentStubV5TournamentCodeParametersV5SpectatorType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentStubV5TournamentCodeParametersV5SpectatorType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TournamentStubV5TournamentCodeV5DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TournamentStubV5TournamentCodeV5DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("lobbyName")
		e.Str(s.LobbyName)
	}
	{
		e.FieldStart("metaData")
		e.Str(s.MetaData)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
	{
		e.FieldStart("teamSize")
		e.Int32(s.TeamSize)
	}
	{
		e.FieldStart("providerId")
		e.Int32(s.ProviderId)
	}
	{
		e.FieldStart("pickType")
		e.Str(s.PickType)
	}
	{
		e.FieldStart("tournamentId")
		e.Int32(s.TournamentId)
	}
	{
		e.FieldStart("id")
		e.Int32(s.ID)
	}
	{
		e.FieldStart("region")
		s.Region.Encode(e)
	}
	{
		e.FieldStart("map")
		e.Str(s.Map)
	}
	{
		e.FieldStart("participants")
		e.ArrStart()
		for _, elem := range s.Participants {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfTournamentStubV5TournamentCodeV5DTO = [12]string{
	0:  "code",
	1:  "lobbyName",
	2:  "metaData",
	3:  "password",
	4:  "teamSize",
	5:  "providerId",
	6:  "pickType",
	7:  "tournamentId",
	8:  "id",
	9:  "region",
	10: "map",
	11: "participants",
}

// Decode decodes TournamentStubV5TournamentCodeV5DTO from json.
func (s *TournamentStubV5TournamentCodeV5DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentStubV5TournamentCodeV5DTO to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "lobbyName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LobbyName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lobbyName\"")
			}
		case "metaData":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.MetaData = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metaData\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "teamSize":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.TeamSize = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamSize\"")
			}
		case "providerId":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.ProviderId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerId\"")
			}
		case "pickType":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.PickType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pickType\"")
			}
		case "tournamentId":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.TournamentId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tournamentId\"")
			}
		case "id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ID = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "region":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "map":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Map = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"map\"")
			}
		case "participants":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				s.Participants = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Participants = append(s.Participants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participants\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TournamentStubV5TournamentCodeV5DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTournamentStubV5TournamentCodeV5DTO) {
					name = jsonFieldsNameOfTournamentStubV5TournamentCodeV5DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TournamentStubV5TournamentCodeV5DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentStubV5TournamentCodeV5DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TournamentStubV5TournamentCodeV5DTORegion as json.
func (s TournamentStubV5TournamentCodeV5DTORegion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TournamentStubV5TournamentCodeV5DTORegion from json.
func (s *TournamentStubV5TournamentCodeV5DTORegion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentStubV5TournamentCodeV5DTORegion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TournamentStubV5TournamentCodeV5DTORegion(v) {
	case TournamentStubV5TournamentCodeV5DTORegionBR:
		*s = TournamentStubV5TournamentCodeV5DTORegionBR
	case TournamentStubV5TournamentCodeV5DTORegionEUNE:
		*s = TournamentStubV5TournamentCodeV5DTORegionEUNE
	case TournamentStubV5TournamentCodeV5DTORegionEUW:
		*s = TournamentStubV5TournamentCodeV5DTORegionEUW
	case TournamentStubV5TournamentCodeV5DTORegionJP:
		*s = TournamentStubV5TournamentCodeV5DTORegionJP
	case TournamentStubV5TournamentCodeV5DTORegionLAN:
		*s = TournamentStubV5TournamentCodeV5DTORegionLAN
	case TournamentStubV5TournamentCodeV5DTORegionLAS:
		*s = TournamentStubV5TournamentCodeV5DTORegionLAS
	case TournamentStubV5TournamentCodeV5DTORegionNA:
		*s = TournamentStubV5TournamentCodeV5DTORegionNA
	case TournamentStubV5TournamentCodeV5DTORegionOCE:
		*s = TournamentStubV5TournamentCodeV5DTORegionOCE
	case TournamentStubV5TournamentCodeV5DTORegionPBE:
		*s = TournamentStubV5TournamentCodeV5DTORegionPBE
	case TournamentStubV5TournamentCodeV5DTORegionRU:
		*s = TournamentStubV5TournamentCodeV5DTORegionRU
	case TournamentStubV5TournamentCodeV5DTORegionTR:
		*s = TournamentStubV5TournamentCodeV5DTORegionTR
	case TournamentStubV5TournamentCodeV5DTORegionKR:
		*s = TournamentStubV5TournamentCodeV5DTORegionKR
	default:
		*s = TournamentStubV5TournamentCodeV5DTORegion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TournamentStubV5TournamentCodeV5DTORegion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentStubV5TournamentCodeV5DTORegion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TournamentStubV5TournamentRegistrationParametersV5) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TournamentStubV5TournamentRegistrationParametersV5) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("providerId")
		e.Int32(s.ProviderId)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfTournamentStubV5TournamentRegistrationParametersV5 = [2]string{
	0: "providerId",
	1: "name",
}

// Decode decodes TournamentStubV5TournamentRegistrationParametersV5 from json.
func (s *TournamentStubV5TournamentRegistrationParametersV5) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentStubV5TournamentRegistrationParametersV5 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "providerId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ProviderId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerId\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TournamentStubV5TournamentRegistrationParametersV5")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTournamentStubV5TournamentRegistrationParametersV5) {
					name = jsonFieldsNameOfTournamentStubV5TournamentRegistrationParametersV5[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TournamentStubV5TournamentRegistrationParametersV5) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentStubV5TournamentRegistrationParametersV5) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TournamentV5CreateTournamentCodeOKApplicationJSON as json.
func (s TournamentV5CreateTournamentCodeOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []string(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes TournamentV5CreateTournamentCodeOKApplicationJSON from json.
func (s *TournamentV5CreateTournamentCodeOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentV5CreateTournamentCodeOKApplicationJSON to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TournamentV5CreateTournamentCodeOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TournamentV5CreateTournamentCodeOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentV5CreateTournamentCodeOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TournamentV5GetGamesOKApplicationJSON as json.
func (s TournamentV5GetGamesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []TournamentV5TournamentGamesV5(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes TournamentV5GetGamesOKApplicationJSON from json.
func (s *TournamentV5GetGamesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentV5GetGamesOKApplicationJSON to nil")
	}
	var unwrapped []TournamentV5TournamentGamesV5
	if err := func() error {
		unwrapped = make([]TournamentV5TournamentGamesV5, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem TournamentV5TournamentGamesV5
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TournamentV5GetGamesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TournamentV5GetGamesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentV5GetGamesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TournamentV5LobbyEventV5DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TournamentV5LobbyEventV5DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("timestamp")
		e.Str(s.Timestamp)
	}
	{
		e.FieldStart("eventType")
		e.Str(s.EventType)
	}
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
}

var jsonFieldsNameOfTournamentV5LobbyEventV5DTO = [3]string{
	0: "timestamp",
	1: "eventType",
	2: "puuid",
}

// Decode decodes TournamentV5LobbyEventV5DTO from json.
func (s *TournamentV5LobbyEventV5DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentV5LobbyEventV5DTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Timestamp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "eventType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EventType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventType\"")
			}
		case "puuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TournamentV5LobbyEventV5DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTournamentV5LobbyEventV5DTO) {
					name = jsonFieldsNameOfTournamentV5LobbyEventV5DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TournamentV5LobbyEventV5DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentV5LobbyEventV5DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TournamentV5LobbyEventV5DTOWrapper) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TournamentV5LobbyEventV5DTOWrapper) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventList")
		e.ArrStart()
		for _, elem := range s.EventList {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfTournamentV5LobbyEventV5DTOWrapper = [1]string{
	0: "eventList",
}

// Decode decodes TournamentV5LobbyEventV5DTOWrapper from json.
func (s *TournamentV5LobbyEventV5DTOWrapper) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentV5LobbyEventV5DTOWrapper to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventList":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.EventList = make([]TournamentV5LobbyEventV5DTO, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TournamentV5LobbyEventV5DTO
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.EventList = append(s.EventList, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventList\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TournamentV5LobbyEventV5DTOWrapper")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTournamentV5LobbyEventV5DTOWrapper) {
					name = jsonFieldsNameOfTournamentV5LobbyEventV5DTOWrapper[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TournamentV5LobbyEventV5DTOWrapper) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentV5LobbyEventV5DTOWrapper) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TournamentV5ProviderRegistrationParametersV5) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TournamentV5ProviderRegistrationParametersV5) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("region")
		s.Region.Encode(e)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
}

var jsonFieldsNameOfTournamentV5ProviderRegistrationParametersV5 = [2]string{
	0: "region",
	1: "url",
}

// Decode decodes TournamentV5ProviderRegistrationParametersV5 from json.
func (s *TournamentV5ProviderRegistrationParametersV5) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentV5ProviderRegistrationParametersV5 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "region":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TournamentV5ProviderRegistrationParametersV5")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTournamentV5ProviderRegistrationParametersV5) {
					name = jsonFieldsNameOfTournamentV5ProviderRegistrationParametersV5[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TournamentV5ProviderRegistrationParametersV5) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentV5ProviderRegistrationParametersV5) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TournamentV5ProviderRegistrationParametersV5Region as json.
func (s TournamentV5ProviderRegistrationParametersV5Region) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TournamentV5ProviderRegistrationParametersV5Region from json.
func (s *TournamentV5ProviderRegistrationParametersV5Region) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentV5ProviderRegistrationParametersV5Region to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TournamentV5ProviderRegistrationParametersV5Region(v) {
	case TournamentV5ProviderRegistrationParametersV5RegionBR:
		*s = TournamentV5ProviderRegistrationParametersV5RegionBR
	case TournamentV5ProviderRegistrationParametersV5RegionEUNE:
		*s = TournamentV5ProviderRegistrationParametersV5RegionEUNE
	case TournamentV5ProviderRegistrationParametersV5RegionEUW:
		*s = TournamentV5ProviderRegistrationParametersV5RegionEUW
	case TournamentV5ProviderRegistrationParametersV5RegionJP:
		*s = TournamentV5ProviderRegistrationParametersV5RegionJP
	case TournamentV5ProviderRegistrationParametersV5RegionLAN:
		*s = TournamentV5ProviderRegistrationParametersV5RegionLAN
	case TournamentV5ProviderRegistrationParametersV5RegionLAS:
		*s = TournamentV5ProviderRegistrationParametersV5RegionLAS
	case TournamentV5ProviderRegistrationParametersV5RegionNA:
		*s = TournamentV5ProviderRegistrationParametersV5RegionNA
	case TournamentV5ProviderRegistrationParametersV5RegionOCE:
		*s = TournamentV5ProviderRegistrationParametersV5RegionOCE
	case TournamentV5ProviderRegistrationParametersV5RegionPBE:
		*s = TournamentV5ProviderRegistrationParametersV5RegionPBE
	case TournamentV5ProviderRegistrationParametersV5RegionRU:
		*s = TournamentV5ProviderRegistrationParametersV5RegionRU
	case TournamentV5ProviderRegistrationParametersV5RegionTR:
		*s = TournamentV5ProviderRegistrationParametersV5RegionTR
	case TournamentV5ProviderRegistrationParametersV5RegionKR:
		*s = TournamentV5ProviderRegistrationParametersV5RegionKR
	case TournamentV5ProviderRegistrationParametersV5RegionPH:
		*s = TournamentV5ProviderRegistrationParametersV5RegionPH
	case TournamentV5ProviderRegistrationParametersV5RegionSG:
		*s = TournamentV5ProviderRegistrationParametersV5RegionSG
	case TournamentV5ProviderRegistrationParametersV5RegionTH:
		*s = TournamentV5ProviderRegistrationParametersV5RegionTH
	case TournamentV5ProviderRegistrationParametersV5RegionTW:
		*s = TournamentV5ProviderRegistrationParametersV5RegionTW
	case TournamentV5ProviderRegistrationParametersV5RegionVN:
		*s = TournamentV5ProviderRegistrationParametersV5RegionVN
	default:
		*s = TournamentV5ProviderRegistrationParametersV5Region(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TournamentV5ProviderRegistrationParametersV5Region) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentV5ProviderRegistrationParametersV5Region) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TournamentV5RegisterProviderDataOKApplicationJSON as json.
func (s TournamentV5RegisterProviderDataOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := int32(s)

	e.Int32(unwrapped)
}

// Decode decodes TournamentV5RegisterProviderDataOKApplicationJSON from json.
func (s *TournamentV5RegisterProviderDataOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentV5RegisterProviderDataOKApplicationJSON to nil")
	}
	var unwrapped int32
	if err := func() error {
		v, err := d.Int32()
		unwrapped = int32(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TournamentV5RegisterProviderDataOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TournamentV5RegisterProviderDataOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentV5RegisterProviderDataOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TournamentV5RegisterTournamentOKApplicationJSON as json.
func (s TournamentV5RegisterTournamentOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := int32(s)

	e.Int32(unwrapped)
}

// Decode decodes TournamentV5RegisterTournamentOKApplicationJSON from json.
func (s *TournamentV5RegisterTournamentOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentV5RegisterTournamentOKApplicationJSON to nil")
	}
	var unwrapped int32
	if err := func() error {
		v, err := d.Int32()
		unwrapped = int32(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TournamentV5RegisterTournamentOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TournamentV5RegisterTournamentOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentV5RegisterTournamentOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TournamentV5TournamentCodeParametersV5) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TournamentV5TournamentCodeParametersV5) encodeFields(e *jx.Encoder) {
	{
		if s.AllowedParticipants != nil {
			e.FieldStart("allowedParticipants")
			e.ArrStart()
			for _, elem := range s.AllowedParticipants {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("teamSize")
		e.Int32(s.TeamSize)
	}
	{
		e.FieldStart("pickType")
		s.PickType.Encode(e)
	}
	{
		e.FieldStart("mapType")
		s.MapType.Encode(e)
	}
	{
		e.FieldStart("spectatorType")
		s.SpectatorType.Encode(e)
	}
	{
		e.FieldStart("enoughPlayers")
		e.Bool(s.EnoughPlayers)
	}
}

var jsonFieldsNameOfTournamentV5TournamentCodeParametersV5 = [7]string{
	0: "allowedParticipants",
	1: "metadata",
	2: "teamSize",
	3: "pickType",
	4: "mapType",
	5: "spectatorType",
	6: "enoughPlayers",
}

// Decode decodes TournamentV5TournamentCodeParametersV5 from json.
func (s *TournamentV5TournamentCodeParametersV5) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentV5TournamentCodeParametersV5 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowedParticipants":
			if err := func() error {
				s.AllowedParticipants = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedParticipants = append(s.AllowedParticipants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedParticipants\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "teamSize":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.TeamSize = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamSize\"")
			}
		case "pickType":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.PickType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pickType\"")
			}
		case "mapType":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.MapType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mapType\"")
			}
		case "spectatorType":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.SpectatorType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spectatorType\"")
			}
		case "enoughPlayers":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.EnoughPlayers = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enoughPlayers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TournamentV5TournamentCodeParametersV5")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTournamentV5TournamentCodeParametersV5) {
					name = jsonFieldsNameOfTournamentV5TournamentCodeParametersV5[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TournamentV5TournamentCodeParametersV5) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentV5TournamentCodeParametersV5) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TournamentV5TournamentCodeParametersV5MapType as json.
func (s TournamentV5TournamentCodeParametersV5MapType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TournamentV5TournamentCodeParametersV5MapType from json.
func (s *TournamentV5TournamentCodeParametersV5MapType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentV5TournamentCodeParametersV5MapType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TournamentV5TournamentCodeParametersV5MapType(v) {
	case TournamentV5TournamentCodeParametersV5MapTypeSUMMONERSRIFT:
		*s = TournamentV5TournamentCodeParametersV5MapTypeSUMMONERSRIFT
	case TournamentV5TournamentCodeParametersV5MapTypeHOWLINGABYSS:
		*s = TournamentV5TournamentCodeParametersV5MapTypeHOWLINGABYSS
	default:
		*s = TournamentV5TournamentCodeParametersV5MapType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TournamentV5TournamentCodeParametersV5MapType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentV5TournamentCodeParametersV5MapType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TournamentV5TournamentCodeParametersV5PickType as json.
func (s TournamentV5TournamentCodeParametersV5PickType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TournamentV5TournamentCodeParametersV5PickType from json.
func (s *TournamentV5TournamentCodeParametersV5PickType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentV5TournamentCodeParametersV5PickType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TournamentV5TournamentCodeParametersV5PickType(v) {
	case TournamentV5TournamentCodeParametersV5PickTypeBLINDPICK:
		*s = TournamentV5TournamentCodeParametersV5PickTypeBLINDPICK
	case TournamentV5TournamentCodeParametersV5PickTypeDRAFTMODE:
		*s = TournamentV5TournamentCodeParametersV5PickTypeDRAFTMODE
	case TournamentV5TournamentCodeParametersV5PickTypeALLRANDOM:
		*s = TournamentV5TournamentCodeParametersV5PickTypeALLRANDOM
	case TournamentV5TournamentCodeParametersV5PickTypeTOURNAMENTDRAFT:
		*s = TournamentV5TournamentCodeParametersV5PickTypeTOURNAMENTDRAFT
	default:
		*s = TournamentV5TournamentCodeParametersV5PickType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TournamentV5TournamentCodeParametersV5PickType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentV5TournamentCodeParametersV5PickType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TournamentV5TournamentCodeParametersV5SpectatorType as json.
func (s TournamentV5TournamentCodeParametersV5SpectatorType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TournamentV5TournamentCodeParametersV5SpectatorType from json.
func (s *TournamentV5TournamentCodeParametersV5SpectatorType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentV5TournamentCodeParametersV5SpectatorType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TournamentV5TournamentCodeParametersV5SpectatorType(v) {
	case TournamentV5TournamentCodeParametersV5SpectatorTypeNONE:
		*s = TournamentV5TournamentCodeParametersV5SpectatorTypeNONE
	case TournamentV5TournamentCodeParametersV5SpectatorTypeLOBBYONLY:
		*s = TournamentV5TournamentCodeParametersV5SpectatorTypeLOBBYONLY
	case TournamentV5TournamentCodeParametersV5SpectatorTypeALL:
		*s = TournamentV5TournamentCodeParametersV5SpectatorTypeALL
	default:
		*s = TournamentV5TournamentCodeParametersV5SpectatorType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TournamentV5TournamentCodeParametersV5SpectatorType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentV5TournamentCodeParametersV5SpectatorType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TournamentV5TournamentCodeUpdateParametersV5) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TournamentV5TournamentCodeUpdateParametersV5) encodeFields(e *jx.Encoder) {
	{
		if s.AllowedParticipants != nil {
			e.FieldStart("allowedParticipants")
			e.ArrStart()
			for _, elem := range s.AllowedParticipants {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("pickType")
		s.PickType.Encode(e)
	}
	{
		e.FieldStart("mapType")
		s.MapType.Encode(e)
	}
	{
		e.FieldStart("spectatorType")
		s.SpectatorType.Encode(e)
	}
}

var jsonFieldsNameOfTournamentV5TournamentCodeUpdateParametersV5 = [4]string{
	0: "allowedParticipants",
	1: "pickType",
	2: "mapType",
	3: "spectatorType",
}

// Decode decodes TournamentV5TournamentCodeUpdateParametersV5 from json.
func (s *TournamentV5TournamentCodeUpdateParametersV5) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentV5TournamentCodeUpdateParametersV5 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowedParticipants":
			if err := func() error {
				s.AllowedParticipants = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedParticipants = append(s.AllowedParticipants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedParticipants\"")
			}
		case "pickType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.PickType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pickType\"")
			}
		case "mapType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.MapType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mapType\"")
			}
		case "spectatorType":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.SpectatorType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spectatorType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TournamentV5TournamentCodeUpdateParametersV5")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTournamentV5TournamentCodeUpdateParametersV5) {
					name = jsonFieldsNameOfTournamentV5TournamentCodeUpdateParametersV5[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TournamentV5TournamentCodeUpdateParametersV5) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentV5TournamentCodeUpdateParametersV5) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TournamentV5TournamentCodeUpdateParametersV5MapType as json.
func (s TournamentV5TournamentCodeUpdateParametersV5MapType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TournamentV5TournamentCodeUpdateParametersV5MapType from json.
func (s *TournamentV5TournamentCodeUpdateParametersV5MapType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentV5TournamentCodeUpdateParametersV5MapType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TournamentV5TournamentCodeUpdateParametersV5MapType(v) {
	case TournamentV5TournamentCodeUpdateParametersV5MapTypeSUMMONERSRIFT:
		*s = TournamentV5TournamentCodeUpdateParametersV5MapTypeSUMMONERSRIFT
	case TournamentV5TournamentCodeUpdateParametersV5MapTypeHOWLINGABYSS:
		*s = TournamentV5TournamentCodeUpdateParametersV5MapTypeHOWLINGABYSS
	default:
		*s = TournamentV5TournamentCodeUpdateParametersV5MapType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TournamentV5TournamentCodeUpdateParametersV5MapType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentV5TournamentCodeUpdateParametersV5MapType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TournamentV5TournamentCodeUpdateParametersV5PickType as json.
func (s TournamentV5TournamentCodeUpdateParametersV5PickType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TournamentV5TournamentCodeUpdateParametersV5PickType from json.
func (s *TournamentV5TournamentCodeUpdateParametersV5PickType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentV5TournamentCodeUpdateParametersV5PickType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TournamentV5TournamentCodeUpdateParametersV5PickType(v) {
	case TournamentV5TournamentCodeUpdateParametersV5PickTypeBLINDPICK:
		*s = TournamentV5TournamentCodeUpdateParametersV5PickTypeBLINDPICK
	case TournamentV5TournamentCodeUpdateParametersV5PickTypeDRAFTMODE:
		*s = TournamentV5TournamentCodeUpdateParametersV5PickTypeDRAFTMODE
	case TournamentV5TournamentCodeUpdateParametersV5PickTypeALLRANDOM:
		*s = TournamentV5TournamentCodeUpdateParametersV5PickTypeALLRANDOM
	case TournamentV5TournamentCodeUpdateParametersV5PickTypeTOURNAMENTDRAFT:
		*s = TournamentV5TournamentCodeUpdateParametersV5PickTypeTOURNAMENTDRAFT
	default:
		*s = TournamentV5TournamentCodeUpdateParametersV5PickType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TournamentV5TournamentCodeUpdateParametersV5PickType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentV5TournamentCodeUpdateParametersV5PickType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TournamentV5TournamentCodeUpdateParametersV5SpectatorType as json.
func (s TournamentV5TournamentCodeUpdateParametersV5SpectatorType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TournamentV5TournamentCodeUpdateParametersV5SpectatorType from json.
func (s *TournamentV5TournamentCodeUpdateParametersV5SpectatorType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentV5TournamentCodeUpdateParametersV5SpectatorType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TournamentV5TournamentCodeUpdateParametersV5SpectatorType(v) {
	case TournamentV5TournamentCodeUpdateParametersV5SpectatorTypeNONE:
		*s = TournamentV5TournamentCodeUpdateParametersV5SpectatorTypeNONE
	case TournamentV5TournamentCodeUpdateParametersV5SpectatorTypeLOBBYONLY:
		*s = TournamentV5TournamentCodeUpdateParametersV5SpectatorTypeLOBBYONLY
	case TournamentV5TournamentCodeUpdateParametersV5SpectatorTypeALL:
		*s = TournamentV5TournamentCodeUpdateParametersV5SpectatorTypeALL
	default:
		*s = TournamentV5TournamentCodeUpdateParametersV5SpectatorType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TournamentV5TournamentCodeUpdateParametersV5SpectatorType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentV5TournamentCodeUpdateParametersV5SpectatorType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TournamentV5TournamentCodeV5DTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TournamentV5TournamentCodeV5DTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int32(s.ID)
	}
	{
		e.FieldStart("providerId")
		e.Int32(s.ProviderId)
	}
	{
		e.FieldStart("tournamentId")
		e.Int32(s.TournamentId)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("region")
		s.Region.Encode(e)
	}
	{
		e.FieldStart("map")
		e.Str(s.Map)
	}
	{
		e.FieldStart("teamSize")
		e.Int32(s.TeamSize)
	}
	{
		e.FieldStart("spectators")
		e.Str(s.Spectators)
	}
	{
		e.FieldStart("pickType")
		e.Str(s.PickType)
	}
	{
		e.FieldStart("lobbyName")
		e.Str(s.LobbyName)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
	{
		e.FieldStart("metaData")
		e.Str(s.MetaData)
	}
	{
		e.FieldStart("participants")
		e.ArrStart()
		for _, elem := range s.Participants {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfTournamentV5TournamentCodeV5DTO = [13]string{
	0:  "id",
	1:  "providerId",
	2:  "tournamentId",
	3:  "code",
	4:  "region",
	5:  "map",
	6:  "teamSize",
	7:  "spectators",
	8:  "pickType",
	9:  "lobbyName",
	10: "password",
	11: "metaData",
	12: "participants",
}

// Decode decodes TournamentV5TournamentCodeV5DTO from json.
func (s *TournamentV5TournamentCodeV5DTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentV5TournamentCodeV5DTO to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ID = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "providerId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.ProviderId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerId\"")
			}
		case "tournamentId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.TournamentId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tournamentId\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "region":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "map":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Map = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"map\"")
			}
		case "teamSize":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.TeamSize = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamSize\"")
			}
		case "spectators":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Spectators = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spectators\"")
			}
		case "pickType":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PickType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pickType\"")
			}
		case "lobbyName":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LobbyName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lobbyName\"")
			}
		case "password":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "metaData":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.MetaData = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metaData\"")
			}
		case "participants":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				s.Participants = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Participants = append(s.Participants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"participants\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TournamentV5TournamentCodeV5DTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTournamentV5TournamentCodeV5DTO) {
					name = jsonFieldsNameOfTournamentV5TournamentCodeV5DTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TournamentV5TournamentCodeV5DTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentV5TournamentCodeV5DTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TournamentV5TournamentCodeV5DTORegion as json.
func (s TournamentV5TournamentCodeV5DTORegion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TournamentV5TournamentCodeV5DTORegion from json.
func (s *TournamentV5TournamentCodeV5DTORegion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentV5TournamentCodeV5DTORegion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TournamentV5TournamentCodeV5DTORegion(v) {
	case TournamentV5TournamentCodeV5DTORegionBR:
		*s = TournamentV5TournamentCodeV5DTORegionBR
	case TournamentV5TournamentCodeV5DTORegionEUNE:
		*s = TournamentV5TournamentCodeV5DTORegionEUNE
	case TournamentV5TournamentCodeV5DTORegionEUW:
		*s = TournamentV5TournamentCodeV5DTORegionEUW
	case TournamentV5TournamentCodeV5DTORegionJP:
		*s = TournamentV5TournamentCodeV5DTORegionJP
	case TournamentV5TournamentCodeV5DTORegionLAN:
		*s = TournamentV5TournamentCodeV5DTORegionLAN
	case TournamentV5TournamentCodeV5DTORegionLAS:
		*s = TournamentV5TournamentCodeV5DTORegionLAS
	case TournamentV5TournamentCodeV5DTORegionNA:
		*s = TournamentV5TournamentCodeV5DTORegionNA
	case TournamentV5TournamentCodeV5DTORegionOCE:
		*s = TournamentV5TournamentCodeV5DTORegionOCE
	case TournamentV5TournamentCodeV5DTORegionPBE:
		*s = TournamentV5TournamentCodeV5DTORegionPBE
	case TournamentV5TournamentCodeV5DTORegionRU:
		*s = TournamentV5TournamentCodeV5DTORegionRU
	case TournamentV5TournamentCodeV5DTORegionTR:
		*s = TournamentV5TournamentCodeV5DTORegionTR
	case TournamentV5TournamentCodeV5DTORegionKR:
		*s = TournamentV5TournamentCodeV5DTORegionKR
	case TournamentV5TournamentCodeV5DTORegionPH:
		*s = TournamentV5TournamentCodeV5DTORegionPH
	case TournamentV5TournamentCodeV5DTORegionSG:
		*s = TournamentV5TournamentCodeV5DTORegionSG
	case TournamentV5TournamentCodeV5DTORegionTH:
		*s = TournamentV5TournamentCodeV5DTORegionTH
	case TournamentV5TournamentCodeV5DTORegionTW:
		*s = TournamentV5TournamentCodeV5DTORegionTW
	case TournamentV5TournamentCodeV5DTORegionVN:
		*s = TournamentV5TournamentCodeV5DTORegionVN
	default:
		*s = TournamentV5TournamentCodeV5DTORegion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TournamentV5TournamentCodeV5DTORegion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentV5TournamentCodeV5DTORegion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TournamentV5TournamentGamesV5) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TournamentV5TournamentGamesV5) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("startTime")
		e.Int64(s.StartTime)
	}
	{
		e.FieldStart("winningTeam")
		e.ArrStart()
		for _, elem := range s.WinningTeam {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("losingTeam")
		e.ArrStart()
		for _, elem := range s.LosingTeam {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("shortCode")
		e.Str(s.ShortCode)
	}
	{
		if s.MetaData.Set {
			e.FieldStart("metaData")
			s.MetaData.Encode(e)
		}
	}
	{
		e.FieldStart("gameId")
		e.Int64(s.GameId)
	}
	{
		e.FieldStart("gameName")
		e.Str(s.GameName)
	}
	{
		e.FieldStart("gameType")
		e.Str(s.GameType)
	}
	{
		e.FieldStart("gameMap")
		e.Int32(s.GameMap)
	}
	{
		e.FieldStart("gameMode")
		e.Str(s.GameMode)
	}
	{
		e.FieldStart("region")
		e.Str(s.Region)
	}
}

var jsonFieldsNameOfTournamentV5TournamentGamesV5 = [11]string{
	0:  "startTime",
	1:  "winningTeam",
	2:  "losingTeam",
	3:  "shortCode",
	4:  "metaData",
	5:  "gameId",
	6:  "gameName",
	7:  "gameType",
	8:  "gameMap",
	9:  "gameMode",
	10: "region",
}

// Decode decodes TournamentV5TournamentGamesV5 from json.
func (s *TournamentV5TournamentGamesV5) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentV5TournamentGamesV5 to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "startTime":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.StartTime = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startTime\"")
			}
		case "winningTeam":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.WinningTeam = make([]TournamentV5TournamentTeamV5, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TournamentV5TournamentTeamV5
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.WinningTeam = append(s.WinningTeam, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"winningTeam\"")
			}
		case "losingTeam":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.LosingTeam = make([]TournamentV5TournamentTeamV5, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TournamentV5TournamentTeamV5
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.LosingTeam = append(s.LosingTeam, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"losingTeam\"")
			}
		case "shortCode":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ShortCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortCode\"")
			}
		case "metaData":
			if err := func() error {
				s.MetaData.Reset()
				if err := s.MetaData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metaData\"")
			}
		case "gameId":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.GameId = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameId\"")
			}
		case "gameName":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.GameName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameName\"")
			}
		case "gameType":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.GameType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameType\"")
			}
		case "gameMap":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.GameMap = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameMap\"")
			}
		case "gameMode":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GameMode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameMode\"")
			}
		case "region":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Region = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TournamentV5TournamentGamesV5")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11101111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTournamentV5TournamentGamesV5) {
					name = jsonFieldsNameOfTournamentV5TournamentGamesV5[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TournamentV5TournamentGamesV5) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentV5TournamentGamesV5) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TournamentV5TournamentRegistrationParametersV5) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TournamentV5TournamentRegistrationParametersV5) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("providerId")
		e.Int32(s.ProviderId)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfTournamentV5TournamentRegistrationParametersV5 = [2]string{
	0: "providerId",
	1: "name",
}

// Decode decodes TournamentV5TournamentRegistrationParametersV5 from json.
func (s *TournamentV5TournamentRegistrationParametersV5) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentV5TournamentRegistrationParametersV5 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "providerId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ProviderId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerId\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TournamentV5TournamentRegistrationParametersV5")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTournamentV5TournamentRegistrationParametersV5) {
					name = jsonFieldsNameOfTournamentV5TournamentRegistrationParametersV5[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TournamentV5TournamentRegistrationParametersV5) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentV5TournamentRegistrationParametersV5) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TournamentV5TournamentTeamV5) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TournamentV5TournamentTeamV5) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
}

var jsonFieldsNameOfTournamentV5TournamentTeamV5 = [1]string{
	0: "puuid",
}

// Decode decodes TournamentV5TournamentTeamV5 from json.
func (s *TournamentV5TournamentTeamV5) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TournamentV5TournamentTeamV5 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "puuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TournamentV5TournamentTeamV5")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTournamentV5TournamentTeamV5) {
					name = jsonFieldsNameOfTournamentV5TournamentTeamV5[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TournamentV5TournamentTeamV5) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TournamentV5TournamentTeamV5) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValConsoleMatchV1AbilityCastsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValConsoleMatchV1AbilityCastsDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("grenadeCasts")
		e.Int32(s.GrenadeCasts)
	}
	{
		e.FieldStart("ability1Casts")
		e.Int32(s.Ability1Casts)
	}
	{
		e.FieldStart("ability2Casts")
		e.Int32(s.Ability2Casts)
	}
	{
		e.FieldStart("ultimateCasts")
		e.Int32(s.UltimateCasts)
	}
}

var jsonFieldsNameOfValConsoleMatchV1AbilityCastsDto = [4]string{
	0: "grenadeCasts",
	1: "ability1Casts",
	2: "ability2Casts",
	3: "ultimateCasts",
}

// Decode decodes ValConsoleMatchV1AbilityCastsDto from json.
func (s *ValConsoleMatchV1AbilityCastsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValConsoleMatchV1AbilityCastsDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "grenadeCasts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.GrenadeCasts = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"grenadeCasts\"")
			}
		case "ability1Casts":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Ability1Casts = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ability1Casts\"")
			}
		case "ability2Casts":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Ability2Casts = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ability2Casts\"")
			}
		case "ultimateCasts":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.UltimateCasts = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ultimateCasts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValConsoleMatchV1AbilityCastsDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValConsoleMatchV1AbilityCastsDto) {
					name = jsonFieldsNameOfValConsoleMatchV1AbilityCastsDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValConsoleMatchV1AbilityCastsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValConsoleMatchV1AbilityCastsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValConsoleMatchV1AbilityDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValConsoleMatchV1AbilityDto) encodeFields(e *jx.Encoder) {
	{
		if s.GrenadeEffects.Set {
			e.FieldStart("grenadeEffects")
			s.GrenadeEffects.Encode(e)
		}
	}
	{
		if s.Ability1Effects.Set {
			e.FieldStart("ability1Effects")
			s.Ability1Effects.Encode(e)
		}
	}
	{
		if s.Ability2Effects.Set {
			e.FieldStart("ability2Effects")
			s.Ability2Effects.Encode(e)
		}
	}
	{
		if s.UltimateEffects.Set {
			e.FieldStart("ultimateEffects")
			s.UltimateEffects.Encode(e)
		}
	}
}

var jsonFieldsNameOfValConsoleMatchV1AbilityDto = [4]string{
	0: "grenadeEffects",
	1: "ability1Effects",
	2: "ability2Effects",
	3: "ultimateEffects",
}

// Decode decodes ValConsoleMatchV1AbilityDto from json.
func (s *ValConsoleMatchV1AbilityDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValConsoleMatchV1AbilityDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "grenadeEffects":
			if err := func() error {
				s.GrenadeEffects.Reset()
				if err := s.GrenadeEffects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"grenadeEffects\"")
			}
		case "ability1Effects":
			if err := func() error {
				s.Ability1Effects.Reset()
				if err := s.Ability1Effects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ability1Effects\"")
			}
		case "ability2Effects":
			if err := func() error {
				s.Ability2Effects.Reset()
				if err := s.Ability2Effects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ability2Effects\"")
			}
		case "ultimateEffects":
			if err := func() error {
				s.UltimateEffects.Reset()
				if err := s.UltimateEffects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ultimateEffects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValConsoleMatchV1AbilityDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValConsoleMatchV1AbilityDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValConsoleMatchV1AbilityDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValConsoleMatchV1CoachDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValConsoleMatchV1CoachDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		e.FieldStart("teamId")
		e.Str(s.TeamId)
	}
}

var jsonFieldsNameOfValConsoleMatchV1CoachDto = [2]string{
	0: "puuid",
	1: "teamId",
}

// Decode decodes ValConsoleMatchV1CoachDto from json.
func (s *ValConsoleMatchV1CoachDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValConsoleMatchV1CoachDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "puuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "teamId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TeamId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValConsoleMatchV1CoachDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValConsoleMatchV1CoachDto) {
					name = jsonFieldsNameOfValConsoleMatchV1CoachDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValConsoleMatchV1CoachDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValConsoleMatchV1CoachDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValConsoleMatchV1DamageDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValConsoleMatchV1DamageDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("receiver")
		e.Str(s.Receiver)
	}
	{
		e.FieldStart("damage")
		e.Int32(s.Damage)
	}
	{
		e.FieldStart("legshots")
		e.Int32(s.Legshots)
	}
	{
		e.FieldStart("bodyshots")
		e.Int32(s.Bodyshots)
	}
	{
		e.FieldStart("headshots")
		e.Int32(s.Headshots)
	}
}

var jsonFieldsNameOfValConsoleMatchV1DamageDto = [5]string{
	0: "receiver",
	1: "damage",
	2: "legshots",
	3: "bodyshots",
	4: "headshots",
}

// Decode decodes ValConsoleMatchV1DamageDto from json.
func (s *ValConsoleMatchV1DamageDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValConsoleMatchV1DamageDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "receiver":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Receiver = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"receiver\"")
			}
		case "damage":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Damage = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage\"")
			}
		case "legshots":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Legshots = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"legshots\"")
			}
		case "bodyshots":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Bodyshots = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bodyshots\"")
			}
		case "headshots":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Headshots = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headshots\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValConsoleMatchV1DamageDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValConsoleMatchV1DamageDto) {
					name = jsonFieldsNameOfValConsoleMatchV1DamageDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValConsoleMatchV1DamageDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValConsoleMatchV1DamageDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValConsoleMatchV1EconomyDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValConsoleMatchV1EconomyDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("loadoutValue")
		e.Int32(s.LoadoutValue)
	}
	{
		e.FieldStart("weapon")
		e.Str(s.Weapon)
	}
	{
		e.FieldStart("armor")
		e.Str(s.Armor)
	}
	{
		e.FieldStart("remaining")
		e.Int32(s.Remaining)
	}
	{
		e.FieldStart("spent")
		e.Int32(s.Spent)
	}
}

var jsonFieldsNameOfValConsoleMatchV1EconomyDto = [5]string{
	0: "loadoutValue",
	1: "weapon",
	2: "armor",
	3: "remaining",
	4: "spent",
}

// Decode decodes ValConsoleMatchV1EconomyDto from json.
func (s *ValConsoleMatchV1EconomyDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValConsoleMatchV1EconomyDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "loadoutValue":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.LoadoutValue = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadoutValue\"")
			}
		case "weapon":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Weapon = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon\"")
			}
		case "armor":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Armor = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"armor\"")
			}
		case "remaining":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Remaining = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining\"")
			}
		case "spent":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Spent = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValConsoleMatchV1EconomyDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValConsoleMatchV1EconomyDto) {
					name = jsonFieldsNameOfValConsoleMatchV1EconomyDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValConsoleMatchV1EconomyDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValConsoleMatchV1EconomyDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValConsoleMatchV1FinishingDamageDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValConsoleMatchV1FinishingDamageDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("damageType")
		e.Str(s.DamageType)
	}
	{
		e.FieldStart("damageItem")
		e.Str(s.DamageItem)
	}
	{
		e.FieldStart("isSecondaryFireMode")
		e.Bool(s.IsSecondaryFireMode)
	}
}

var jsonFieldsNameOfValConsoleMatchV1FinishingDamageDto = [3]string{
	0: "damageType",
	1: "damageItem",
	2: "isSecondaryFireMode",
}

// Decode decodes ValConsoleMatchV1FinishingDamageDto from json.
func (s *ValConsoleMatchV1FinishingDamageDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValConsoleMatchV1FinishingDamageDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "damageType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DamageType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damageType\"")
			}
		case "damageItem":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DamageItem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damageItem\"")
			}
		case "isSecondaryFireMode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.IsSecondaryFireMode = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isSecondaryFireMode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValConsoleMatchV1FinishingDamageDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValConsoleMatchV1FinishingDamageDto) {
					name = jsonFieldsNameOfValConsoleMatchV1FinishingDamageDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValConsoleMatchV1FinishingDamageDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValConsoleMatchV1FinishingDamageDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValConsoleMatchV1KillDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValConsoleMatchV1KillDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("timeSinceGameStartMillis")
		e.Int32(s.TimeSinceGameStartMillis)
	}
	{
		e.FieldStart("timeSinceRoundStartMillis")
		e.Int32(s.TimeSinceRoundStartMillis)
	}
	{
		e.FieldStart("killer")
		e.Str(s.Killer)
	}
	{
		e.FieldStart("victim")
		e.Str(s.Victim)
	}
	{
		e.FieldStart("victimLocation")
		s.VictimLocation.Encode(e)
	}
	{
		e.FieldStart("assistants")
		e.ArrStart()
		for _, elem := range s.Assistants {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("playerLocations")
		e.ArrStart()
		for _, elem := range s.PlayerLocations {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("finishingDamage")
		s.FinishingDamage.Encode(e)
	}
}

var jsonFieldsNameOfValConsoleMatchV1KillDto = [8]string{
	0: "timeSinceGameStartMillis",
	1: "timeSinceRoundStartMillis",
	2: "killer",
	3: "victim",
	4: "victimLocation",
	5: "assistants",
	6: "playerLocations",
	7: "finishingDamage",
}

// Decode decodes ValConsoleMatchV1KillDto from json.
func (s *ValConsoleMatchV1KillDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValConsoleMatchV1KillDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timeSinceGameStartMillis":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.TimeSinceGameStartMillis = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeSinceGameStartMillis\"")
			}
		case "timeSinceRoundStartMillis":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.TimeSinceRoundStartMillis = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeSinceRoundStartMillis\"")
			}
		case "killer":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Killer = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"killer\"")
			}
		case "victim":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Victim = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"victim\"")
			}
		case "victimLocation":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.VictimLocation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"victimLocation\"")
			}
		case "assistants":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Assistants = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Assistants = append(s.Assistants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assistants\"")
			}
		case "playerLocations":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.PlayerLocations = make([]ValConsoleMatchV1PlayerLocationsDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValConsoleMatchV1PlayerLocationsDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PlayerLocations = append(s.PlayerLocations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerLocations\"")
			}
		case "finishingDamage":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.FinishingDamage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finishingDamage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValConsoleMatchV1KillDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValConsoleMatchV1KillDto) {
					name = jsonFieldsNameOfValConsoleMatchV1KillDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValConsoleMatchV1KillDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValConsoleMatchV1KillDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValConsoleMatchV1LocationDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValConsoleMatchV1LocationDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("x")
		e.Int32(s.X)
	}
	{
		e.FieldStart("y")
		e.Int32(s.Y)
	}
}

var jsonFieldsNameOfValConsoleMatchV1LocationDto = [2]string{
	0: "x",
	1: "y",
}

// Decode decodes ValConsoleMatchV1LocationDto from json.
func (s *ValConsoleMatchV1LocationDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValConsoleMatchV1LocationDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.X = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Y = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValConsoleMatchV1LocationDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValConsoleMatchV1LocationDto) {
					name = jsonFieldsNameOfValConsoleMatchV1LocationDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValConsoleMatchV1LocationDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValConsoleMatchV1LocationDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValConsoleMatchV1MatchDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValConsoleMatchV1MatchDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("matchInfo")
		s.MatchInfo.Encode(e)
	}
	{
		e.FieldStart("players")
		e.ArrStart()
		for _, elem := range s.Players {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("coaches")
		e.ArrStart()
		for _, elem := range s.Coaches {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Teams != nil {
			e.FieldStart("teams")
			e.ArrStart()
			for _, elem := range s.Teams {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RoundResults != nil {
			e.FieldStart("roundResults")
			e.ArrStart()
			for _, elem := range s.RoundResults {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfValConsoleMatchV1MatchDto = [5]string{
	0: "matchInfo",
	1: "players",
	2: "coaches",
	3: "teams",
	4: "roundResults",
}

// Decode decodes ValConsoleMatchV1MatchDto from json.
func (s *ValConsoleMatchV1MatchDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValConsoleMatchV1MatchDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchInfo":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.MatchInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchInfo\"")
			}
		case "players":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Players = make([]ValConsoleMatchV1PlayerDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValConsoleMatchV1PlayerDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Players = append(s.Players, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"players\"")
			}
		case "coaches":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Coaches = make([]ValConsoleMatchV1CoachDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValConsoleMatchV1CoachDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Coaches = append(s.Coaches, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"coaches\"")
			}
		case "teams":
			if err := func() error {
				s.Teams = make([]ValConsoleMatchV1TeamDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValConsoleMatchV1TeamDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		case "roundResults":
			if err := func() error {
				s.RoundResults = make([]ValConsoleMatchV1RoundResultDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValConsoleMatchV1RoundResultDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RoundResults = append(s.RoundResults, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roundResults\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValConsoleMatchV1MatchDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValConsoleMatchV1MatchDto) {
					name = jsonFieldsNameOfValConsoleMatchV1MatchDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValConsoleMatchV1MatchDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValConsoleMatchV1MatchDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValConsoleMatchV1MatchInfoDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValConsoleMatchV1MatchInfoDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("matchId")
		e.Str(s.MatchId)
	}
	{
		e.FieldStart("mapId")
		e.Str(s.MapId)
	}
	{
		if s.GameLengthMillis.Set {
			e.FieldStart("gameLengthMillis")
			s.GameLengthMillis.Encode(e)
		}
	}
	{
		e.FieldStart("gameStartMillis")
		e.Int64(s.GameStartMillis)
	}
	{
		e.FieldStart("provisioningFlowId")
		e.Str(s.ProvisioningFlowId)
	}
	{
		e.FieldStart("isCompleted")
		e.Bool(s.IsCompleted)
	}
	{
		e.FieldStart("customGameName")
		e.Str(s.CustomGameName)
	}
	{
		e.FieldStart("queueId")
		e.Str(s.QueueId)
	}
	{
		e.FieldStart("gameMode")
		e.Str(s.GameMode)
	}
	{
		e.FieldStart("isRanked")
		e.Bool(s.IsRanked)
	}
	{
		e.FieldStart("seasonId")
		e.Str(s.SeasonId)
	}
}

var jsonFieldsNameOfValConsoleMatchV1MatchInfoDto = [11]string{
	0:  "matchId",
	1:  "mapId",
	2:  "gameLengthMillis",
	3:  "gameStartMillis",
	4:  "provisioningFlowId",
	5:  "isCompleted",
	6:  "customGameName",
	7:  "queueId",
	8:  "gameMode",
	9:  "isRanked",
	10: "seasonId",
}

// Decode decodes ValConsoleMatchV1MatchInfoDto from json.
func (s *ValConsoleMatchV1MatchInfoDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValConsoleMatchV1MatchInfoDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MatchId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchId\"")
			}
		case "mapId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.MapId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mapId\"")
			}
		case "gameLengthMillis":
			if err := func() error {
				s.GameLengthMillis.Reset()
				if err := s.GameLengthMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameLengthMillis\"")
			}
		case "gameStartMillis":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int64()
				s.GameStartMillis = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameStartMillis\"")
			}
		case "provisioningFlowId":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ProvisioningFlowId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provisioningFlowId\"")
			}
		case "isCompleted":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsCompleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isCompleted\"")
			}
		case "customGameName":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.CustomGameName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customGameName\"")
			}
		case "queueId":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.QueueId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queueId\"")
			}
		case "gameMode":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GameMode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameMode\"")
			}
		case "isRanked":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsRanked = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isRanked\"")
			}
		case "seasonId":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SeasonId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seasonId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValConsoleMatchV1MatchInfoDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111011,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValConsoleMatchV1MatchInfoDto) {
					name = jsonFieldsNameOfValConsoleMatchV1MatchInfoDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValConsoleMatchV1MatchInfoDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValConsoleMatchV1MatchInfoDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValConsoleMatchV1MatchlistDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValConsoleMatchV1MatchlistDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		e.FieldStart("history")
		e.ArrStart()
		for _, elem := range s.History {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfValConsoleMatchV1MatchlistDto = [2]string{
	0: "puuid",
	1: "history",
}

// Decode decodes ValConsoleMatchV1MatchlistDto from json.
func (s *ValConsoleMatchV1MatchlistDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValConsoleMatchV1MatchlistDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "puuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "history":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.History = make([]ValConsoleMatchV1MatchlistEntryDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValConsoleMatchV1MatchlistEntryDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.History = append(s.History, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"history\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValConsoleMatchV1MatchlistDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValConsoleMatchV1MatchlistDto) {
					name = jsonFieldsNameOfValConsoleMatchV1MatchlistDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValConsoleMatchV1MatchlistDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValConsoleMatchV1MatchlistDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValConsoleMatchV1MatchlistEntryDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValConsoleMatchV1MatchlistEntryDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("matchId")
		e.Str(s.MatchId)
	}
	{
		e.FieldStart("gameStartTimeMillis")
		e.Int64(s.GameStartTimeMillis)
	}
	{
		e.FieldStart("queueId")
		e.Str(s.QueueId)
	}
}

var jsonFieldsNameOfValConsoleMatchV1MatchlistEntryDto = [3]string{
	0: "matchId",
	1: "gameStartTimeMillis",
	2: "queueId",
}

// Decode decodes ValConsoleMatchV1MatchlistEntryDto from json.
func (s *ValConsoleMatchV1MatchlistEntryDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValConsoleMatchV1MatchlistEntryDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MatchId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchId\"")
			}
		case "gameStartTimeMillis":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.GameStartTimeMillis = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameStartTimeMillis\"")
			}
		case "queueId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.QueueId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queueId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValConsoleMatchV1MatchlistEntryDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValConsoleMatchV1MatchlistEntryDto) {
					name = jsonFieldsNameOfValConsoleMatchV1MatchlistEntryDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValConsoleMatchV1MatchlistEntryDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValConsoleMatchV1MatchlistEntryDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValConsoleMatchV1PlayerDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValConsoleMatchV1PlayerDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		e.FieldStart("gameName")
		e.Str(s.GameName)
	}
	{
		e.FieldStart("tagLine")
		e.Str(s.TagLine)
	}
	{
		e.FieldStart("teamId")
		e.Str(s.TeamId)
	}
	{
		e.FieldStart("partyId")
		e.Str(s.PartyId)
	}
	{
		if s.CharacterId.Set {
			e.FieldStart("characterId")
			s.CharacterId.Encode(e)
		}
	}
	{
		if s.Stats.Set {
			e.FieldStart("stats")
			s.Stats.Encode(e)
		}
	}
	{
		e.FieldStart("competitiveTier")
		e.Int32(s.CompetitiveTier)
	}
	{
		e.FieldStart("playerCard")
		e.Str(s.PlayerCard)
	}
	{
		e.FieldStart("playerTitle")
		e.Str(s.PlayerTitle)
	}
}

var jsonFieldsNameOfValConsoleMatchV1PlayerDto = [10]string{
	0: "puuid",
	1: "gameName",
	2: "tagLine",
	3: "teamId",
	4: "partyId",
	5: "characterId",
	6: "stats",
	7: "competitiveTier",
	8: "playerCard",
	9: "playerTitle",
}

// Decode decodes ValConsoleMatchV1PlayerDto from json.
func (s *ValConsoleMatchV1PlayerDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValConsoleMatchV1PlayerDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "puuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "gameName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GameName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameName\"")
			}
		case "tagLine":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TagLine = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tagLine\"")
			}
		case "teamId":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TeamId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamId\"")
			}
		case "partyId":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.PartyId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partyId\"")
			}
		case "characterId":
			if err := func() error {
				s.CharacterId.Reset()
				if err := s.CharacterId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"characterId\"")
			}
		case "stats":
			if err := func() error {
				s.Stats.Reset()
				if err := s.Stats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stats\"")
			}
		case "competitiveTier":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.CompetitiveTier = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"competitiveTier\"")
			}
		case "playerCard":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PlayerCard = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerCard\"")
			}
		case "playerTitle":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PlayerTitle = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerTitle\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValConsoleMatchV1PlayerDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10011111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValConsoleMatchV1PlayerDto) {
					name = jsonFieldsNameOfValConsoleMatchV1PlayerDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValConsoleMatchV1PlayerDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValConsoleMatchV1PlayerDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValConsoleMatchV1PlayerLocationsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValConsoleMatchV1PlayerLocationsDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		e.FieldStart("viewRadians")
		e.Float32(s.ViewRadians)
	}
	{
		e.FieldStart("location")
		s.Location.Encode(e)
	}
}

var jsonFieldsNameOfValConsoleMatchV1PlayerLocationsDto = [3]string{
	0: "puuid",
	1: "viewRadians",
	2: "location",
}

// Decode decodes ValConsoleMatchV1PlayerLocationsDto from json.
func (s *ValConsoleMatchV1PlayerLocationsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValConsoleMatchV1PlayerLocationsDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "puuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "viewRadians":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.ViewRadians = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewRadians\"")
			}
		case "location":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValConsoleMatchV1PlayerLocationsDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValConsoleMatchV1PlayerLocationsDto) {
					name = jsonFieldsNameOfValConsoleMatchV1PlayerLocationsDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValConsoleMatchV1PlayerLocationsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValConsoleMatchV1PlayerLocationsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValConsoleMatchV1PlayerRoundStatsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValConsoleMatchV1PlayerRoundStatsDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		e.FieldStart("kills")
		e.ArrStart()
		for _, elem := range s.Kills {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("damage")
		e.ArrStart()
		for _, elem := range s.Damage {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("score")
		e.Int32(s.Score)
	}
	{
		e.FieldStart("economy")
		s.Economy.Encode(e)
	}
	{
		e.FieldStart("ability")
		s.Ability.Encode(e)
	}
}

var jsonFieldsNameOfValConsoleMatchV1PlayerRoundStatsDto = [6]string{
	0: "puuid",
	1: "kills",
	2: "damage",
	3: "score",
	4: "economy",
	5: "ability",
}

// Decode decodes ValConsoleMatchV1PlayerRoundStatsDto from json.
func (s *ValConsoleMatchV1PlayerRoundStatsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValConsoleMatchV1PlayerRoundStatsDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "puuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "kills":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Kills = make([]ValConsoleMatchV1KillDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValConsoleMatchV1KillDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Kills = append(s.Kills, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kills\"")
			}
		case "damage":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Damage = make([]ValConsoleMatchV1DamageDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValConsoleMatchV1DamageDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Damage = append(s.Damage, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage\"")
			}
		case "score":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Score = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "economy":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Economy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"economy\"")
			}
		case "ability":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Ability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ability\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValConsoleMatchV1PlayerRoundStatsDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValConsoleMatchV1PlayerRoundStatsDto) {
					name = jsonFieldsNameOfValConsoleMatchV1PlayerRoundStatsDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValConsoleMatchV1PlayerRoundStatsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValConsoleMatchV1PlayerRoundStatsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValConsoleMatchV1PlayerStatsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValConsoleMatchV1PlayerStatsDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("score")
		e.Int32(s.Score)
	}
	{
		e.FieldStart("roundsPlayed")
		e.Int32(s.RoundsPlayed)
	}
	{
		e.FieldStart("kills")
		e.Int32(s.Kills)
	}
	{
		e.FieldStart("deaths")
		e.Int32(s.Deaths)
	}
	{
		e.FieldStart("assists")
		e.Int32(s.Assists)
	}
	{
		e.FieldStart("playtimeMillis")
		e.Int32(s.PlaytimeMillis)
	}
	{
		if s.AbilityCasts.Set {
			e.FieldStart("abilityCasts")
			s.AbilityCasts.Encode(e)
		}
	}
}

var jsonFieldsNameOfValConsoleMatchV1PlayerStatsDto = [7]string{
	0: "score",
	1: "roundsPlayed",
	2: "kills",
	3: "deaths",
	4: "assists",
	5: "playtimeMillis",
	6: "abilityCasts",
}

// Decode decodes ValConsoleMatchV1PlayerStatsDto from json.
func (s *ValConsoleMatchV1PlayerStatsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValConsoleMatchV1PlayerStatsDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "score":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Score = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "roundsPlayed":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.RoundsPlayed = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roundsPlayed\"")
			}
		case "kills":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Kills = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kills\"")
			}
		case "deaths":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Deaths = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deaths\"")
			}
		case "assists":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Assists = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assists\"")
			}
		case "playtimeMillis":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.PlaytimeMillis = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playtimeMillis\"")
			}
		case "abilityCasts":
			if err := func() error {
				s.AbilityCasts.Reset()
				if err := s.AbilityCasts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"abilityCasts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValConsoleMatchV1PlayerStatsDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValConsoleMatchV1PlayerStatsDto) {
					name = jsonFieldsNameOfValConsoleMatchV1PlayerStatsDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValConsoleMatchV1PlayerStatsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValConsoleMatchV1PlayerStatsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValConsoleMatchV1RecentMatchesDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValConsoleMatchV1RecentMatchesDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("currentTime")
		e.Int64(s.CurrentTime)
	}
	{
		e.FieldStart("matchIds")
		e.ArrStart()
		for _, elem := range s.MatchIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfValConsoleMatchV1RecentMatchesDto = [2]string{
	0: "currentTime",
	1: "matchIds",
}

// Decode decodes ValConsoleMatchV1RecentMatchesDto from json.
func (s *ValConsoleMatchV1RecentMatchesDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValConsoleMatchV1RecentMatchesDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currentTime":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.CurrentTime = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentTime\"")
			}
		case "matchIds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.MatchIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.MatchIds = append(s.MatchIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchIds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValConsoleMatchV1RecentMatchesDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValConsoleMatchV1RecentMatchesDto) {
					name = jsonFieldsNameOfValConsoleMatchV1RecentMatchesDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValConsoleMatchV1RecentMatchesDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValConsoleMatchV1RecentMatchesDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValConsoleMatchV1RoundResultDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValConsoleMatchV1RoundResultDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("roundNum")
		e.Int32(s.RoundNum)
	}
	{
		e.FieldStart("roundResult")
		e.Str(s.RoundResult)
	}
	{
		e.FieldStart("roundCeremony")
		e.Str(s.RoundCeremony)
	}
	{
		e.FieldStart("winningTeam")
		e.Str(s.WinningTeam)
	}
	{
		if s.BombPlanter.Set {
			e.FieldStart("bombPlanter")
			s.BombPlanter.Encode(e)
		}
	}
	{
		if s.BombDefuser.Set {
			e.FieldStart("bombDefuser")
			s.BombDefuser.Encode(e)
		}
	}
	{
		e.FieldStart("plantRoundTime")
		e.Int32(s.PlantRoundTime)
	}
	{
		if s.PlantPlayerLocations != nil {
			e.FieldStart("plantPlayerLocations")
			e.ArrStart()
			for _, elem := range s.PlantPlayerLocations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("plantLocation")
		s.PlantLocation.Encode(e)
	}
	{
		e.FieldStart("plantSite")
		e.Str(s.PlantSite)
	}
	{
		e.FieldStart("defuseRoundTime")
		e.Int32(s.DefuseRoundTime)
	}
	{
		if s.DefusePlayerLocations != nil {
			e.FieldStart("defusePlayerLocations")
			e.ArrStart()
			for _, elem := range s.DefusePlayerLocations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("defuseLocation")
		s.DefuseLocation.Encode(e)
	}
	{
		e.FieldStart("playerStats")
		e.ArrStart()
		for _, elem := range s.PlayerStats {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("roundResultCode")
		e.Str(s.RoundResultCode)
	}
}

var jsonFieldsNameOfValConsoleMatchV1RoundResultDto = [15]string{
	0:  "roundNum",
	1:  "roundResult",
	2:  "roundCeremony",
	3:  "winningTeam",
	4:  "bombPlanter",
	5:  "bombDefuser",
	6:  "plantRoundTime",
	7:  "plantPlayerLocations",
	8:  "plantLocation",
	9:  "plantSite",
	10: "defuseRoundTime",
	11: "defusePlayerLocations",
	12: "defuseLocation",
	13: "playerStats",
	14: "roundResultCode",
}

// Decode decodes ValConsoleMatchV1RoundResultDto from json.
func (s *ValConsoleMatchV1RoundResultDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValConsoleMatchV1RoundResultDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "roundNum":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.RoundNum = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roundNum\"")
			}
		case "roundResult":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RoundResult = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roundResult\"")
			}
		case "roundCeremony":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.RoundCeremony = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roundCeremony\"")
			}
		case "winningTeam":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.WinningTeam = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"winningTeam\"")
			}
		case "bombPlanter":
			if err := func() error {
				s.BombPlanter.Reset()
				if err := s.BombPlanter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bombPlanter\"")
			}
		case "bombDefuser":
			if err := func() error {
				s.BombDefuser.Reset()
				if err := s.BombDefuser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bombDefuser\"")
			}
		case "plantRoundTime":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int32()
				s.PlantRoundTime = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plantRoundTime\"")
			}
		case "plantPlayerLocations":
			if err := func() error {
				s.PlantPlayerLocations = make([]ValConsoleMatchV1PlayerLocationsDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValConsoleMatchV1PlayerLocationsDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PlantPlayerLocations = append(s.PlantPlayerLocations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plantPlayerLocations\"")
			}
		case "plantLocation":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.PlantLocation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plantLocation\"")
			}
		case "plantSite":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PlantSite = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plantSite\"")
			}
		case "defuseRoundTime":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.DefuseRoundTime = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defuseRoundTime\"")
			}
		case "defusePlayerLocations":
			if err := func() error {
				s.DefusePlayerLocations = make([]ValConsoleMatchV1PlayerLocationsDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValConsoleMatchV1PlayerLocationsDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DefusePlayerLocations = append(s.DefusePlayerLocations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defusePlayerLocations\"")
			}
		case "defuseLocation":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.DefuseLocation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defuseLocation\"")
			}
		case "playerStats":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				s.PlayerStats = make([]ValConsoleMatchV1PlayerRoundStatsDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValConsoleMatchV1PlayerRoundStatsDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PlayerStats = append(s.PlayerStats, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerStats\"")
			}
		case "roundResultCode":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.RoundResultCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roundResultCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValConsoleMatchV1RoundResultDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01001111,
		0b01110111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValConsoleMatchV1RoundResultDto) {
					name = jsonFieldsNameOfValConsoleMatchV1RoundResultDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValConsoleMatchV1RoundResultDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValConsoleMatchV1RoundResultDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValConsoleMatchV1TeamDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValConsoleMatchV1TeamDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("teamId")
		e.Str(s.TeamId)
	}
	{
		e.FieldStart("won")
		e.Bool(s.Won)
	}
	{
		e.FieldStart("roundsPlayed")
		e.Int32(s.RoundsPlayed)
	}
	{
		e.FieldStart("roundsWon")
		e.Int32(s.RoundsWon)
	}
	{
		e.FieldStart("numPoints")
		e.Int32(s.NumPoints)
	}
}

var jsonFieldsNameOfValConsoleMatchV1TeamDto = [5]string{
	0: "teamId",
	1: "won",
	2: "roundsPlayed",
	3: "roundsWon",
	4: "numPoints",
}

// Decode decodes ValConsoleMatchV1TeamDto from json.
func (s *ValConsoleMatchV1TeamDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValConsoleMatchV1TeamDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "teamId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TeamId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamId\"")
			}
		case "won":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Won = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"won\"")
			}
		case "roundsPlayed":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.RoundsPlayed = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roundsPlayed\"")
			}
		case "roundsWon":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.RoundsWon = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roundsWon\"")
			}
		case "numPoints":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.NumPoints = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numPoints\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValConsoleMatchV1TeamDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValConsoleMatchV1TeamDto) {
					name = jsonFieldsNameOfValConsoleMatchV1TeamDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValConsoleMatchV1TeamDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValConsoleMatchV1TeamDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValConsoleRankedV1LeaderboardDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValConsoleRankedV1LeaderboardDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("actId")
		e.Str(s.ActId)
	}
	{
		e.FieldStart("totalPlayers")
		e.Int64(s.TotalPlayers)
	}
	{
		if s.Query.Set {
			e.FieldStart("query")
			s.Query.Encode(e)
		}
	}
	{
		e.FieldStart("shard")
		e.Str(s.Shard)
	}
	{
		e.FieldStart("players")
		e.ArrStart()
		for _, elem := range s.Players {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.TierDetails != nil {
			e.FieldStart("tierDetails")
			e.ArrStart()
			for _, elem := range s.TierDetails {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfValConsoleRankedV1LeaderboardDto = [6]string{
	0: "actId",
	1: "totalPlayers",
	2: "query",
	3: "shard",
	4: "players",
	5: "tierDetails",
}

// Decode decodes ValConsoleRankedV1LeaderboardDto from json.
func (s *ValConsoleRankedV1LeaderboardDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValConsoleRankedV1LeaderboardDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "actId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ActId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actId\"")
			}
		case "totalPlayers":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.TotalPlayers = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalPlayers\"")
			}
		case "query":
			if err := func() error {
				s.Query.Reset()
				if err := s.Query.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		case "shard":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Shard = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shard\"")
			}
		case "players":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Players = make([]ValConsoleRankedV1PlayerDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValConsoleRankedV1PlayerDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Players = append(s.Players, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"players\"")
			}
		case "tierDetails":
			if err := func() error {
				s.TierDetails = make([]ValConsoleRankedV1TierDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValConsoleRankedV1TierDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TierDetails = append(s.TierDetails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tierDetails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValConsoleRankedV1LeaderboardDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValConsoleRankedV1LeaderboardDto) {
					name = jsonFieldsNameOfValConsoleRankedV1LeaderboardDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValConsoleRankedV1LeaderboardDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValConsoleRankedV1LeaderboardDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValConsoleRankedV1PlayerDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValConsoleRankedV1PlayerDto) encodeFields(e *jx.Encoder) {
	{
		if s.Puuid.Set {
			e.FieldStart("puuid")
			s.Puuid.Encode(e)
		}
	}
	{
		if s.GameName.Set {
			e.FieldStart("gameName")
			s.GameName.Encode(e)
		}
	}
	{
		if s.TagLine.Set {
			e.FieldStart("tagLine")
			s.TagLine.Encode(e)
		}
	}
	{
		e.FieldStart("leaderboardRank")
		e.Int64(s.LeaderboardRank)
	}
	{
		e.FieldStart("rankedRating")
		e.Int64(s.RankedRating)
	}
	{
		e.FieldStart("numberOfWins")
		e.Int64(s.NumberOfWins)
	}
}

var jsonFieldsNameOfValConsoleRankedV1PlayerDto = [6]string{
	0: "puuid",
	1: "gameName",
	2: "tagLine",
	3: "leaderboardRank",
	4: "rankedRating",
	5: "numberOfWins",
}

// Decode decodes ValConsoleRankedV1PlayerDto from json.
func (s *ValConsoleRankedV1PlayerDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValConsoleRankedV1PlayerDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "puuid":
			if err := func() error {
				s.Puuid.Reset()
				if err := s.Puuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "gameName":
			if err := func() error {
				s.GameName.Reset()
				if err := s.GameName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameName\"")
			}
		case "tagLine":
			if err := func() error {
				s.TagLine.Reset()
				if err := s.TagLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tagLine\"")
			}
		case "leaderboardRank":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int64()
				s.LeaderboardRank = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leaderboardRank\"")
			}
		case "rankedRating":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.RankedRating = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rankedRating\"")
			}
		case "numberOfWins":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.NumberOfWins = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numberOfWins\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValConsoleRankedV1PlayerDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValConsoleRankedV1PlayerDto) {
					name = jsonFieldsNameOfValConsoleRankedV1PlayerDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValConsoleRankedV1PlayerDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValConsoleRankedV1PlayerDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValConsoleRankedV1TierDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValConsoleRankedV1TierDto) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfValConsoleRankedV1TierDto = [0]string{}

// Decode decodes ValConsoleRankedV1TierDto from json.
func (s *ValConsoleRankedV1TierDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValConsoleRankedV1TierDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ValConsoleRankedV1TierDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValConsoleRankedV1TierDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValConsoleRankedV1TierDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValContentV1ActDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValContentV1ActDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.LocalizedNames.Set {
			e.FieldStart("localizedNames")
			s.LocalizedNames.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("isActive")
		e.Bool(s.IsActive)
	}
	{
		if s.ParentId.Set {
			e.FieldStart("parentId")
			s.ParentId.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfValContentV1ActDto = [6]string{
	0: "name",
	1: "localizedNames",
	2: "id",
	3: "isActive",
	4: "parentId",
	5: "type",
}

// Decode decodes ValContentV1ActDto from json.
func (s *ValContentV1ActDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValContentV1ActDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "localizedNames":
			if err := func() error {
				s.LocalizedNames.Reset()
				if err := s.LocalizedNames.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"localizedNames\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "isActive":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.IsActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isActive\"")
			}
		case "parentId":
			if err := func() error {
				s.ParentId.Reset()
				if err := s.ParentId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parentId\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValContentV1ActDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValContentV1ActDto) {
					name = jsonFieldsNameOfValContentV1ActDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValContentV1ActDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValContentV1ActDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValContentV1ContentDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValContentV1ContentDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("characters")
		e.ArrStart()
		for _, elem := range s.Characters {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("maps")
		e.ArrStart()
		for _, elem := range s.Maps {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("chromas")
		e.ArrStart()
		for _, elem := range s.Chromas {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("skins")
		e.ArrStart()
		for _, elem := range s.Skins {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("skinLevels")
		e.ArrStart()
		for _, elem := range s.SkinLevels {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("equips")
		e.ArrStart()
		for _, elem := range s.Equips {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("gameModes")
		e.ArrStart()
		for _, elem := range s.GameModes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("sprays")
		e.ArrStart()
		for _, elem := range s.Sprays {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("sprayLevels")
		e.ArrStart()
		for _, elem := range s.SprayLevels {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("charms")
		e.ArrStart()
		for _, elem := range s.Charms {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("charmLevels")
		e.ArrStart()
		for _, elem := range s.CharmLevels {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("playerCards")
		e.ArrStart()
		for _, elem := range s.PlayerCards {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("playerTitles")
		e.ArrStart()
		for _, elem := range s.PlayerTitles {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("acts")
		e.ArrStart()
		for _, elem := range s.Acts {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Ceremonies != nil {
			e.FieldStart("ceremonies")
			e.ArrStart()
			for _, elem := range s.Ceremonies {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Totems != nil {
			e.FieldStart("totems")
			e.ArrStart()
			for _, elem := range s.Totems {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfValContentV1ContentDto = [17]string{
	0:  "version",
	1:  "characters",
	2:  "maps",
	3:  "chromas",
	4:  "skins",
	5:  "skinLevels",
	6:  "equips",
	7:  "gameModes",
	8:  "sprays",
	9:  "sprayLevels",
	10: "charms",
	11: "charmLevels",
	12: "playerCards",
	13: "playerTitles",
	14: "acts",
	15: "ceremonies",
	16: "totems",
}

// Decode decodes ValContentV1ContentDto from json.
func (s *ValContentV1ContentDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValContentV1ContentDto to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "characters":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Characters = make([]ValContentV1ContentItemDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValContentV1ContentItemDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Characters = append(s.Characters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"characters\"")
			}
		case "maps":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Maps = make([]ValContentV1ContentItemDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValContentV1ContentItemDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Maps = append(s.Maps, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maps\"")
			}
		case "chromas":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Chromas = make([]ValContentV1ContentItemDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValContentV1ContentItemDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Chromas = append(s.Chromas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chromas\"")
			}
		case "skins":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Skins = make([]ValContentV1ContentItemDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValContentV1ContentItemDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Skins = append(s.Skins, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skins\"")
			}
		case "skinLevels":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.SkinLevels = make([]ValContentV1ContentItemDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValContentV1ContentItemDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SkinLevels = append(s.SkinLevels, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skinLevels\"")
			}
		case "equips":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.Equips = make([]ValContentV1ContentItemDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValContentV1ContentItemDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Equips = append(s.Equips, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"equips\"")
			}
		case "gameModes":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.GameModes = make([]ValContentV1ContentItemDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValContentV1ContentItemDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.GameModes = append(s.GameModes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameModes\"")
			}
		case "sprays":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.Sprays = make([]ValContentV1ContentItemDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValContentV1ContentItemDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Sprays = append(s.Sprays, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sprays\"")
			}
		case "sprayLevels":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				s.SprayLevels = make([]ValContentV1ContentItemDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValContentV1ContentItemDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SprayLevels = append(s.SprayLevels, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sprayLevels\"")
			}
		case "charms":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				s.Charms = make([]ValContentV1ContentItemDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValContentV1ContentItemDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Charms = append(s.Charms, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"charms\"")
			}
		case "charmLevels":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				s.CharmLevels = make([]ValContentV1ContentItemDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValContentV1ContentItemDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CharmLevels = append(s.CharmLevels, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"charmLevels\"")
			}
		case "playerCards":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				s.PlayerCards = make([]ValContentV1ContentItemDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValContentV1ContentItemDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PlayerCards = append(s.PlayerCards, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerCards\"")
			}
		case "playerTitles":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				s.PlayerTitles = make([]ValContentV1ContentItemDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValContentV1ContentItemDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PlayerTitles = append(s.PlayerTitles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerTitles\"")
			}
		case "acts":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				s.Acts = make([]ValContentV1ActDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValContentV1ActDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Acts = append(s.Acts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"acts\"")
			}
		case "ceremonies":
			if err := func() error {
				s.Ceremonies = make([]ValContentV1ContentItemDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValContentV1ContentItemDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ceremonies = append(s.Ceremonies, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ceremonies\"")
			}
		case "totems":
			if err := func() error {
				s.Totems = make([]ValContentV1ContentItemDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValContentV1ContentItemDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Totems = append(s.Totems, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totems\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValContentV1ContentDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b01111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValContentV1ContentDto) {
					name = jsonFieldsNameOfValContentV1ContentDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValContentV1ContentDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValContentV1ContentDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValContentV1ContentItemDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValContentV1ContentItemDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.LocalizedNames.Set {
			e.FieldStart("localizedNames")
			s.LocalizedNames.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("assetName")
		e.Str(s.AssetName)
	}
	{
		if s.AssetPath.Set {
			e.FieldStart("assetPath")
			s.AssetPath.Encode(e)
		}
	}
}

var jsonFieldsNameOfValContentV1ContentItemDto = [5]string{
	0: "name",
	1: "localizedNames",
	2: "id",
	3: "assetName",
	4: "assetPath",
}

// Decode decodes ValContentV1ContentItemDto from json.
func (s *ValContentV1ContentItemDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValContentV1ContentItemDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "localizedNames":
			if err := func() error {
				s.LocalizedNames.Reset()
				if err := s.LocalizedNames.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"localizedNames\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "assetName":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.AssetName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetName\"")
			}
		case "assetPath":
			if err := func() error {
				s.AssetPath.Reset()
				if err := s.AssetPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assetPath\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValContentV1ContentItemDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValContentV1ContentItemDto) {
					name = jsonFieldsNameOfValContentV1ContentItemDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValContentV1ContentItemDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValContentV1ContentItemDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValContentV1LocalizedNamesDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValContentV1LocalizedNamesDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ar-AE")
		e.Str(s.ArMinusAE)
	}
	{
		e.FieldStart("de-DE")
		e.Str(s.DeMinusDE)
	}
	{
		if s.EnMinusGB.Set {
			e.FieldStart("en-GB")
			s.EnMinusGB.Encode(e)
		}
	}
	{
		e.FieldStart("en-US")
		e.Str(s.EnMinusUS)
	}
	{
		e.FieldStart("es-ES")
		e.Str(s.EsMinusES)
	}
	{
		e.FieldStart("es-MX")
		e.Str(s.EsMinusMX)
	}
	{
		e.FieldStart("fr-FR")
		e.Str(s.FrMinusFR)
	}
	{
		e.FieldStart("id-ID")
		e.Str(s.IDMinusID)
	}
	{
		e.FieldStart("it-IT")
		e.Str(s.ItMinusIT)
	}
	{
		e.FieldStart("ja-JP")
		e.Str(s.JaMinusJP)
	}
	{
		e.FieldStart("ko-KR")
		e.Str(s.KoMinusKR)
	}
	{
		e.FieldStart("pl-PL")
		e.Str(s.PlMinusPL)
	}
	{
		e.FieldStart("pt-BR")
		e.Str(s.PtMinusBR)
	}
	{
		e.FieldStart("ru-RU")
		e.Str(s.RuMinusRU)
	}
	{
		e.FieldStart("th-TH")
		e.Str(s.ThMinusTH)
	}
	{
		e.FieldStart("tr-TR")
		e.Str(s.TrMinusTR)
	}
	{
		e.FieldStart("vi-VN")
		e.Str(s.ViMinusVN)
	}
	{
		e.FieldStart("zh-CN")
		e.Str(s.ZhMinusCN)
	}
	{
		e.FieldStart("zh-TW")
		e.Str(s.ZhMinusTW)
	}
}

var jsonFieldsNameOfValContentV1LocalizedNamesDto = [19]string{
	0:  "ar-AE",
	1:  "de-DE",
	2:  "en-GB",
	3:  "en-US",
	4:  "es-ES",
	5:  "es-MX",
	6:  "fr-FR",
	7:  "id-ID",
	8:  "it-IT",
	9:  "ja-JP",
	10: "ko-KR",
	11: "pl-PL",
	12: "pt-BR",
	13: "ru-RU",
	14: "th-TH",
	15: "tr-TR",
	16: "vi-VN",
	17: "zh-CN",
	18: "zh-TW",
}

// Decode decodes ValContentV1LocalizedNamesDto from json.
func (s *ValContentV1LocalizedNamesDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValContentV1LocalizedNamesDto to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ar-AE":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ArMinusAE = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ar-AE\"")
			}
		case "de-DE":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DeMinusDE = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"de-DE\"")
			}
		case "en-GB":
			if err := func() error {
				s.EnMinusGB.Reset()
				if err := s.EnMinusGB.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"en-GB\"")
			}
		case "en-US":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.EnMinusUS = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"en-US\"")
			}
		case "es-ES":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.EsMinusES = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"es-ES\"")
			}
		case "es-MX":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.EsMinusMX = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"es-MX\"")
			}
		case "fr-FR":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.FrMinusFR = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fr-FR\"")
			}
		case "id-ID":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.IDMinusID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id-ID\"")
			}
		case "it-IT":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ItMinusIT = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"it-IT\"")
			}
		case "ja-JP":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.JaMinusJP = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ja-JP\"")
			}
		case "ko-KR":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.KoMinusKR = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ko-KR\"")
			}
		case "pl-PL":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.PlMinusPL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pl-PL\"")
			}
		case "pt-BR":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.PtMinusBR = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pt-BR\"")
			}
		case "ru-RU":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.RuMinusRU = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ru-RU\"")
			}
		case "th-TH":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ThMinusTH = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"th-TH\"")
			}
		case "tr-TR":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.TrMinusTR = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tr-TR\"")
			}
		case "vi-VN":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ViMinusVN = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vi-VN\"")
			}
		case "zh-CN":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ZhMinusCN = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zh-CN\"")
			}
		case "zh-TW":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ZhMinusTW = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zh-TW\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValContentV1LocalizedNamesDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111011,
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValContentV1LocalizedNamesDto) {
					name = jsonFieldsNameOfValContentV1LocalizedNamesDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValContentV1LocalizedNamesDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValContentV1LocalizedNamesDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValMatchV1AbilityCastsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValMatchV1AbilityCastsDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("grenadeCasts")
		e.Int32(s.GrenadeCasts)
	}
	{
		e.FieldStart("ability1Casts")
		e.Int32(s.Ability1Casts)
	}
	{
		e.FieldStart("ability2Casts")
		e.Int32(s.Ability2Casts)
	}
	{
		e.FieldStart("ultimateCasts")
		e.Int32(s.UltimateCasts)
	}
}

var jsonFieldsNameOfValMatchV1AbilityCastsDto = [4]string{
	0: "grenadeCasts",
	1: "ability1Casts",
	2: "ability2Casts",
	3: "ultimateCasts",
}

// Decode decodes ValMatchV1AbilityCastsDto from json.
func (s *ValMatchV1AbilityCastsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValMatchV1AbilityCastsDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "grenadeCasts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.GrenadeCasts = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"grenadeCasts\"")
			}
		case "ability1Casts":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Ability1Casts = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ability1Casts\"")
			}
		case "ability2Casts":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Ability2Casts = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ability2Casts\"")
			}
		case "ultimateCasts":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.UltimateCasts = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ultimateCasts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValMatchV1AbilityCastsDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValMatchV1AbilityCastsDto) {
					name = jsonFieldsNameOfValMatchV1AbilityCastsDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValMatchV1AbilityCastsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValMatchV1AbilityCastsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValMatchV1AbilityDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValMatchV1AbilityDto) encodeFields(e *jx.Encoder) {
	{
		if s.GrenadeEffects.Set {
			e.FieldStart("grenadeEffects")
			s.GrenadeEffects.Encode(e)
		}
	}
	{
		if s.Ability1Effects.Set {
			e.FieldStart("ability1Effects")
			s.Ability1Effects.Encode(e)
		}
	}
	{
		if s.Ability2Effects.Set {
			e.FieldStart("ability2Effects")
			s.Ability2Effects.Encode(e)
		}
	}
	{
		if s.UltimateEffects.Set {
			e.FieldStart("ultimateEffects")
			s.UltimateEffects.Encode(e)
		}
	}
}

var jsonFieldsNameOfValMatchV1AbilityDto = [4]string{
	0: "grenadeEffects",
	1: "ability1Effects",
	2: "ability2Effects",
	3: "ultimateEffects",
}

// Decode decodes ValMatchV1AbilityDto from json.
func (s *ValMatchV1AbilityDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValMatchV1AbilityDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "grenadeEffects":
			if err := func() error {
				s.GrenadeEffects.Reset()
				if err := s.GrenadeEffects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"grenadeEffects\"")
			}
		case "ability1Effects":
			if err := func() error {
				s.Ability1Effects.Reset()
				if err := s.Ability1Effects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ability1Effects\"")
			}
		case "ability2Effects":
			if err := func() error {
				s.Ability2Effects.Reset()
				if err := s.Ability2Effects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ability2Effects\"")
			}
		case "ultimateEffects":
			if err := func() error {
				s.UltimateEffects.Reset()
				if err := s.UltimateEffects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ultimateEffects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValMatchV1AbilityDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValMatchV1AbilityDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValMatchV1AbilityDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValMatchV1CoachDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValMatchV1CoachDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		e.FieldStart("teamId")
		e.Str(s.TeamId)
	}
}

var jsonFieldsNameOfValMatchV1CoachDto = [2]string{
	0: "puuid",
	1: "teamId",
}

// Decode decodes ValMatchV1CoachDto from json.
func (s *ValMatchV1CoachDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValMatchV1CoachDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "puuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "teamId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TeamId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValMatchV1CoachDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValMatchV1CoachDto) {
					name = jsonFieldsNameOfValMatchV1CoachDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValMatchV1CoachDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValMatchV1CoachDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValMatchV1DamageDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValMatchV1DamageDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("receiver")
		e.Str(s.Receiver)
	}
	{
		e.FieldStart("damage")
		e.Int32(s.Damage)
	}
	{
		e.FieldStart("legshots")
		e.Int32(s.Legshots)
	}
	{
		e.FieldStart("bodyshots")
		e.Int32(s.Bodyshots)
	}
	{
		e.FieldStart("headshots")
		e.Int32(s.Headshots)
	}
}

var jsonFieldsNameOfValMatchV1DamageDto = [5]string{
	0: "receiver",
	1: "damage",
	2: "legshots",
	3: "bodyshots",
	4: "headshots",
}

// Decode decodes ValMatchV1DamageDto from json.
func (s *ValMatchV1DamageDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValMatchV1DamageDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "receiver":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Receiver = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"receiver\"")
			}
		case "damage":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Damage = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage\"")
			}
		case "legshots":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Legshots = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"legshots\"")
			}
		case "bodyshots":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Bodyshots = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bodyshots\"")
			}
		case "headshots":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Headshots = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headshots\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValMatchV1DamageDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValMatchV1DamageDto) {
					name = jsonFieldsNameOfValMatchV1DamageDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValMatchV1DamageDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValMatchV1DamageDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValMatchV1EconomyDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValMatchV1EconomyDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("loadoutValue")
		e.Int32(s.LoadoutValue)
	}
	{
		e.FieldStart("weapon")
		e.Str(s.Weapon)
	}
	{
		e.FieldStart("armor")
		e.Str(s.Armor)
	}
	{
		e.FieldStart("remaining")
		e.Int32(s.Remaining)
	}
	{
		e.FieldStart("spent")
		e.Int32(s.Spent)
	}
}

var jsonFieldsNameOfValMatchV1EconomyDto = [5]string{
	0: "loadoutValue",
	1: "weapon",
	2: "armor",
	3: "remaining",
	4: "spent",
}

// Decode decodes ValMatchV1EconomyDto from json.
func (s *ValMatchV1EconomyDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValMatchV1EconomyDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "loadoutValue":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.LoadoutValue = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loadoutValue\"")
			}
		case "weapon":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Weapon = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weapon\"")
			}
		case "armor":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Armor = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"armor\"")
			}
		case "remaining":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Remaining = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remaining\"")
			}
		case "spent":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Spent = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValMatchV1EconomyDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValMatchV1EconomyDto) {
					name = jsonFieldsNameOfValMatchV1EconomyDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValMatchV1EconomyDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValMatchV1EconomyDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValMatchV1FinishingDamageDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValMatchV1FinishingDamageDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("damageType")
		e.Str(s.DamageType)
	}
	{
		e.FieldStart("damageItem")
		e.Str(s.DamageItem)
	}
	{
		e.FieldStart("isSecondaryFireMode")
		e.Bool(s.IsSecondaryFireMode)
	}
}

var jsonFieldsNameOfValMatchV1FinishingDamageDto = [3]string{
	0: "damageType",
	1: "damageItem",
	2: "isSecondaryFireMode",
}

// Decode decodes ValMatchV1FinishingDamageDto from json.
func (s *ValMatchV1FinishingDamageDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValMatchV1FinishingDamageDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "damageType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DamageType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damageType\"")
			}
		case "damageItem":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DamageItem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damageItem\"")
			}
		case "isSecondaryFireMode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.IsSecondaryFireMode = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isSecondaryFireMode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValMatchV1FinishingDamageDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValMatchV1FinishingDamageDto) {
					name = jsonFieldsNameOfValMatchV1FinishingDamageDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValMatchV1FinishingDamageDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValMatchV1FinishingDamageDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValMatchV1KillDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValMatchV1KillDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("timeSinceGameStartMillis")
		e.Int32(s.TimeSinceGameStartMillis)
	}
	{
		e.FieldStart("timeSinceRoundStartMillis")
		e.Int32(s.TimeSinceRoundStartMillis)
	}
	{
		e.FieldStart("killer")
		e.Str(s.Killer)
	}
	{
		e.FieldStart("victim")
		e.Str(s.Victim)
	}
	{
		e.FieldStart("victimLocation")
		s.VictimLocation.Encode(e)
	}
	{
		e.FieldStart("assistants")
		e.ArrStart()
		for _, elem := range s.Assistants {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("playerLocations")
		e.ArrStart()
		for _, elem := range s.PlayerLocations {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("finishingDamage")
		s.FinishingDamage.Encode(e)
	}
}

var jsonFieldsNameOfValMatchV1KillDto = [8]string{
	0: "timeSinceGameStartMillis",
	1: "timeSinceRoundStartMillis",
	2: "killer",
	3: "victim",
	4: "victimLocation",
	5: "assistants",
	6: "playerLocations",
	7: "finishingDamage",
}

// Decode decodes ValMatchV1KillDto from json.
func (s *ValMatchV1KillDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValMatchV1KillDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timeSinceGameStartMillis":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.TimeSinceGameStartMillis = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeSinceGameStartMillis\"")
			}
		case "timeSinceRoundStartMillis":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.TimeSinceRoundStartMillis = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeSinceRoundStartMillis\"")
			}
		case "killer":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Killer = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"killer\"")
			}
		case "victim":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Victim = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"victim\"")
			}
		case "victimLocation":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.VictimLocation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"victimLocation\"")
			}
		case "assistants":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Assistants = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Assistants = append(s.Assistants, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assistants\"")
			}
		case "playerLocations":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.PlayerLocations = make([]ValMatchV1PlayerLocationsDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValMatchV1PlayerLocationsDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PlayerLocations = append(s.PlayerLocations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerLocations\"")
			}
		case "finishingDamage":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.FinishingDamage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finishingDamage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValMatchV1KillDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValMatchV1KillDto) {
					name = jsonFieldsNameOfValMatchV1KillDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValMatchV1KillDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValMatchV1KillDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValMatchV1LocationDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValMatchV1LocationDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("x")
		e.Int32(s.X)
	}
	{
		e.FieldStart("y")
		e.Int32(s.Y)
	}
}

var jsonFieldsNameOfValMatchV1LocationDto = [2]string{
	0: "x",
	1: "y",
}

// Decode decodes ValMatchV1LocationDto from json.
func (s *ValMatchV1LocationDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValMatchV1LocationDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "x":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.X = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"x\"")
			}
		case "y":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Y = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"y\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValMatchV1LocationDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValMatchV1LocationDto) {
					name = jsonFieldsNameOfValMatchV1LocationDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValMatchV1LocationDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValMatchV1LocationDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValMatchV1MatchDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValMatchV1MatchDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("matchInfo")
		s.MatchInfo.Encode(e)
	}
	{
		e.FieldStart("players")
		e.ArrStart()
		for _, elem := range s.Players {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("coaches")
		e.ArrStart()
		for _, elem := range s.Coaches {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Teams != nil {
			e.FieldStart("teams")
			e.ArrStart()
			for _, elem := range s.Teams {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RoundResults != nil {
			e.FieldStart("roundResults")
			e.ArrStart()
			for _, elem := range s.RoundResults {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfValMatchV1MatchDto = [5]string{
	0: "matchInfo",
	1: "players",
	2: "coaches",
	3: "teams",
	4: "roundResults",
}

// Decode decodes ValMatchV1MatchDto from json.
func (s *ValMatchV1MatchDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValMatchV1MatchDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchInfo":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.MatchInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchInfo\"")
			}
		case "players":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Players = make([]ValMatchV1PlayerDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValMatchV1PlayerDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Players = append(s.Players, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"players\"")
			}
		case "coaches":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Coaches = make([]ValMatchV1CoachDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValMatchV1CoachDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Coaches = append(s.Coaches, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"coaches\"")
			}
		case "teams":
			if err := func() error {
				s.Teams = make([]ValMatchV1TeamDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValMatchV1TeamDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		case "roundResults":
			if err := func() error {
				s.RoundResults = make([]ValMatchV1RoundResultDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValMatchV1RoundResultDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RoundResults = append(s.RoundResults, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roundResults\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValMatchV1MatchDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValMatchV1MatchDto) {
					name = jsonFieldsNameOfValMatchV1MatchDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValMatchV1MatchDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValMatchV1MatchDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValMatchV1MatchInfoDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValMatchV1MatchInfoDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("matchId")
		e.Str(s.MatchId)
	}
	{
		e.FieldStart("mapId")
		e.Str(s.MapId)
	}
	{
		e.FieldStart("gameVersion")
		e.Str(s.GameVersion)
	}
	{
		if s.GameLengthMillis.Set {
			e.FieldStart("gameLengthMillis")
			s.GameLengthMillis.Encode(e)
		}
	}
	{
		e.FieldStart("region")
		e.Str(s.Region)
	}
	{
		e.FieldStart("gameStartMillis")
		e.Int64(s.GameStartMillis)
	}
	{
		e.FieldStart("provisioningFlowId")
		e.Str(s.ProvisioningFlowId)
	}
	{
		e.FieldStart("isCompleted")
		e.Bool(s.IsCompleted)
	}
	{
		e.FieldStart("customGameName")
		e.Str(s.CustomGameName)
	}
	{
		e.FieldStart("queueId")
		e.Str(s.QueueId)
	}
	{
		e.FieldStart("gameMode")
		e.Str(s.GameMode)
	}
	{
		e.FieldStart("isRanked")
		e.Bool(s.IsRanked)
	}
	{
		e.FieldStart("seasonId")
		e.Str(s.SeasonId)
	}
	{
		e.FieldStart("premierMatchInfo")
		s.PremierMatchInfo.Encode(e)
	}
}

var jsonFieldsNameOfValMatchV1MatchInfoDto = [14]string{
	0:  "matchId",
	1:  "mapId",
	2:  "gameVersion",
	3:  "gameLengthMillis",
	4:  "region",
	5:  "gameStartMillis",
	6:  "provisioningFlowId",
	7:  "isCompleted",
	8:  "customGameName",
	9:  "queueId",
	10: "gameMode",
	11: "isRanked",
	12: "seasonId",
	13: "premierMatchInfo",
}

// Decode decodes ValMatchV1MatchInfoDto from json.
func (s *ValMatchV1MatchInfoDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValMatchV1MatchInfoDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MatchId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchId\"")
			}
		case "mapId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.MapId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mapId\"")
			}
		case "gameVersion":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GameVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameVersion\"")
			}
		case "gameLengthMillis":
			if err := func() error {
				s.GameLengthMillis.Reset()
				if err := s.GameLengthMillis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameLengthMillis\"")
			}
		case "region":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Region = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "gameStartMillis":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.GameStartMillis = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameStartMillis\"")
			}
		case "provisioningFlowId":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ProvisioningFlowId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provisioningFlowId\"")
			}
		case "isCompleted":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsCompleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isCompleted\"")
			}
		case "customGameName":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CustomGameName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customGameName\"")
			}
		case "queueId":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.QueueId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queueId\"")
			}
		case "gameMode":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GameMode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameMode\"")
			}
		case "isRanked":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.IsRanked = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isRanked\"")
			}
		case "seasonId":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SeasonId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seasonId\"")
			}
		case "premierMatchInfo":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.PremierMatchInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"premierMatchInfo\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValMatchV1MatchInfoDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11110111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValMatchV1MatchInfoDto) {
					name = jsonFieldsNameOfValMatchV1MatchInfoDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValMatchV1MatchInfoDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValMatchV1MatchInfoDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValMatchV1MatchInfoDtoPremierMatchInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValMatchV1MatchInfoDtoPremierMatchInfo) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfValMatchV1MatchInfoDtoPremierMatchInfo = [0]string{}

// Decode decodes ValMatchV1MatchInfoDtoPremierMatchInfo from json.
func (s *ValMatchV1MatchInfoDtoPremierMatchInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValMatchV1MatchInfoDtoPremierMatchInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ValMatchV1MatchInfoDtoPremierMatchInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValMatchV1MatchInfoDtoPremierMatchInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValMatchV1MatchInfoDtoPremierMatchInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValMatchV1MatchlistDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValMatchV1MatchlistDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		e.FieldStart("history")
		e.ArrStart()
		for _, elem := range s.History {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfValMatchV1MatchlistDto = [2]string{
	0: "puuid",
	1: "history",
}

// Decode decodes ValMatchV1MatchlistDto from json.
func (s *ValMatchV1MatchlistDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValMatchV1MatchlistDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "puuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "history":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.History = make([]ValMatchV1MatchlistEntryDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValMatchV1MatchlistEntryDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.History = append(s.History, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"history\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValMatchV1MatchlistDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValMatchV1MatchlistDto) {
					name = jsonFieldsNameOfValMatchV1MatchlistDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValMatchV1MatchlistDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValMatchV1MatchlistDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValMatchV1MatchlistEntryDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValMatchV1MatchlistEntryDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("matchId")
		e.Str(s.MatchId)
	}
	{
		e.FieldStart("gameStartTimeMillis")
		e.Int64(s.GameStartTimeMillis)
	}
	{
		e.FieldStart("queueId")
		e.Str(s.QueueId)
	}
}

var jsonFieldsNameOfValMatchV1MatchlistEntryDto = [3]string{
	0: "matchId",
	1: "gameStartTimeMillis",
	2: "queueId",
}

// Decode decodes ValMatchV1MatchlistEntryDto from json.
func (s *ValMatchV1MatchlistEntryDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValMatchV1MatchlistEntryDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MatchId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchId\"")
			}
		case "gameStartTimeMillis":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.GameStartTimeMillis = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameStartTimeMillis\"")
			}
		case "queueId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.QueueId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queueId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValMatchV1MatchlistEntryDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValMatchV1MatchlistEntryDto) {
					name = jsonFieldsNameOfValMatchV1MatchlistEntryDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValMatchV1MatchlistEntryDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValMatchV1MatchlistEntryDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValMatchV1PlayerDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValMatchV1PlayerDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		e.FieldStart("gameName")
		e.Str(s.GameName)
	}
	{
		e.FieldStart("tagLine")
		e.Str(s.TagLine)
	}
	{
		e.FieldStart("teamId")
		e.Str(s.TeamId)
	}
	{
		e.FieldStart("partyId")
		e.Str(s.PartyId)
	}
	{
		if s.CharacterId.Set {
			e.FieldStart("characterId")
			s.CharacterId.Encode(e)
		}
	}
	{
		if s.Stats.Set {
			e.FieldStart("stats")
			s.Stats.Encode(e)
		}
	}
	{
		e.FieldStart("competitiveTier")
		e.Int32(s.CompetitiveTier)
	}
	{
		e.FieldStart("isObserver")
		e.Bool(s.IsObserver)
	}
	{
		e.FieldStart("playerCard")
		e.Str(s.PlayerCard)
	}
	{
		e.FieldStart("playerTitle")
		e.Str(s.PlayerTitle)
	}
	{
		e.FieldStart("accountLevel")
		e.Int32(s.AccountLevel)
	}
}

var jsonFieldsNameOfValMatchV1PlayerDto = [12]string{
	0:  "puuid",
	1:  "gameName",
	2:  "tagLine",
	3:  "teamId",
	4:  "partyId",
	5:  "characterId",
	6:  "stats",
	7:  "competitiveTier",
	8:  "isObserver",
	9:  "playerCard",
	10: "playerTitle",
	11: "accountLevel",
}

// Decode decodes ValMatchV1PlayerDto from json.
func (s *ValMatchV1PlayerDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValMatchV1PlayerDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "puuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "gameName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.GameName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameName\"")
			}
		case "tagLine":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TagLine = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tagLine\"")
			}
		case "teamId":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TeamId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamId\"")
			}
		case "partyId":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.PartyId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partyId\"")
			}
		case "characterId":
			if err := func() error {
				s.CharacterId.Reset()
				if err := s.CharacterId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"characterId\"")
			}
		case "stats":
			if err := func() error {
				s.Stats.Reset()
				if err := s.Stats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stats\"")
			}
		case "competitiveTier":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.CompetitiveTier = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"competitiveTier\"")
			}
		case "isObserver":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsObserver = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isObserver\"")
			}
		case "playerCard":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PlayerCard = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerCard\"")
			}
		case "playerTitle":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PlayerTitle = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerTitle\"")
			}
		case "accountLevel":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.AccountLevel = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountLevel\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValMatchV1PlayerDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10011111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValMatchV1PlayerDto) {
					name = jsonFieldsNameOfValMatchV1PlayerDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValMatchV1PlayerDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValMatchV1PlayerDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValMatchV1PlayerLocationsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValMatchV1PlayerLocationsDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		e.FieldStart("viewRadians")
		e.Float32(s.ViewRadians)
	}
	{
		e.FieldStart("location")
		s.Location.Encode(e)
	}
}

var jsonFieldsNameOfValMatchV1PlayerLocationsDto = [3]string{
	0: "puuid",
	1: "viewRadians",
	2: "location",
}

// Decode decodes ValMatchV1PlayerLocationsDto from json.
func (s *ValMatchV1PlayerLocationsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValMatchV1PlayerLocationsDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "puuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "viewRadians":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.ViewRadians = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewRadians\"")
			}
		case "location":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Location.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"location\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValMatchV1PlayerLocationsDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValMatchV1PlayerLocationsDto) {
					name = jsonFieldsNameOfValMatchV1PlayerLocationsDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValMatchV1PlayerLocationsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValMatchV1PlayerLocationsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValMatchV1PlayerRoundStatsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValMatchV1PlayerRoundStatsDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("puuid")
		e.Str(s.Puuid)
	}
	{
		e.FieldStart("kills")
		e.ArrStart()
		for _, elem := range s.Kills {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("damage")
		e.ArrStart()
		for _, elem := range s.Damage {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("score")
		e.Int32(s.Score)
	}
	{
		e.FieldStart("economy")
		s.Economy.Encode(e)
	}
	{
		e.FieldStart("ability")
		s.Ability.Encode(e)
	}
}

var jsonFieldsNameOfValMatchV1PlayerRoundStatsDto = [6]string{
	0: "puuid",
	1: "kills",
	2: "damage",
	3: "score",
	4: "economy",
	5: "ability",
}

// Decode decodes ValMatchV1PlayerRoundStatsDto from json.
func (s *ValMatchV1PlayerRoundStatsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValMatchV1PlayerRoundStatsDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "puuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Puuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "kills":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Kills = make([]ValMatchV1KillDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValMatchV1KillDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Kills = append(s.Kills, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kills\"")
			}
		case "damage":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Damage = make([]ValMatchV1DamageDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValMatchV1DamageDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Damage = append(s.Damage, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"damage\"")
			}
		case "score":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Score = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "economy":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Economy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"economy\"")
			}
		case "ability":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Ability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ability\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValMatchV1PlayerRoundStatsDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValMatchV1PlayerRoundStatsDto) {
					name = jsonFieldsNameOfValMatchV1PlayerRoundStatsDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValMatchV1PlayerRoundStatsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValMatchV1PlayerRoundStatsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValMatchV1PlayerStatsDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValMatchV1PlayerStatsDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("score")
		e.Int32(s.Score)
	}
	{
		e.FieldStart("roundsPlayed")
		e.Int32(s.RoundsPlayed)
	}
	{
		e.FieldStart("kills")
		e.Int32(s.Kills)
	}
	{
		e.FieldStart("deaths")
		e.Int32(s.Deaths)
	}
	{
		e.FieldStart("assists")
		e.Int32(s.Assists)
	}
	{
		e.FieldStart("playtimeMillis")
		e.Int32(s.PlaytimeMillis)
	}
	{
		if s.AbilityCasts.Set {
			e.FieldStart("abilityCasts")
			s.AbilityCasts.Encode(e)
		}
	}
}

var jsonFieldsNameOfValMatchV1PlayerStatsDto = [7]string{
	0: "score",
	1: "roundsPlayed",
	2: "kills",
	3: "deaths",
	4: "assists",
	5: "playtimeMillis",
	6: "abilityCasts",
}

// Decode decodes ValMatchV1PlayerStatsDto from json.
func (s *ValMatchV1PlayerStatsDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValMatchV1PlayerStatsDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "score":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Score = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "roundsPlayed":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.RoundsPlayed = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roundsPlayed\"")
			}
		case "kills":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Kills = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kills\"")
			}
		case "deaths":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Deaths = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deaths\"")
			}
		case "assists":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Assists = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assists\"")
			}
		case "playtimeMillis":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int32()
				s.PlaytimeMillis = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playtimeMillis\"")
			}
		case "abilityCasts":
			if err := func() error {
				s.AbilityCasts.Reset()
				if err := s.AbilityCasts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"abilityCasts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValMatchV1PlayerStatsDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValMatchV1PlayerStatsDto) {
					name = jsonFieldsNameOfValMatchV1PlayerStatsDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValMatchV1PlayerStatsDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValMatchV1PlayerStatsDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValMatchV1RecentMatchesDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValMatchV1RecentMatchesDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("currentTime")
		e.Int64(s.CurrentTime)
	}
	{
		e.FieldStart("matchIds")
		e.ArrStart()
		for _, elem := range s.MatchIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfValMatchV1RecentMatchesDto = [2]string{
	0: "currentTime",
	1: "matchIds",
}

// Decode decodes ValMatchV1RecentMatchesDto from json.
func (s *ValMatchV1RecentMatchesDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValMatchV1RecentMatchesDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currentTime":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.CurrentTime = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentTime\"")
			}
		case "matchIds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.MatchIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.MatchIds = append(s.MatchIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchIds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValMatchV1RecentMatchesDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValMatchV1RecentMatchesDto) {
					name = jsonFieldsNameOfValMatchV1RecentMatchesDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValMatchV1RecentMatchesDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValMatchV1RecentMatchesDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValMatchV1RoundResultDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValMatchV1RoundResultDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("roundNum")
		e.Int32(s.RoundNum)
	}
	{
		e.FieldStart("roundResult")
		e.Str(s.RoundResult)
	}
	{
		e.FieldStart("roundCeremony")
		e.Str(s.RoundCeremony)
	}
	{
		e.FieldStart("winningTeam")
		e.Str(s.WinningTeam)
	}
	{
		e.FieldStart("winningTeamRole")
		e.Str(s.WinningTeamRole)
	}
	{
		if s.BombPlanter.Set {
			e.FieldStart("bombPlanter")
			s.BombPlanter.Encode(e)
		}
	}
	{
		if s.BombDefuser.Set {
			e.FieldStart("bombDefuser")
			s.BombDefuser.Encode(e)
		}
	}
	{
		e.FieldStart("plantRoundTime")
		e.Int32(s.PlantRoundTime)
	}
	{
		if s.PlantPlayerLocations != nil {
			e.FieldStart("plantPlayerLocations")
			e.ArrStart()
			for _, elem := range s.PlantPlayerLocations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("plantLocation")
		s.PlantLocation.Encode(e)
	}
	{
		e.FieldStart("plantSite")
		e.Str(s.PlantSite)
	}
	{
		e.FieldStart("defuseRoundTime")
		e.Int32(s.DefuseRoundTime)
	}
	{
		if s.DefusePlayerLocations != nil {
			e.FieldStart("defusePlayerLocations")
			e.ArrStart()
			for _, elem := range s.DefusePlayerLocations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("defuseLocation")
		s.DefuseLocation.Encode(e)
	}
	{
		e.FieldStart("playerStats")
		e.ArrStart()
		for _, elem := range s.PlayerStats {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("roundResultCode")
		e.Str(s.RoundResultCode)
	}
}

var jsonFieldsNameOfValMatchV1RoundResultDto = [16]string{
	0:  "roundNum",
	1:  "roundResult",
	2:  "roundCeremony",
	3:  "winningTeam",
	4:  "winningTeamRole",
	5:  "bombPlanter",
	6:  "bombDefuser",
	7:  "plantRoundTime",
	8:  "plantPlayerLocations",
	9:  "plantLocation",
	10: "plantSite",
	11: "defuseRoundTime",
	12: "defusePlayerLocations",
	13: "defuseLocation",
	14: "playerStats",
	15: "roundResultCode",
}

// Decode decodes ValMatchV1RoundResultDto from json.
func (s *ValMatchV1RoundResultDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValMatchV1RoundResultDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "roundNum":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.RoundNum = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roundNum\"")
			}
		case "roundResult":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RoundResult = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roundResult\"")
			}
		case "roundCeremony":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.RoundCeremony = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roundCeremony\"")
			}
		case "winningTeam":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.WinningTeam = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"winningTeam\"")
			}
		case "winningTeamRole":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.WinningTeamRole = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"winningTeamRole\"")
			}
		case "bombPlanter":
			if err := func() error {
				s.BombPlanter.Reset()
				if err := s.BombPlanter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bombPlanter\"")
			}
		case "bombDefuser":
			if err := func() error {
				s.BombDefuser.Reset()
				if err := s.BombDefuser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bombDefuser\"")
			}
		case "plantRoundTime":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.PlantRoundTime = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plantRoundTime\"")
			}
		case "plantPlayerLocations":
			if err := func() error {
				s.PlantPlayerLocations = make([]ValMatchV1PlayerLocationsDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValMatchV1PlayerLocationsDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PlantPlayerLocations = append(s.PlantPlayerLocations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plantPlayerLocations\"")
			}
		case "plantLocation":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.PlantLocation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plantLocation\"")
			}
		case "plantSite":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PlantSite = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plantSite\"")
			}
		case "defuseRoundTime":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.DefuseRoundTime = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defuseRoundTime\"")
			}
		case "defusePlayerLocations":
			if err := func() error {
				s.DefusePlayerLocations = make([]ValMatchV1PlayerLocationsDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValMatchV1PlayerLocationsDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DefusePlayerLocations = append(s.DefusePlayerLocations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defusePlayerLocations\"")
			}
		case "defuseLocation":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.DefuseLocation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defuseLocation\"")
			}
		case "playerStats":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				s.PlayerStats = make([]ValMatchV1PlayerRoundStatsDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValMatchV1PlayerRoundStatsDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PlayerStats = append(s.PlayerStats, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"playerStats\"")
			}
		case "roundResultCode":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.RoundResultCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roundResultCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValMatchV1RoundResultDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10011111,
		0b11101110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValMatchV1RoundResultDto) {
					name = jsonFieldsNameOfValMatchV1RoundResultDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValMatchV1RoundResultDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValMatchV1RoundResultDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValMatchV1TeamDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValMatchV1TeamDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("teamId")
		e.Str(s.TeamId)
	}
	{
		e.FieldStart("won")
		e.Bool(s.Won)
	}
	{
		e.FieldStart("roundsPlayed")
		e.Int32(s.RoundsPlayed)
	}
	{
		e.FieldStart("roundsWon")
		e.Int32(s.RoundsWon)
	}
	{
		e.FieldStart("numPoints")
		e.Int32(s.NumPoints)
	}
}

var jsonFieldsNameOfValMatchV1TeamDto = [5]string{
	0: "teamId",
	1: "won",
	2: "roundsPlayed",
	3: "roundsWon",
	4: "numPoints",
}

// Decode decodes ValMatchV1TeamDto from json.
func (s *ValMatchV1TeamDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValMatchV1TeamDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "teamId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TeamId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamId\"")
			}
		case "won":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Won = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"won\"")
			}
		case "roundsPlayed":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.RoundsPlayed = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roundsPlayed\"")
			}
		case "roundsWon":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.RoundsWon = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roundsWon\"")
			}
		case "numPoints":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.NumPoints = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numPoints\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValMatchV1TeamDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValMatchV1TeamDto) {
					name = jsonFieldsNameOfValMatchV1TeamDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValMatchV1TeamDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValMatchV1TeamDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValRankedV1LeaderboardDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValRankedV1LeaderboardDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("shard")
		e.Str(s.Shard)
	}
	{
		e.FieldStart("actId")
		e.Str(s.ActId)
	}
	{
		e.FieldStart("totalPlayers")
		e.Int64(s.TotalPlayers)
	}
	{
		e.FieldStart("players")
		e.ArrStart()
		for _, elem := range s.Players {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.ImmortalStartingPage.Set {
			e.FieldStart("immortalStartingPage")
			s.ImmortalStartingPage.Encode(e)
		}
	}
	{
		if s.ImmortalStartingIndex.Set {
			e.FieldStart("immortalStartingIndex")
			s.ImmortalStartingIndex.Encode(e)
		}
	}
	{
		if s.TopTierRRThreshold.Set {
			e.FieldStart("topTierRRThreshold")
			s.TopTierRRThreshold.Encode(e)
		}
	}
	{
		if s.TierDetails.Set {
			e.FieldStart("tierDetails")
			s.TierDetails.Encode(e)
		}
	}
	{
		if s.StartIndex.Set {
			e.FieldStart("startIndex")
			s.StartIndex.Encode(e)
		}
	}
	{
		if s.Query.Set {
			e.FieldStart("query")
			s.Query.Encode(e)
		}
	}
}

var jsonFieldsNameOfValRankedV1LeaderboardDto = [10]string{
	0: "shard",
	1: "actId",
	2: "totalPlayers",
	3: "players",
	4: "immortalStartingPage",
	5: "immortalStartingIndex",
	6: "topTierRRThreshold",
	7: "tierDetails",
	8: "startIndex",
	9: "query",
}

// Decode decodes ValRankedV1LeaderboardDto from json.
func (s *ValRankedV1LeaderboardDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValRankedV1LeaderboardDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "shard":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Shard = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shard\"")
			}
		case "actId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ActId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actId\"")
			}
		case "totalPlayers":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.TotalPlayers = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalPlayers\"")
			}
		case "players":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Players = make([]ValRankedV1PlayerDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValRankedV1PlayerDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Players = append(s.Players, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"players\"")
			}
		case "immortalStartingPage":
			if err := func() error {
				s.ImmortalStartingPage.Reset()
				if err := s.ImmortalStartingPage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"immortalStartingPage\"")
			}
		case "immortalStartingIndex":
			if err := func() error {
				s.ImmortalStartingIndex.Reset()
				if err := s.ImmortalStartingIndex.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"immortalStartingIndex\"")
			}
		case "topTierRRThreshold":
			if err := func() error {
				s.TopTierRRThreshold.Reset()
				if err := s.TopTierRRThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topTierRRThreshold\"")
			}
		case "tierDetails":
			if err := func() error {
				s.TierDetails.Reset()
				if err := s.TierDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tierDetails\"")
			}
		case "startIndex":
			if err := func() error {
				s.StartIndex.Reset()
				if err := s.StartIndex.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startIndex\"")
			}
		case "query":
			if err := func() error {
				s.Query.Reset()
				if err := s.Query.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValRankedV1LeaderboardDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValRankedV1LeaderboardDto) {
					name = jsonFieldsNameOfValRankedV1LeaderboardDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValRankedV1LeaderboardDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValRankedV1LeaderboardDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ValRankedV1LeaderboardDtoTierDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ValRankedV1LeaderboardDtoTierDetails) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes ValRankedV1LeaderboardDtoTierDetails from json.
func (s *ValRankedV1LeaderboardDtoTierDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValRankedV1LeaderboardDtoTierDetails to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem ValRankedV1TierDetailDto
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValRankedV1LeaderboardDtoTierDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ValRankedV1LeaderboardDtoTierDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValRankedV1LeaderboardDtoTierDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValRankedV1PlayerDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValRankedV1PlayerDto) encodeFields(e *jx.Encoder) {
	{
		if s.Puuid.Set {
			e.FieldStart("puuid")
			s.Puuid.Encode(e)
		}
	}
	{
		if s.GameName.Set {
			e.FieldStart("gameName")
			s.GameName.Encode(e)
		}
	}
	{
		if s.TagLine.Set {
			e.FieldStart("tagLine")
			s.TagLine.Encode(e)
		}
	}
	{
		e.FieldStart("leaderboardRank")
		e.Int64(s.LeaderboardRank)
	}
	{
		e.FieldStart("rankedRating")
		e.Int64(s.RankedRating)
	}
	{
		e.FieldStart("numberOfWins")
		e.Int64(s.NumberOfWins)
	}
	{
		if s.CompetitiveTier.Set {
			e.FieldStart("competitiveTier")
			s.CompetitiveTier.Encode(e)
		}
	}
	{
		if s.Prefix.Set {
			e.FieldStart("prefix")
			s.Prefix.Encode(e)
		}
	}
}

var jsonFieldsNameOfValRankedV1PlayerDto = [8]string{
	0: "puuid",
	1: "gameName",
	2: "tagLine",
	3: "leaderboardRank",
	4: "rankedRating",
	5: "numberOfWins",
	6: "competitiveTier",
	7: "prefix",
}

// Decode decodes ValRankedV1PlayerDto from json.
func (s *ValRankedV1PlayerDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValRankedV1PlayerDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "puuid":
			if err := func() error {
				s.Puuid.Reset()
				if err := s.Puuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"puuid\"")
			}
		case "gameName":
			if err := func() error {
				s.GameName.Reset()
				if err := s.GameName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gameName\"")
			}
		case "tagLine":
			if err := func() error {
				s.TagLine.Reset()
				if err := s.TagLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tagLine\"")
			}
		case "leaderboardRank":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int64()
				s.LeaderboardRank = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leaderboardRank\"")
			}
		case "rankedRating":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.RankedRating = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rankedRating\"")
			}
		case "numberOfWins":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.NumberOfWins = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numberOfWins\"")
			}
		case "competitiveTier":
			if err := func() error {
				s.CompetitiveTier.Reset()
				if err := s.CompetitiveTier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"competitiveTier\"")
			}
		case "prefix":
			if err := func() error {
				s.Prefix.Reset()
				if err := s.Prefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prefix\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValRankedV1PlayerDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValRankedV1PlayerDto) {
					name = jsonFieldsNameOfValRankedV1PlayerDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValRankedV1PlayerDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValRankedV1PlayerDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValRankedV1TierDetailDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValRankedV1TierDetailDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("rankedRatingThreshold")
		e.Int64(s.RankedRatingThreshold)
	}
	{
		e.FieldStart("startingPage")
		e.Int64(s.StartingPage)
	}
	{
		e.FieldStart("startingIndex")
		e.Int64(s.StartingIndex)
	}
}

var jsonFieldsNameOfValRankedV1TierDetailDto = [3]string{
	0: "rankedRatingThreshold",
	1: "startingPage",
	2: "startingIndex",
}

// Decode decodes ValRankedV1TierDetailDto from json.
func (s *ValRankedV1TierDetailDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValRankedV1TierDetailDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rankedRatingThreshold":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.RankedRatingThreshold = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rankedRatingThreshold\"")
			}
		case "startingPage":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.StartingPage = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startingPage\"")
			}
		case "startingIndex":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.StartingIndex = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startingIndex\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValRankedV1TierDetailDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValRankedV1TierDetailDto) {
					name = jsonFieldsNameOfValRankedV1TierDetailDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValRankedV1TierDetailDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValRankedV1TierDetailDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValStatusV1ContentDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValStatusV1ContentDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("locale")
		e.Str(s.Locale)
	}
	{
		e.FieldStart("content")
		e.Str(s.Content)
	}
}

var jsonFieldsNameOfValStatusV1ContentDto = [2]string{
	0: "locale",
	1: "content",
}

// Decode decodes ValStatusV1ContentDto from json.
func (s *ValStatusV1ContentDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValStatusV1ContentDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "locale":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Locale = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locale\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValStatusV1ContentDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValStatusV1ContentDto) {
					name = jsonFieldsNameOfValStatusV1ContentDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValStatusV1ContentDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValStatusV1ContentDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValStatusV1PlatformDataDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValStatusV1PlatformDataDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("locales")
		e.ArrStart()
		for _, elem := range s.Locales {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("maintenances")
		e.ArrStart()
		for _, elem := range s.Maintenances {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("incidents")
		e.ArrStart()
		for _, elem := range s.Incidents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfValStatusV1PlatformDataDto = [5]string{
	0: "id",
	1: "name",
	2: "locales",
	3: "maintenances",
	4: "incidents",
}

// Decode decodes ValStatusV1PlatformDataDto from json.
func (s *ValStatusV1PlatformDataDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValStatusV1PlatformDataDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "locales":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Locales = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Locales = append(s.Locales, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locales\"")
			}
		case "maintenances":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Maintenances = make([]ValStatusV1StatusDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValStatusV1StatusDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Maintenances = append(s.Maintenances, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenances\"")
			}
		case "incidents":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Incidents = make([]ValStatusV1StatusDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValStatusV1StatusDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Incidents = append(s.Incidents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incidents\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValStatusV1PlatformDataDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValStatusV1PlatformDataDto) {
					name = jsonFieldsNameOfValStatusV1PlatformDataDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValStatusV1PlatformDataDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValStatusV1PlatformDataDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValStatusV1StatusDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValStatusV1StatusDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int32(s.ID)
	}
	{
		e.FieldStart("maintenance_status")
		s.MaintenanceStatus.Encode(e)
	}
	{
		e.FieldStart("incident_severity")
		s.IncidentSeverity.Encode(e)
	}
	{
		e.FieldStart("titles")
		e.ArrStart()
		for _, elem := range s.Titles {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("updates")
		e.ArrStart()
		for _, elem := range s.Updates {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("created_at")
		e.Str(s.CreatedAt)
	}
	{
		e.FieldStart("archive_at")
		e.Str(s.ArchiveAt)
	}
	{
		e.FieldStart("updated_at")
		e.Str(s.UpdatedAt)
	}
	{
		e.FieldStart("platforms")
		e.ArrStart()
		for _, elem := range s.Platforms {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfValStatusV1StatusDto = [9]string{
	0: "id",
	1: "maintenance_status",
	2: "incident_severity",
	3: "titles",
	4: "updates",
	5: "created_at",
	6: "archive_at",
	7: "updated_at",
	8: "platforms",
}

// Decode decodes ValStatusV1StatusDto from json.
func (s *ValStatusV1StatusDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValStatusV1StatusDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ID = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "maintenance_status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.MaintenanceStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenance_status\"")
			}
		case "incident_severity":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.IncidentSeverity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incident_severity\"")
			}
		case "titles":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Titles = make([]ValStatusV1ContentDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValStatusV1ContentDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Titles = append(s.Titles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"titles\"")
			}
		case "updates":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Updates = make([]ValStatusV1UpdateDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValStatusV1UpdateDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Updates = append(s.Updates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updates\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "archive_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ArchiveAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archive_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "platforms":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.Platforms = make([]ValStatusV1StatusDtoPlatformsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValStatusV1StatusDtoPlatformsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Platforms = append(s.Platforms, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platforms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValStatusV1StatusDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValStatusV1StatusDto) {
					name = jsonFieldsNameOfValStatusV1StatusDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValStatusV1StatusDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValStatusV1StatusDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValStatusV1StatusDtoIncidentSeverity as json.
func (s ValStatusV1StatusDtoIncidentSeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ValStatusV1StatusDtoIncidentSeverity from json.
func (s *ValStatusV1StatusDtoIncidentSeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValStatusV1StatusDtoIncidentSeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ValStatusV1StatusDtoIncidentSeverity(v) {
	case ValStatusV1StatusDtoIncidentSeverityInfo:
		*s = ValStatusV1StatusDtoIncidentSeverityInfo
	case ValStatusV1StatusDtoIncidentSeverityWarning:
		*s = ValStatusV1StatusDtoIncidentSeverityWarning
	case ValStatusV1StatusDtoIncidentSeverityCritical:
		*s = ValStatusV1StatusDtoIncidentSeverityCritical
	default:
		*s = ValStatusV1StatusDtoIncidentSeverity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ValStatusV1StatusDtoIncidentSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValStatusV1StatusDtoIncidentSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValStatusV1StatusDtoMaintenanceStatus as json.
func (s ValStatusV1StatusDtoMaintenanceStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ValStatusV1StatusDtoMaintenanceStatus from json.
func (s *ValStatusV1StatusDtoMaintenanceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValStatusV1StatusDtoMaintenanceStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ValStatusV1StatusDtoMaintenanceStatus(v) {
	case ValStatusV1StatusDtoMaintenanceStatusScheduled:
		*s = ValStatusV1StatusDtoMaintenanceStatusScheduled
	case ValStatusV1StatusDtoMaintenanceStatusInProgress:
		*s = ValStatusV1StatusDtoMaintenanceStatusInProgress
	case ValStatusV1StatusDtoMaintenanceStatusComplete:
		*s = ValStatusV1StatusDtoMaintenanceStatusComplete
	default:
		*s = ValStatusV1StatusDtoMaintenanceStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ValStatusV1StatusDtoMaintenanceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValStatusV1StatusDtoMaintenanceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValStatusV1StatusDtoPlatformsItem as json.
func (s ValStatusV1StatusDtoPlatformsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ValStatusV1StatusDtoPlatformsItem from json.
func (s *ValStatusV1StatusDtoPlatformsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValStatusV1StatusDtoPlatformsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ValStatusV1StatusDtoPlatformsItem(v) {
	case ValStatusV1StatusDtoPlatformsItemWindows:
		*s = ValStatusV1StatusDtoPlatformsItemWindows
	case ValStatusV1StatusDtoPlatformsItemMacos:
		*s = ValStatusV1StatusDtoPlatformsItemMacos
	case ValStatusV1StatusDtoPlatformsItemAndroid:
		*s = ValStatusV1StatusDtoPlatformsItemAndroid
	case ValStatusV1StatusDtoPlatformsItemIos:
		*s = ValStatusV1StatusDtoPlatformsItemIos
	case ValStatusV1StatusDtoPlatformsItemPs4:
		*s = ValStatusV1StatusDtoPlatformsItemPs4
	case ValStatusV1StatusDtoPlatformsItemXbone:
		*s = ValStatusV1StatusDtoPlatformsItemXbone
	case ValStatusV1StatusDtoPlatformsItemSwitch:
		*s = ValStatusV1StatusDtoPlatformsItemSwitch
	default:
		*s = ValStatusV1StatusDtoPlatformsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ValStatusV1StatusDtoPlatformsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValStatusV1StatusDtoPlatformsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValStatusV1UpdateDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValStatusV1UpdateDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int32(s.ID)
	}
	{
		e.FieldStart("author")
		e.Str(s.Author)
	}
	{
		e.FieldStart("publish")
		e.Bool(s.Publish)
	}
	{
		e.FieldStart("publish_locations")
		e.ArrStart()
		for _, elem := range s.PublishLocations {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("translations")
		e.ArrStart()
		for _, elem := range s.Translations {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("created_at")
		e.Str(s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		e.Str(s.UpdatedAt)
	}
}

var jsonFieldsNameOfValStatusV1UpdateDto = [7]string{
	0: "id",
	1: "author",
	2: "publish",
	3: "publish_locations",
	4: "translations",
	5: "created_at",
	6: "updated_at",
}

// Decode decodes ValStatusV1UpdateDto from json.
func (s *ValStatusV1UpdateDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValStatusV1UpdateDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ID = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "author":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Author = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "publish":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Publish = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publish\"")
			}
		case "publish_locations":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.PublishLocations = make([]ValStatusV1UpdateDtoPublishLocationsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValStatusV1UpdateDtoPublishLocationsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PublishLocations = append(s.PublishLocations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publish_locations\"")
			}
		case "translations":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Translations = make([]ValStatusV1ContentDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValStatusV1ContentDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Translations = append(s.Translations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"translations\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValStatusV1UpdateDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValStatusV1UpdateDto) {
					name = jsonFieldsNameOfValStatusV1UpdateDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValStatusV1UpdateDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValStatusV1UpdateDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValStatusV1UpdateDtoPublishLocationsItem as json.
func (s ValStatusV1UpdateDtoPublishLocationsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ValStatusV1UpdateDtoPublishLocationsItem from json.
func (s *ValStatusV1UpdateDtoPublishLocationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValStatusV1UpdateDtoPublishLocationsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ValStatusV1UpdateDtoPublishLocationsItem(v) {
	case ValStatusV1UpdateDtoPublishLocationsItemRiotclient:
		*s = ValStatusV1UpdateDtoPublishLocationsItemRiotclient
	case ValStatusV1UpdateDtoPublishLocationsItemRiotstatus:
		*s = ValStatusV1UpdateDtoPublishLocationsItemRiotstatus
	case ValStatusV1UpdateDtoPublishLocationsItemGame:
		*s = ValStatusV1UpdateDtoPublishLocationsItemGame
	default:
		*s = ValStatusV1UpdateDtoPublishLocationsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ValStatusV1UpdateDtoPublishLocationsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValStatusV1UpdateDtoPublishLocationsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
