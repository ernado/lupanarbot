// Code generated by ogen, DO NOT EDIT.

package oas

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AccountV1GetActiveRegion invokes account-v1.getActiveRegion operation.
	//
	// Get active region (lol and tft).
	//
	// GET /riot/account/v1/region/by-game/{game}/by-puuid/{puuid}
	AccountV1GetActiveRegion(ctx context.Context, params AccountV1GetActiveRegionParams) (AccountV1GetActiveRegionRes, error)
	// AccountV1GetActiveShard invokes account-v1.getActiveShard operation.
	//
	// Get active shard for a player.
	//
	// GET /riot/account/v1/active-shards/by-game/{game}/by-puuid/{puuid}
	AccountV1GetActiveShard(ctx context.Context, params AccountV1GetActiveShardParams) (AccountV1GetActiveShardRes, error)
	// AccountV1GetByAccessToken invokes account-v1.getByAccessToken operation.
	//
	// Get account by access token.
	//
	// GET /riot/account/v1/accounts/me
	AccountV1GetByAccessToken(ctx context.Context) (AccountV1GetByAccessTokenRes, error)
	// AccountV1GetByPuuid invokes account-v1.getByPuuid operation.
	//
	// Get account by puuid.
	//
	// GET /riot/account/v1/accounts/by-puuid/{puuid}
	AccountV1GetByPuuid(ctx context.Context, params AccountV1GetByPuuidParams) (AccountV1GetByPuuidRes, error)
	// AccountV1GetByRiotId invokes account-v1.getByRiotId operation.
	//
	// Get account by riot id.
	//
	// GET /riot/account/v1/accounts/by-riot-id/{gameName}/{tagLine}
	AccountV1GetByRiotId(ctx context.Context, params AccountV1GetByRiotIdParams) (AccountV1GetByRiotIdRes, error)
	// ChampionMasteryV4GetAllChampionMasteriesByPUUID invokes champion-mastery-v4.getAllChampionMasteriesByPUUID operation.
	//
	// Get all champion mastery entries sorted by number of champion points descending.
	//
	// GET /lol/champion-mastery/v4/champion-masteries/by-puuid/{encryptedPUUID}
	ChampionMasteryV4GetAllChampionMasteriesByPUUID(ctx context.Context, params ChampionMasteryV4GetAllChampionMasteriesByPUUIDParams) (ChampionMasteryV4GetAllChampionMasteriesByPUUIDRes, error)
	// ChampionMasteryV4GetChampionMasteryByPUUID invokes champion-mastery-v4.getChampionMasteryByPUUID operation.
	//
	// Get a champion mastery by puuid and champion ID.
	//
	// GET /lol/champion-mastery/v4/champion-masteries/by-puuid/{encryptedPUUID}/by-champion/{championId}
	ChampionMasteryV4GetChampionMasteryByPUUID(ctx context.Context, params ChampionMasteryV4GetChampionMasteryByPUUIDParams) (ChampionMasteryV4GetChampionMasteryByPUUIDRes, error)
	// ChampionMasteryV4GetChampionMasteryScoreByPUUID invokes champion-mastery-v4.getChampionMasteryScoreByPUUID operation.
	//
	// Get a player's total champion mastery score, which is the sum of individual champion mastery
	// levels.
	//
	// GET /lol/champion-mastery/v4/scores/by-puuid/{encryptedPUUID}
	ChampionMasteryV4GetChampionMasteryScoreByPUUID(ctx context.Context, params ChampionMasteryV4GetChampionMasteryScoreByPUUIDParams) (ChampionMasteryV4GetChampionMasteryScoreByPUUIDRes, error)
	// ChampionMasteryV4GetTopChampionMasteriesByPUUID invokes champion-mastery-v4.getTopChampionMasteriesByPUUID operation.
	//
	// Get specified number of top champion mastery entries sorted by number of champion points
	// descending.
	//
	// GET /lol/champion-mastery/v4/champion-masteries/by-puuid/{encryptedPUUID}/top
	ChampionMasteryV4GetTopChampionMasteriesByPUUID(ctx context.Context, params ChampionMasteryV4GetTopChampionMasteriesByPUUIDParams) (ChampionMasteryV4GetTopChampionMasteriesByPUUIDRes, error)
	// ChampionV3GetChampionInfo invokes champion-v3.getChampionInfo operation.
	//
	// Returns champion rotations, including free-to-play and low-level free-to-play rotations (REST).
	//
	// GET /lol/platform/v3/champion-rotations
	ChampionV3GetChampionInfo(ctx context.Context) (ChampionV3GetChampionInfoRes, error)
	// ClashV1GetPlayersByPUUID invokes clash-v1.getPlayersByPUUID operation.
	//
	// Get players by puuid
	// ## Implementation Notes
	// This endpoint returns a list of active Clash players for a given PUUID. If a summoner registers
	// for multiple tournaments at the same time (e.g., Saturday and Sunday) then both registrations
	// would appear in this list.
	//
	// GET /lol/clash/v1/players/by-puuid/{puuid}
	ClashV1GetPlayersByPUUID(ctx context.Context, params ClashV1GetPlayersByPUUIDParams) (ClashV1GetPlayersByPUUIDRes, error)
	// ClashV1GetTeamById invokes clash-v1.getTeamById operation.
	//
	// Get team by ID.
	//
	// GET /lol/clash/v1/teams/{teamId}
	ClashV1GetTeamById(ctx context.Context, params ClashV1GetTeamByIdParams) (ClashV1GetTeamByIdRes, error)
	// ClashV1GetTournamentById invokes clash-v1.getTournamentById operation.
	//
	// Get tournament by ID.
	//
	// GET /lol/clash/v1/tournaments/{tournamentId}
	ClashV1GetTournamentById(ctx context.Context, params ClashV1GetTournamentByIdParams) (ClashV1GetTournamentByIdRes, error)
	// ClashV1GetTournamentByTeam invokes clash-v1.getTournamentByTeam operation.
	//
	// Get tournament by team ID.
	//
	// GET /lol/clash/v1/tournaments/by-team/{teamId}
	ClashV1GetTournamentByTeam(ctx context.Context, params ClashV1GetTournamentByTeamParams) (ClashV1GetTournamentByTeamRes, error)
	// ClashV1GetTournaments invokes clash-v1.getTournaments operation.
	//
	// Get all active or upcoming tournaments.
	//
	// GET /lol/clash/v1/tournaments
	ClashV1GetTournaments(ctx context.Context) (ClashV1GetTournamentsRes, error)
	// LeagueExpV4GetLeagueEntries invokes league-exp-v4.getLeagueEntries operation.
	//
	// Get all the league entries.
	//
	// GET /lol/league-exp/v4/entries/{queue}/{tier}/{division}
	LeagueExpV4GetLeagueEntries(ctx context.Context, params LeagueExpV4GetLeagueEntriesParams) (LeagueExpV4GetLeagueEntriesRes, error)
	// LeagueV4GetChallengerLeague invokes league-v4.getChallengerLeague operation.
	//
	// Get the challenger league for given queue.
	//
	// GET /lol/league/v4/challengerleagues/by-queue/{queue}
	LeagueV4GetChallengerLeague(ctx context.Context, params LeagueV4GetChallengerLeagueParams) (LeagueV4GetChallengerLeagueRes, error)
	// LeagueV4GetGrandmasterLeague invokes league-v4.getGrandmasterLeague operation.
	//
	// Get the grandmaster league of a specific queue.
	//
	// GET /lol/league/v4/grandmasterleagues/by-queue/{queue}
	LeagueV4GetGrandmasterLeague(ctx context.Context, params LeagueV4GetGrandmasterLeagueParams) (LeagueV4GetGrandmasterLeagueRes, error)
	// LeagueV4GetLeagueById invokes league-v4.getLeagueById operation.
	//
	// Get league with given ID, including inactive entries.
	//
	// GET /lol/league/v4/leagues/{leagueId}
	LeagueV4GetLeagueById(ctx context.Context, params LeagueV4GetLeagueByIdParams) (LeagueV4GetLeagueByIdRes, error)
	// LeagueV4GetLeagueEntries invokes league-v4.getLeagueEntries operation.
	//
	// Get all the league entries.
	//
	// GET /lol/league/v4/entries/{queue}/{tier}/{division}
	LeagueV4GetLeagueEntries(ctx context.Context, params LeagueV4GetLeagueEntriesParams) (LeagueV4GetLeagueEntriesRes, error)
	// LeagueV4GetLeagueEntriesByPUUID invokes league-v4.getLeagueEntriesByPUUID operation.
	//
	// Get league entries in all queues for a given puuid.
	//
	// GET /lol/league/v4/entries/by-puuid/{encryptedPUUID}
	LeagueV4GetLeagueEntriesByPUUID(ctx context.Context, params LeagueV4GetLeagueEntriesByPUUIDParams) (LeagueV4GetLeagueEntriesByPUUIDRes, error)
	// LeagueV4GetMasterLeague invokes league-v4.getMasterLeague operation.
	//
	// Get the master league for given queue.
	//
	// GET /lol/league/v4/masterleagues/by-queue/{queue}
	LeagueV4GetMasterLeague(ctx context.Context, params LeagueV4GetMasterLeagueParams) (LeagueV4GetMasterLeagueRes, error)
	// LolChallengesV1GetAllChallengeConfigs invokes lol-challenges-v1.getAllChallengeConfigs operation.
	//
	// List of all basic challenge configuration information (includes all translations for names and
	// descriptions).
	//
	// GET /lol/challenges/v1/challenges/config
	LolChallengesV1GetAllChallengeConfigs(ctx context.Context) (LolChallengesV1GetAllChallengeConfigsRes, error)
	// LolChallengesV1GetAllChallengePercentiles invokes lol-challenges-v1.getAllChallengePercentiles operation.
	//
	// Map of level to percentile of players who have achieved it - keys: ChallengeId -> Season -> Level
	// -> percentile of players who achieved it.
	//
	// GET /lol/challenges/v1/challenges/percentiles
	LolChallengesV1GetAllChallengePercentiles(ctx context.Context) (LolChallengesV1GetAllChallengePercentilesRes, error)
	// LolChallengesV1GetChallengeConfigs invokes lol-challenges-v1.getChallengeConfigs operation.
	//
	// Get challenge configuration (REST).
	//
	// GET /lol/challenges/v1/challenges/{challengeId}/config
	LolChallengesV1GetChallengeConfigs(ctx context.Context, params LolChallengesV1GetChallengeConfigsParams) (LolChallengesV1GetChallengeConfigsRes, error)
	// LolChallengesV1GetChallengeLeaderboards invokes lol-challenges-v1.getChallengeLeaderboards operation.
	//
	// Return top players for each level. Level must be MASTER, GRANDMASTER or CHALLENGER.
	//
	// GET /lol/challenges/v1/challenges/{challengeId}/leaderboards/by-level/{level}
	LolChallengesV1GetChallengeLeaderboards(ctx context.Context, params LolChallengesV1GetChallengeLeaderboardsParams) (LolChallengesV1GetChallengeLeaderboardsRes, error)
	// LolChallengesV1GetChallengePercentiles invokes lol-challenges-v1.getChallengePercentiles operation.
	//
	// Map of level to percentile of players who have achieved it.
	//
	// GET /lol/challenges/v1/challenges/{challengeId}/percentiles
	LolChallengesV1GetChallengePercentiles(ctx context.Context, params LolChallengesV1GetChallengePercentilesParams) (LolChallengesV1GetChallengePercentilesRes, error)
	// LolChallengesV1GetPlayerData invokes lol-challenges-v1.getPlayerData operation.
	//
	// Returns player information with list of all progressed challenges (REST).
	//
	// GET /lol/challenges/v1/player-data/{puuid}
	LolChallengesV1GetPlayerData(ctx context.Context, params LolChallengesV1GetPlayerDataParams) (LolChallengesV1GetPlayerDataRes, error)
	// LolRsoMatchV1GetMatch invokes lol-rso-match-v1.getMatch operation.
	//
	// Get a match by match id.
	//
	// GET /lol/rso-match/v1/matches/{matchId}
	LolRsoMatchV1GetMatch(ctx context.Context, params LolRsoMatchV1GetMatchParams) (LolRsoMatchV1GetMatchRes, error)
	// LolRsoMatchV1GetMatchIds invokes lol-rso-match-v1.getMatchIds operation.
	//
	// Get a list of match ids by player access token - Includes custom matches.
	//
	// GET /lol/rso-match/v1/matches/ids
	LolRsoMatchV1GetMatchIds(ctx context.Context, params LolRsoMatchV1GetMatchIdsParams) (LolRsoMatchV1GetMatchIdsRes, error)
	// LolRsoMatchV1GetTimeline invokes lol-rso-match-v1.getTimeline operation.
	//
	// Get a match timeline by match id.
	//
	// GET /lol/rso-match/v1/matches/{matchId}/timeline
	LolRsoMatchV1GetTimeline(ctx context.Context, params LolRsoMatchV1GetTimelineParams) (LolRsoMatchV1GetTimelineRes, error)
	// LolStatusV4GetPlatformData invokes lol-status-v4.getPlatformData operation.
	//
	// Get League of Legends status for the given platform.
	//
	// GET /lol/status/v4/platform-data
	LolStatusV4GetPlatformData(ctx context.Context) (LolStatusV4GetPlatformDataRes, error)
	// LorDeckV1CreateDeck invokes lor-deck-v1.createDeck operation.
	//
	// Create a new deck for the calling user.
	//
	// POST /lor/deck/v1/decks/me
	LorDeckV1CreateDeck(ctx context.Context, request *LorDeckV1NewDeckDto) (LorDeckV1CreateDeckRes, error)
	// LorDeckV1GetDecks invokes lor-deck-v1.getDecks operation.
	//
	// Get a list of the calling user's decks.
	//
	// GET /lor/deck/v1/decks/me
	LorDeckV1GetDecks(ctx context.Context) (LorDeckV1GetDecksRes, error)
	// LorInventoryV1GetCards invokes lor-inventory-v1.getCards operation.
	//
	// Return a list of cards owned by the calling user.
	//
	// GET /lor/inventory/v1/cards/me
	LorInventoryV1GetCards(ctx context.Context) (LorInventoryV1GetCardsRes, error)
	// LorMatchV1GetMatch invokes lor-match-v1.getMatch operation.
	//
	// Get match by id.
	//
	// GET /lor/match/v1/matches/{matchId}
	LorMatchV1GetMatch(ctx context.Context, params LorMatchV1GetMatchParams) (LorMatchV1GetMatchRes, error)
	// LorMatchV1GetMatchIdsByPUUID invokes lor-match-v1.getMatchIdsByPUUID operation.
	//
	// Get a list of match ids by PUUID.
	//
	// GET /lor/match/v1/matches/by-puuid/{puuid}/ids
	LorMatchV1GetMatchIdsByPUUID(ctx context.Context, params LorMatchV1GetMatchIdsByPUUIDParams) (LorMatchV1GetMatchIdsByPUUIDRes, error)
	// LorRankedV1GetLeaderboards invokes lor-ranked-v1.getLeaderboards operation.
	//
	// Get the players in Master tier.
	//
	// GET /lor/ranked/v1/leaderboards
	LorRankedV1GetLeaderboards(ctx context.Context) (LorRankedV1GetLeaderboardsRes, error)
	// LorStatusV1GetPlatformData invokes lor-status-v1.getPlatformData operation.
	//
	// Get Legends of Runeterra status for the given platform.
	//
	// GET /lor/status/v1/platform-data
	LorStatusV1GetPlatformData(ctx context.Context) (LorStatusV1GetPlatformDataRes, error)
	// MatchV5GetMatch invokes match-v5.getMatch operation.
	//
	// Get a match by match id.
	//
	// GET /lol/match/v5/matches/{matchId}
	MatchV5GetMatch(ctx context.Context, params MatchV5GetMatchParams) (MatchV5GetMatchRes, error)
	// MatchV5GetMatchIdsByPUUID invokes match-v5.getMatchIdsByPUUID operation.
	//
	// Get a list of match ids by puuid.
	//
	// GET /lol/match/v5/matches/by-puuid/{puuid}/ids
	MatchV5GetMatchIdsByPUUID(ctx context.Context, params MatchV5GetMatchIdsByPUUIDParams) (MatchV5GetMatchIdsByPUUIDRes, error)
	// MatchV5GetTimeline invokes match-v5.getTimeline operation.
	//
	// Get a match timeline by match id.
	//
	// GET /lol/match/v5/matches/{matchId}/timeline
	MatchV5GetTimeline(ctx context.Context, params MatchV5GetTimelineParams) (MatchV5GetTimelineRes, error)
	// SpectatorTftV5GetCurrentGameInfoByPuuid invokes spectator-tft-v5.getCurrentGameInfoByPuuid operation.
	//
	// Get current game information for the given puuid.
	//
	// GET /lol/spectator/tft/v5/active-games/by-puuid/{encryptedPUUID}
	SpectatorTftV5GetCurrentGameInfoByPuuid(ctx context.Context, params SpectatorTftV5GetCurrentGameInfoByPuuidParams) (SpectatorTftV5GetCurrentGameInfoByPuuidRes, error)
	// SpectatorTftV5GetFeaturedGames invokes spectator-tft-v5.getFeaturedGames operation.
	//
	// Get list of featured games.
	//
	// GET /lol/spectator/tft/v5/featured-games
	SpectatorTftV5GetFeaturedGames(ctx context.Context) (SpectatorTftV5GetFeaturedGamesRes, error)
	// SpectatorV5GetCurrentGameInfoByPuuid invokes spectator-v5.getCurrentGameInfoByPuuid operation.
	//
	// Get current game information for the given puuid.
	//
	// GET /lol/spectator/v5/active-games/by-summoner/{encryptedPUUID}
	SpectatorV5GetCurrentGameInfoByPuuid(ctx context.Context, params SpectatorV5GetCurrentGameInfoByPuuidParams) (SpectatorV5GetCurrentGameInfoByPuuidRes, error)
	// SpectatorV5GetFeaturedGames invokes spectator-v5.getFeaturedGames operation.
	//
	// Get list of featured games.
	//
	// GET /lol/spectator/v5/featured-games
	SpectatorV5GetFeaturedGames(ctx context.Context) (SpectatorV5GetFeaturedGamesRes, error)
	// SummonerV4GetByAccessToken invokes summoner-v4.getByAccessToken operation.
	//
	// Get a summoner by access token.
	//
	// GET /lol/summoner/v4/summoners/me
	SummonerV4GetByAccessToken(ctx context.Context) (SummonerV4GetByAccessTokenRes, error)
	// SummonerV4GetByPUUID invokes summoner-v4.getByPUUID operation.
	//
	// Get a summoner by PUUID.
	//
	// GET /lol/summoner/v4/summoners/by-puuid/{encryptedPUUID}
	SummonerV4GetByPUUID(ctx context.Context, params SummonerV4GetByPUUIDParams) (SummonerV4GetByPUUIDRes, error)
	// TftLeagueV1GetChallengerLeague invokes tft-league-v1.getChallengerLeague operation.
	//
	// Get the challenger league.
	//
	// GET /tft/league/v1/challenger
	TftLeagueV1GetChallengerLeague(ctx context.Context, params TftLeagueV1GetChallengerLeagueParams) (TftLeagueV1GetChallengerLeagueRes, error)
	// TftLeagueV1GetGrandmasterLeague invokes tft-league-v1.getGrandmasterLeague operation.
	//
	// Get the grandmaster league.
	//
	// GET /tft/league/v1/grandmaster
	TftLeagueV1GetGrandmasterLeague(ctx context.Context, params TftLeagueV1GetGrandmasterLeagueParams) (TftLeagueV1GetGrandmasterLeagueRes, error)
	// TftLeagueV1GetLeagueById invokes tft-league-v1.getLeagueById operation.
	//
	// Get league with given ID, including inactive entries.
	//
	// GET /tft/league/v1/leagues/{leagueId}
	TftLeagueV1GetLeagueById(ctx context.Context, params TftLeagueV1GetLeagueByIdParams) (TftLeagueV1GetLeagueByIdRes, error)
	// TftLeagueV1GetLeagueEntries invokes tft-league-v1.getLeagueEntries operation.
	//
	// Get all the league entries.
	//
	// GET /tft/league/v1/entries/{tier}/{division}
	TftLeagueV1GetLeagueEntries(ctx context.Context, params TftLeagueV1GetLeagueEntriesParams) (TftLeagueV1GetLeagueEntriesRes, error)
	// TftLeagueV1GetLeagueEntriesByPUUID invokes tft-league-v1.getLeagueEntriesByPUUID operation.
	//
	// Get league entries in all queues for a given puuid.
	//
	// GET /tft/league/v1/by-puuid/{puuid}
	TftLeagueV1GetLeagueEntriesByPUUID(ctx context.Context, params TftLeagueV1GetLeagueEntriesByPUUIDParams) (TftLeagueV1GetLeagueEntriesByPUUIDRes, error)
	// TftLeagueV1GetMasterLeague invokes tft-league-v1.getMasterLeague operation.
	//
	// Get the master league.
	//
	// GET /tft/league/v1/master
	TftLeagueV1GetMasterLeague(ctx context.Context, params TftLeagueV1GetMasterLeagueParams) (TftLeagueV1GetMasterLeagueRes, error)
	// TftLeagueV1GetTopRatedLadder invokes tft-league-v1.getTopRatedLadder operation.
	//
	// Get the top rated ladder for given queue.
	//
	// GET /tft/league/v1/rated-ladders/{queue}/top
	TftLeagueV1GetTopRatedLadder(ctx context.Context, params TftLeagueV1GetTopRatedLadderParams) (TftLeagueV1GetTopRatedLadderRes, error)
	// TftMatchV1GetMatch invokes tft-match-v1.getMatch operation.
	//
	// Get a match by match id.
	//
	// GET /tft/match/v1/matches/{matchId}
	TftMatchV1GetMatch(ctx context.Context, params TftMatchV1GetMatchParams) (TftMatchV1GetMatchRes, error)
	// TftMatchV1GetMatchIdsByPUUID invokes tft-match-v1.getMatchIdsByPUUID operation.
	//
	// Get a list of match ids by PUUID.
	//
	// GET /tft/match/v1/matches/by-puuid/{puuid}/ids
	TftMatchV1GetMatchIdsByPUUID(ctx context.Context, params TftMatchV1GetMatchIdsByPUUIDParams) (TftMatchV1GetMatchIdsByPUUIDRes, error)
	// TftStatusV1GetPlatformData invokes tft-status-v1.getPlatformData operation.
	//
	// Get Teamfight Tactics status for the given platform.
	//
	// GET /tft/status/v1/platform-data
	TftStatusV1GetPlatformData(ctx context.Context) (TftStatusV1GetPlatformDataRes, error)
	// TftSummonerV1GetByAccessToken invokes tft-summoner-v1.getByAccessToken operation.
	//
	// Get a summoner by access token.
	//
	// GET /tft/summoner/v1/summoners/me
	TftSummonerV1GetByAccessToken(ctx context.Context) (TftSummonerV1GetByAccessTokenRes, error)
	// TftSummonerV1GetByPUUID invokes tft-summoner-v1.getByPUUID operation.
	//
	// Get a summoner by PUUID.
	//
	// GET /tft/summoner/v1/summoners/by-puuid/{encryptedPUUID}
	TftSummonerV1GetByPUUID(ctx context.Context, params TftSummonerV1GetByPUUIDParams) (TftSummonerV1GetByPUUIDRes, error)
	// TournamentStubV5CreateTournamentCode invokes tournament-stub-v5.createTournamentCode operation.
	//
	// Create a tournament code for the given tournament - Stub method.
	//
	// POST /lol/tournament-stub/v5/codes
	TournamentStubV5CreateTournamentCode(ctx context.Context, request *TournamentStubV5TournamentCodeParametersV5, params TournamentStubV5CreateTournamentCodeParams) (TournamentStubV5CreateTournamentCodeRes, error)
	// TournamentStubV5GetLobbyEventsByCode invokes tournament-stub-v5.getLobbyEventsByCode operation.
	//
	// Gets a list of lobby events by tournament code - Stub method.
	//
	// GET /lol/tournament-stub/v5/lobby-events/by-code/{tournamentCode}
	TournamentStubV5GetLobbyEventsByCode(ctx context.Context, params TournamentStubV5GetLobbyEventsByCodeParams) (TournamentStubV5GetLobbyEventsByCodeRes, error)
	// TournamentStubV5GetTournamentCode invokes tournament-stub-v5.getTournamentCode operation.
	//
	// Returns the tournament code DTO associated with a tournament code string - Stub Method.
	//
	// GET /lol/tournament-stub/v5/codes/{tournamentCode}
	TournamentStubV5GetTournamentCode(ctx context.Context, params TournamentStubV5GetTournamentCodeParams) (TournamentStubV5GetTournamentCodeRes, error)
	// TournamentStubV5RegisterProviderData invokes tournament-stub-v5.registerProviderData operation.
	//
	// Creates a tournament provider and returns its ID - Stub method
	// ## Implementation Notes
	// Providers will need to call this endpoint first to register their callback URL and their API key
	// with the tournament system before any other tournament provider endpoints will work.
	//
	// POST /lol/tournament-stub/v5/providers
	TournamentStubV5RegisterProviderData(ctx context.Context, request *TournamentStubV5ProviderRegistrationParametersV5) (TournamentStubV5RegisterProviderDataRes, error)
	// TournamentStubV5RegisterTournament invokes tournament-stub-v5.registerTournament operation.
	//
	// Creates a tournament and returns its ID - Stub method.
	//
	// POST /lol/tournament-stub/v5/tournaments
	TournamentStubV5RegisterTournament(ctx context.Context, request *TournamentStubV5TournamentRegistrationParametersV5) (TournamentStubV5RegisterTournamentRes, error)
	// TournamentV5CreateTournamentCode invokes tournament-v5.createTournamentCode operation.
	//
	// Create a tournament code for the given tournament.
	//
	// POST /lol/tournament/v5/codes
	TournamentV5CreateTournamentCode(ctx context.Context, request *TournamentV5TournamentCodeParametersV5, params TournamentV5CreateTournamentCodeParams) (TournamentV5CreateTournamentCodeRes, error)
	// TournamentV5GetGames invokes tournament-v5.getGames operation.
	//
	// Get games details
	// ## Implementation Notes
	// Additional endpoint to get tournament games. From this endpoint, you are able to get participants
	// PUUID (the callback doesn't contain this info).
	// You can also use it to check if the game was recorded and validate callbacks. If the endpoint
	// returns the game, it means a callback was attempted.
	// This will only work for tournament codes created after November 10, 2023.
	//
	// GET /lol/tournament/v5/games/by-code/{tournamentCode}
	TournamentV5GetGames(ctx context.Context, params TournamentV5GetGamesParams) (TournamentV5GetGamesRes, error)
	// TournamentV5GetLobbyEventsByCode invokes tournament-v5.getLobbyEventsByCode operation.
	//
	// Gets a list of lobby events by tournament code.
	//
	// GET /lol/tournament/v5/lobby-events/by-code/{tournamentCode}
	TournamentV5GetLobbyEventsByCode(ctx context.Context, params TournamentV5GetLobbyEventsByCodeParams) (TournamentV5GetLobbyEventsByCodeRes, error)
	// TournamentV5GetTournamentCode invokes tournament-v5.getTournamentCode operation.
	//
	// Returns the tournament code DTO associated with a tournament code string.
	//
	// GET /lol/tournament/v5/codes/{tournamentCode}
	TournamentV5GetTournamentCode(ctx context.Context, params TournamentV5GetTournamentCodeParams) (TournamentV5GetTournamentCodeRes, error)
	// TournamentV5RegisterProviderData invokes tournament-v5.registerProviderData operation.
	//
	// Creates a tournament provider and returns its ID.
	// ## Implementation Notes
	// Providers will need to call this endpoint first to register their callback URL and their API key
	// with the tournament system before any other tournament provider endpoints will work.
	//
	// POST /lol/tournament/v5/providers
	TournamentV5RegisterProviderData(ctx context.Context, request *TournamentV5ProviderRegistrationParametersV5) (TournamentV5RegisterProviderDataRes, error)
	// TournamentV5RegisterTournament invokes tournament-v5.registerTournament operation.
	//
	// Creates a tournament and returns its ID.
	//
	// POST /lol/tournament/v5/tournaments
	TournamentV5RegisterTournament(ctx context.Context, request *TournamentV5TournamentRegistrationParametersV5) (TournamentV5RegisterTournamentRes, error)
	// TournamentV5UpdateCode invokes tournament-v5.updateCode operation.
	//
	// Update the pick type, map, spectator type, or allowed puuids for a code.
	//
	// PUT /lol/tournament/v5/codes/{tournamentCode}
	TournamentV5UpdateCode(ctx context.Context, request OptTournamentV5TournamentCodeUpdateParametersV5, params TournamentV5UpdateCodeParams) (TournamentV5UpdateCodeRes, error)
	// ValConsoleMatchV1GetMatch invokes val-console-match-v1.getMatch operation.
	//
	// Get match by id.
	//
	// GET /val/match/console/v1/matches/{matchId}
	ValConsoleMatchV1GetMatch(ctx context.Context, params ValConsoleMatchV1GetMatchParams) (ValConsoleMatchV1GetMatchRes, error)
	// ValConsoleMatchV1GetMatchlist invokes val-console-match-v1.getMatchlist operation.
	//
	// Get matchlist for games played by puuid and platform type.
	//
	// GET /val/match/console/v1/matchlists/by-puuid/{puuid}
	ValConsoleMatchV1GetMatchlist(ctx context.Context, params ValConsoleMatchV1GetMatchlistParams) (ValConsoleMatchV1GetMatchlistRes, error)
	// ValConsoleMatchV1GetRecent invokes val-console-match-v1.getRecent operation.
	//
	// Get recent matches
	// ## Implementation Notes
	// Returns a list of match ids that have completed in the last 10 minutes for live regions and 12
	// hours for the esports routing value. NA/LATAM/BR share a match history deployment. As such, recent
	// matches will return a combined list of matches from those three regions. Requests are load
	// balanced so you may see some inconsistencies as matches are added/removed from the list.
	//
	// GET /val/match/console/v1/recent-matches/by-queue/{queue}
	ValConsoleMatchV1GetRecent(ctx context.Context, params ValConsoleMatchV1GetRecentParams) (ValConsoleMatchV1GetRecentRes, error)
	// ValConsoleRankedV1GetLeaderboard invokes val-console-ranked-v1.getLeaderboard operation.
	//
	// Get leaderboard for the competitive queue.
	//
	// GET /val/console/ranked/v1/leaderboards/by-act/{actId}
	ValConsoleRankedV1GetLeaderboard(ctx context.Context, params ValConsoleRankedV1GetLeaderboardParams) (ValConsoleRankedV1GetLeaderboardRes, error)
	// ValContentV1GetContent invokes val-content-v1.getContent operation.
	//
	// Get content optionally filtered by locale.
	//
	// GET /val/content/v1/contents
	ValContentV1GetContent(ctx context.Context, params ValContentV1GetContentParams) (ValContentV1GetContentRes, error)
	// ValMatchV1GetMatch invokes val-match-v1.getMatch operation.
	//
	// Get match by id.
	//
	// GET /val/match/v1/matches/{matchId}
	ValMatchV1GetMatch(ctx context.Context, params ValMatchV1GetMatchParams) (ValMatchV1GetMatchRes, error)
	// ValMatchV1GetMatchlist invokes val-match-v1.getMatchlist operation.
	//
	// Get matchlist for games played by puuid.
	//
	// GET /val/match/v1/matchlists/by-puuid/{puuid}
	ValMatchV1GetMatchlist(ctx context.Context, params ValMatchV1GetMatchlistParams) (ValMatchV1GetMatchlistRes, error)
	// ValMatchV1GetRecent invokes val-match-v1.getRecent operation.
	//
	// Get recent matches
	// ## Implementation Notes
	// Returns a list of match ids that have completed in the last 10 minutes for live regions and 12
	// hours for the esports routing value. NA/LATAM/BR share a match history deployment. As such, recent
	// matches will return a combined list of matches from those three regions. Requests are load
	// balanced so you may see some inconsistencies as matches are added/removed from the list.
	//
	// GET /val/match/v1/recent-matches/by-queue/{queue}
	ValMatchV1GetRecent(ctx context.Context, params ValMatchV1GetRecentParams) (ValMatchV1GetRecentRes, error)
	// ValRankedV1GetLeaderboard invokes val-ranked-v1.getLeaderboard operation.
	//
	// Get leaderboard for the competitive queue.
	//
	// GET /val/ranked/v1/leaderboards/by-act/{actId}
	ValRankedV1GetLeaderboard(ctx context.Context, params ValRankedV1GetLeaderboardParams) (ValRankedV1GetLeaderboardRes, error)
	// ValStatusV1GetPlatformData invokes val-status-v1.getPlatformData operation.
	//
	// Get VALORANT status for the given platform.
	//
	// GET /val/status/v1/platform-data
	ValStatusV1GetPlatformData(ctx context.Context) (ValStatusV1GetPlatformDataRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

var _ Handler = struct {
	*Client
}{}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AccountV1GetActiveRegion invokes account-v1.getActiveRegion operation.
//
// Get active region (lol and tft).
//
// GET /riot/account/v1/region/by-game/{game}/by-puuid/{puuid}
func (c *Client) AccountV1GetActiveRegion(ctx context.Context, params AccountV1GetActiveRegionParams) (AccountV1GetActiveRegionRes, error) {
	res, err := c.sendAccountV1GetActiveRegion(ctx, params)
	return res, err
}

func (c *Client) sendAccountV1GetActiveRegion(ctx context.Context, params AccountV1GetActiveRegionParams) (res AccountV1GetActiveRegionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("account-v1.getActiveRegion"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/riot/account/v1/region/by-game/{game}/by-puuid/{puuid}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AccountV1GetActiveRegionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/riot/account/v1/region/by-game/"
	{
		// Encode "game" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "game",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Game)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/by-puuid/"
	{
		// Encode "puuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "puuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Puuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, AccountV1GetActiveRegionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, AccountV1GetActiveRegionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAccountV1GetActiveRegionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountV1GetActiveShard invokes account-v1.getActiveShard operation.
//
// Get active shard for a player.
//
// GET /riot/account/v1/active-shards/by-game/{game}/by-puuid/{puuid}
func (c *Client) AccountV1GetActiveShard(ctx context.Context, params AccountV1GetActiveShardParams) (AccountV1GetActiveShardRes, error) {
	res, err := c.sendAccountV1GetActiveShard(ctx, params)
	return res, err
}

func (c *Client) sendAccountV1GetActiveShard(ctx context.Context, params AccountV1GetActiveShardParams) (res AccountV1GetActiveShardRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("account-v1.getActiveShard"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/riot/account/v1/active-shards/by-game/{game}/by-puuid/{puuid}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AccountV1GetActiveShardOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/riot/account/v1/active-shards/by-game/"
	{
		// Encode "game" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "game",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Game)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/by-puuid/"
	{
		// Encode "puuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "puuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Puuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, AccountV1GetActiveShardOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, AccountV1GetActiveShardOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAccountV1GetActiveShardResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountV1GetByAccessToken invokes account-v1.getByAccessToken operation.
//
// Get account by access token.
//
// GET /riot/account/v1/accounts/me
func (c *Client) AccountV1GetByAccessToken(ctx context.Context) (AccountV1GetByAccessTokenRes, error) {
	res, err := c.sendAccountV1GetByAccessToken(ctx)
	return res, err
}

func (c *Client) sendAccountV1GetByAccessToken(ctx context.Context) (res AccountV1GetByAccessTokenRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("account-v1.getByAccessToken"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/riot/account/v1/accounts/me"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AccountV1GetByAccessTokenOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/riot/account/v1/accounts/me"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Rso"
			switch err := c.securityRso(ctx, AccountV1GetByAccessTokenOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Rso\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAccountV1GetByAccessTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountV1GetByPuuid invokes account-v1.getByPuuid operation.
//
// Get account by puuid.
//
// GET /riot/account/v1/accounts/by-puuid/{puuid}
func (c *Client) AccountV1GetByPuuid(ctx context.Context, params AccountV1GetByPuuidParams) (AccountV1GetByPuuidRes, error) {
	res, err := c.sendAccountV1GetByPuuid(ctx, params)
	return res, err
}

func (c *Client) sendAccountV1GetByPuuid(ctx context.Context, params AccountV1GetByPuuidParams) (res AccountV1GetByPuuidRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("account-v1.getByPuuid"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/riot/account/v1/accounts/by-puuid/{puuid}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AccountV1GetByPuuidOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/riot/account/v1/accounts/by-puuid/"
	{
		// Encode "puuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "puuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Puuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, AccountV1GetByPuuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, AccountV1GetByPuuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAccountV1GetByPuuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AccountV1GetByRiotId invokes account-v1.getByRiotId operation.
//
// Get account by riot id.
//
// GET /riot/account/v1/accounts/by-riot-id/{gameName}/{tagLine}
func (c *Client) AccountV1GetByRiotId(ctx context.Context, params AccountV1GetByRiotIdParams) (AccountV1GetByRiotIdRes, error) {
	res, err := c.sendAccountV1GetByRiotId(ctx, params)
	return res, err
}

func (c *Client) sendAccountV1GetByRiotId(ctx context.Context, params AccountV1GetByRiotIdParams) (res AccountV1GetByRiotIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("account-v1.getByRiotId"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/riot/account/v1/accounts/by-riot-id/{gameName}/{tagLine}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AccountV1GetByRiotIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/riot/account/v1/accounts/by-riot-id/"
	{
		// Encode "gameName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "gameName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GameName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "tagLine" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tagLine",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TagLine))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, AccountV1GetByRiotIdOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, AccountV1GetByRiotIdOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAccountV1GetByRiotIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChampionMasteryV4GetAllChampionMasteriesByPUUID invokes champion-mastery-v4.getAllChampionMasteriesByPUUID operation.
//
// Get all champion mastery entries sorted by number of champion points descending.
//
// GET /lol/champion-mastery/v4/champion-masteries/by-puuid/{encryptedPUUID}
func (c *Client) ChampionMasteryV4GetAllChampionMasteriesByPUUID(ctx context.Context, params ChampionMasteryV4GetAllChampionMasteriesByPUUIDParams) (ChampionMasteryV4GetAllChampionMasteriesByPUUIDRes, error) {
	res, err := c.sendChampionMasteryV4GetAllChampionMasteriesByPUUID(ctx, params)
	return res, err
}

func (c *Client) sendChampionMasteryV4GetAllChampionMasteriesByPUUID(ctx context.Context, params ChampionMasteryV4GetAllChampionMasteriesByPUUIDParams) (res ChampionMasteryV4GetAllChampionMasteriesByPUUIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("champion-mastery-v4.getAllChampionMasteriesByPUUID"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/champion-mastery/v4/champion-masteries/by-puuid/{encryptedPUUID}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ChampionMasteryV4GetAllChampionMasteriesByPUUIDOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lol/champion-mastery/v4/champion-masteries/by-puuid/"
	{
		// Encode "encryptedPUUID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "encryptedPUUID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EncryptedPUUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, ChampionMasteryV4GetAllChampionMasteriesByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, ChampionMasteryV4GetAllChampionMasteriesByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeChampionMasteryV4GetAllChampionMasteriesByPUUIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChampionMasteryV4GetChampionMasteryByPUUID invokes champion-mastery-v4.getChampionMasteryByPUUID operation.
//
// Get a champion mastery by puuid and champion ID.
//
// GET /lol/champion-mastery/v4/champion-masteries/by-puuid/{encryptedPUUID}/by-champion/{championId}
func (c *Client) ChampionMasteryV4GetChampionMasteryByPUUID(ctx context.Context, params ChampionMasteryV4GetChampionMasteryByPUUIDParams) (ChampionMasteryV4GetChampionMasteryByPUUIDRes, error) {
	res, err := c.sendChampionMasteryV4GetChampionMasteryByPUUID(ctx, params)
	return res, err
}

func (c *Client) sendChampionMasteryV4GetChampionMasteryByPUUID(ctx context.Context, params ChampionMasteryV4GetChampionMasteryByPUUIDParams) (res ChampionMasteryV4GetChampionMasteryByPUUIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("champion-mastery-v4.getChampionMasteryByPUUID"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/champion-mastery/v4/champion-masteries/by-puuid/{encryptedPUUID}/by-champion/{championId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ChampionMasteryV4GetChampionMasteryByPUUIDOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/lol/champion-mastery/v4/champion-masteries/by-puuid/"
	{
		// Encode "encryptedPUUID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "encryptedPUUID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EncryptedPUUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/by-champion/"
	{
		// Encode "championId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "championId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.ChampionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, ChampionMasteryV4GetChampionMasteryByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, ChampionMasteryV4GetChampionMasteryByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeChampionMasteryV4GetChampionMasteryByPUUIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChampionMasteryV4GetChampionMasteryScoreByPUUID invokes champion-mastery-v4.getChampionMasteryScoreByPUUID operation.
//
// Get a player's total champion mastery score, which is the sum of individual champion mastery
// levels.
//
// GET /lol/champion-mastery/v4/scores/by-puuid/{encryptedPUUID}
func (c *Client) ChampionMasteryV4GetChampionMasteryScoreByPUUID(ctx context.Context, params ChampionMasteryV4GetChampionMasteryScoreByPUUIDParams) (ChampionMasteryV4GetChampionMasteryScoreByPUUIDRes, error) {
	res, err := c.sendChampionMasteryV4GetChampionMasteryScoreByPUUID(ctx, params)
	return res, err
}

func (c *Client) sendChampionMasteryV4GetChampionMasteryScoreByPUUID(ctx context.Context, params ChampionMasteryV4GetChampionMasteryScoreByPUUIDParams) (res ChampionMasteryV4GetChampionMasteryScoreByPUUIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("champion-mastery-v4.getChampionMasteryScoreByPUUID"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/champion-mastery/v4/scores/by-puuid/{encryptedPUUID}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ChampionMasteryV4GetChampionMasteryScoreByPUUIDOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lol/champion-mastery/v4/scores/by-puuid/"
	{
		// Encode "encryptedPUUID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "encryptedPUUID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EncryptedPUUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, ChampionMasteryV4GetChampionMasteryScoreByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, ChampionMasteryV4GetChampionMasteryScoreByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeChampionMasteryV4GetChampionMasteryScoreByPUUIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChampionMasteryV4GetTopChampionMasteriesByPUUID invokes champion-mastery-v4.getTopChampionMasteriesByPUUID operation.
//
// Get specified number of top champion mastery entries sorted by number of champion points
// descending.
//
// GET /lol/champion-mastery/v4/champion-masteries/by-puuid/{encryptedPUUID}/top
func (c *Client) ChampionMasteryV4GetTopChampionMasteriesByPUUID(ctx context.Context, params ChampionMasteryV4GetTopChampionMasteriesByPUUIDParams) (ChampionMasteryV4GetTopChampionMasteriesByPUUIDRes, error) {
	res, err := c.sendChampionMasteryV4GetTopChampionMasteriesByPUUID(ctx, params)
	return res, err
}

func (c *Client) sendChampionMasteryV4GetTopChampionMasteriesByPUUID(ctx context.Context, params ChampionMasteryV4GetTopChampionMasteriesByPUUIDParams) (res ChampionMasteryV4GetTopChampionMasteriesByPUUIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("champion-mastery-v4.getTopChampionMasteriesByPUUID"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/champion-mastery/v4/champion-masteries/by-puuid/{encryptedPUUID}/top"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ChampionMasteryV4GetTopChampionMasteriesByPUUIDOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/lol/champion-mastery/v4/champion-masteries/by-puuid/"
	{
		// Encode "encryptedPUUID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "encryptedPUUID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EncryptedPUUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/top"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "count" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Count.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, ChampionMasteryV4GetTopChampionMasteriesByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, ChampionMasteryV4GetTopChampionMasteriesByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeChampionMasteryV4GetTopChampionMasteriesByPUUIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChampionV3GetChampionInfo invokes champion-v3.getChampionInfo operation.
//
// Returns champion rotations, including free-to-play and low-level free-to-play rotations (REST).
//
// GET /lol/platform/v3/champion-rotations
func (c *Client) ChampionV3GetChampionInfo(ctx context.Context) (ChampionV3GetChampionInfoRes, error) {
	res, err := c.sendChampionV3GetChampionInfo(ctx)
	return res, err
}

func (c *Client) sendChampionV3GetChampionInfo(ctx context.Context) (res ChampionV3GetChampionInfoRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("champion-v3.getChampionInfo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/platform/v3/champion-rotations"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ChampionV3GetChampionInfoOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/lol/platform/v3/champion-rotations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, ChampionV3GetChampionInfoOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, ChampionV3GetChampionInfoOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeChampionV3GetChampionInfoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ClashV1GetPlayersByPUUID invokes clash-v1.getPlayersByPUUID operation.
//
// Get players by puuid
// ## Implementation Notes
// This endpoint returns a list of active Clash players for a given PUUID. If a summoner registers
// for multiple tournaments at the same time (e.g., Saturday and Sunday) then both registrations
// would appear in this list.
//
// GET /lol/clash/v1/players/by-puuid/{puuid}
func (c *Client) ClashV1GetPlayersByPUUID(ctx context.Context, params ClashV1GetPlayersByPUUIDParams) (ClashV1GetPlayersByPUUIDRes, error) {
	res, err := c.sendClashV1GetPlayersByPUUID(ctx, params)
	return res, err
}

func (c *Client) sendClashV1GetPlayersByPUUID(ctx context.Context, params ClashV1GetPlayersByPUUIDParams) (res ClashV1GetPlayersByPUUIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("clash-v1.getPlayersByPUUID"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/clash/v1/players/by-puuid/{puuid}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ClashV1GetPlayersByPUUIDOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lol/clash/v1/players/by-puuid/"
	{
		// Encode "puuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "puuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Puuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, ClashV1GetPlayersByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, ClashV1GetPlayersByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeClashV1GetPlayersByPUUIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ClashV1GetTeamById invokes clash-v1.getTeamById operation.
//
// Get team by ID.
//
// GET /lol/clash/v1/teams/{teamId}
func (c *Client) ClashV1GetTeamById(ctx context.Context, params ClashV1GetTeamByIdParams) (ClashV1GetTeamByIdRes, error) {
	res, err := c.sendClashV1GetTeamById(ctx, params)
	return res, err
}

func (c *Client) sendClashV1GetTeamById(ctx context.Context, params ClashV1GetTeamByIdParams) (res ClashV1GetTeamByIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("clash-v1.getTeamById"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/clash/v1/teams/{teamId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ClashV1GetTeamByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lol/clash/v1/teams/"
	{
		// Encode "teamId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "teamId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, ClashV1GetTeamByIdOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, ClashV1GetTeamByIdOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeClashV1GetTeamByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ClashV1GetTournamentById invokes clash-v1.getTournamentById operation.
//
// Get tournament by ID.
//
// GET /lol/clash/v1/tournaments/{tournamentId}
func (c *Client) ClashV1GetTournamentById(ctx context.Context, params ClashV1GetTournamentByIdParams) (ClashV1GetTournamentByIdRes, error) {
	res, err := c.sendClashV1GetTournamentById(ctx, params)
	return res, err
}

func (c *Client) sendClashV1GetTournamentById(ctx context.Context, params ClashV1GetTournamentByIdParams) (res ClashV1GetTournamentByIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("clash-v1.getTournamentById"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/clash/v1/tournaments/{tournamentId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ClashV1GetTournamentByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lol/clash/v1/tournaments/"
	{
		// Encode "tournamentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tournamentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.TournamentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, ClashV1GetTournamentByIdOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, ClashV1GetTournamentByIdOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeClashV1GetTournamentByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ClashV1GetTournamentByTeam invokes clash-v1.getTournamentByTeam operation.
//
// Get tournament by team ID.
//
// GET /lol/clash/v1/tournaments/by-team/{teamId}
func (c *Client) ClashV1GetTournamentByTeam(ctx context.Context, params ClashV1GetTournamentByTeamParams) (ClashV1GetTournamentByTeamRes, error) {
	res, err := c.sendClashV1GetTournamentByTeam(ctx, params)
	return res, err
}

func (c *Client) sendClashV1GetTournamentByTeam(ctx context.Context, params ClashV1GetTournamentByTeamParams) (res ClashV1GetTournamentByTeamRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("clash-v1.getTournamentByTeam"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/clash/v1/tournaments/by-team/{teamId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ClashV1GetTournamentByTeamOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lol/clash/v1/tournaments/by-team/"
	{
		// Encode "teamId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "teamId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TeamId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, ClashV1GetTournamentByTeamOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, ClashV1GetTournamentByTeamOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeClashV1GetTournamentByTeamResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ClashV1GetTournaments invokes clash-v1.getTournaments operation.
//
// Get all active or upcoming tournaments.
//
// GET /lol/clash/v1/tournaments
func (c *Client) ClashV1GetTournaments(ctx context.Context) (ClashV1GetTournamentsRes, error) {
	res, err := c.sendClashV1GetTournaments(ctx)
	return res, err
}

func (c *Client) sendClashV1GetTournaments(ctx context.Context) (res ClashV1GetTournamentsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("clash-v1.getTournaments"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/clash/v1/tournaments"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ClashV1GetTournamentsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/lol/clash/v1/tournaments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, ClashV1GetTournamentsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, ClashV1GetTournamentsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeClashV1GetTournamentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LeagueExpV4GetLeagueEntries invokes league-exp-v4.getLeagueEntries operation.
//
// Get all the league entries.
//
// GET /lol/league-exp/v4/entries/{queue}/{tier}/{division}
func (c *Client) LeagueExpV4GetLeagueEntries(ctx context.Context, params LeagueExpV4GetLeagueEntriesParams) (LeagueExpV4GetLeagueEntriesRes, error) {
	res, err := c.sendLeagueExpV4GetLeagueEntries(ctx, params)
	return res, err
}

func (c *Client) sendLeagueExpV4GetLeagueEntries(ctx context.Context, params LeagueExpV4GetLeagueEntriesParams) (res LeagueExpV4GetLeagueEntriesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("league-exp-v4.getLeagueEntries"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/league-exp/v4/entries/{queue}/{tier}/{division}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LeagueExpV4GetLeagueEntriesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/lol/league-exp/v4/entries/"
	{
		// Encode "queue" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "queue",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Queue)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "tier" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tier",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Tier)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "division" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "division",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Division)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, LeagueExpV4GetLeagueEntriesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, LeagueExpV4GetLeagueEntriesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLeagueExpV4GetLeagueEntriesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LeagueV4GetChallengerLeague invokes league-v4.getChallengerLeague operation.
//
// Get the challenger league for given queue.
//
// GET /lol/league/v4/challengerleagues/by-queue/{queue}
func (c *Client) LeagueV4GetChallengerLeague(ctx context.Context, params LeagueV4GetChallengerLeagueParams) (LeagueV4GetChallengerLeagueRes, error) {
	res, err := c.sendLeagueV4GetChallengerLeague(ctx, params)
	return res, err
}

func (c *Client) sendLeagueV4GetChallengerLeague(ctx context.Context, params LeagueV4GetChallengerLeagueParams) (res LeagueV4GetChallengerLeagueRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("league-v4.getChallengerLeague"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/league/v4/challengerleagues/by-queue/{queue}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LeagueV4GetChallengerLeagueOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lol/league/v4/challengerleagues/by-queue/"
	{
		// Encode "queue" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "queue",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Queue)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, LeagueV4GetChallengerLeagueOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, LeagueV4GetChallengerLeagueOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLeagueV4GetChallengerLeagueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LeagueV4GetGrandmasterLeague invokes league-v4.getGrandmasterLeague operation.
//
// Get the grandmaster league of a specific queue.
//
// GET /lol/league/v4/grandmasterleagues/by-queue/{queue}
func (c *Client) LeagueV4GetGrandmasterLeague(ctx context.Context, params LeagueV4GetGrandmasterLeagueParams) (LeagueV4GetGrandmasterLeagueRes, error) {
	res, err := c.sendLeagueV4GetGrandmasterLeague(ctx, params)
	return res, err
}

func (c *Client) sendLeagueV4GetGrandmasterLeague(ctx context.Context, params LeagueV4GetGrandmasterLeagueParams) (res LeagueV4GetGrandmasterLeagueRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("league-v4.getGrandmasterLeague"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/league/v4/grandmasterleagues/by-queue/{queue}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LeagueV4GetGrandmasterLeagueOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lol/league/v4/grandmasterleagues/by-queue/"
	{
		// Encode "queue" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "queue",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Queue)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, LeagueV4GetGrandmasterLeagueOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, LeagueV4GetGrandmasterLeagueOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLeagueV4GetGrandmasterLeagueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LeagueV4GetLeagueById invokes league-v4.getLeagueById operation.
//
// Get league with given ID, including inactive entries.
//
// GET /lol/league/v4/leagues/{leagueId}
func (c *Client) LeagueV4GetLeagueById(ctx context.Context, params LeagueV4GetLeagueByIdParams) (LeagueV4GetLeagueByIdRes, error) {
	res, err := c.sendLeagueV4GetLeagueById(ctx, params)
	return res, err
}

func (c *Client) sendLeagueV4GetLeagueById(ctx context.Context, params LeagueV4GetLeagueByIdParams) (res LeagueV4GetLeagueByIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("league-v4.getLeagueById"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/league/v4/leagues/{leagueId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LeagueV4GetLeagueByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lol/league/v4/leagues/"
	{
		// Encode "leagueId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "leagueId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.LeagueId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, LeagueV4GetLeagueByIdOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, LeagueV4GetLeagueByIdOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLeagueV4GetLeagueByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LeagueV4GetLeagueEntries invokes league-v4.getLeagueEntries operation.
//
// Get all the league entries.
//
// GET /lol/league/v4/entries/{queue}/{tier}/{division}
func (c *Client) LeagueV4GetLeagueEntries(ctx context.Context, params LeagueV4GetLeagueEntriesParams) (LeagueV4GetLeagueEntriesRes, error) {
	res, err := c.sendLeagueV4GetLeagueEntries(ctx, params)
	return res, err
}

func (c *Client) sendLeagueV4GetLeagueEntries(ctx context.Context, params LeagueV4GetLeagueEntriesParams) (res LeagueV4GetLeagueEntriesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("league-v4.getLeagueEntries"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/league/v4/entries/{queue}/{tier}/{division}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LeagueV4GetLeagueEntriesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/lol/league/v4/entries/"
	{
		// Encode "queue" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "queue",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Queue)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "tier" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tier",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Tier)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "division" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "division",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Division)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, LeagueV4GetLeagueEntriesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, LeagueV4GetLeagueEntriesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLeagueV4GetLeagueEntriesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LeagueV4GetLeagueEntriesByPUUID invokes league-v4.getLeagueEntriesByPUUID operation.
//
// Get league entries in all queues for a given puuid.
//
// GET /lol/league/v4/entries/by-puuid/{encryptedPUUID}
func (c *Client) LeagueV4GetLeagueEntriesByPUUID(ctx context.Context, params LeagueV4GetLeagueEntriesByPUUIDParams) (LeagueV4GetLeagueEntriesByPUUIDRes, error) {
	res, err := c.sendLeagueV4GetLeagueEntriesByPUUID(ctx, params)
	return res, err
}

func (c *Client) sendLeagueV4GetLeagueEntriesByPUUID(ctx context.Context, params LeagueV4GetLeagueEntriesByPUUIDParams) (res LeagueV4GetLeagueEntriesByPUUIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("league-v4.getLeagueEntriesByPUUID"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/league/v4/entries/by-puuid/{encryptedPUUID}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LeagueV4GetLeagueEntriesByPUUIDOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lol/league/v4/entries/by-puuid/"
	{
		// Encode "encryptedPUUID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "encryptedPUUID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EncryptedPUUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, LeagueV4GetLeagueEntriesByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, LeagueV4GetLeagueEntriesByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLeagueV4GetLeagueEntriesByPUUIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LeagueV4GetMasterLeague invokes league-v4.getMasterLeague operation.
//
// Get the master league for given queue.
//
// GET /lol/league/v4/masterleagues/by-queue/{queue}
func (c *Client) LeagueV4GetMasterLeague(ctx context.Context, params LeagueV4GetMasterLeagueParams) (LeagueV4GetMasterLeagueRes, error) {
	res, err := c.sendLeagueV4GetMasterLeague(ctx, params)
	return res, err
}

func (c *Client) sendLeagueV4GetMasterLeague(ctx context.Context, params LeagueV4GetMasterLeagueParams) (res LeagueV4GetMasterLeagueRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("league-v4.getMasterLeague"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/league/v4/masterleagues/by-queue/{queue}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LeagueV4GetMasterLeagueOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lol/league/v4/masterleagues/by-queue/"
	{
		// Encode "queue" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "queue",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Queue)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, LeagueV4GetMasterLeagueOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, LeagueV4GetMasterLeagueOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLeagueV4GetMasterLeagueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LolChallengesV1GetAllChallengeConfigs invokes lol-challenges-v1.getAllChallengeConfigs operation.
//
// List of all basic challenge configuration information (includes all translations for names and
// descriptions).
//
// GET /lol/challenges/v1/challenges/config
func (c *Client) LolChallengesV1GetAllChallengeConfigs(ctx context.Context) (LolChallengesV1GetAllChallengeConfigsRes, error) {
	res, err := c.sendLolChallengesV1GetAllChallengeConfigs(ctx)
	return res, err
}

func (c *Client) sendLolChallengesV1GetAllChallengeConfigs(ctx context.Context) (res LolChallengesV1GetAllChallengeConfigsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("lol-challenges-v1.getAllChallengeConfigs"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/challenges/v1/challenges/config"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LolChallengesV1GetAllChallengeConfigsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/lol/challenges/v1/challenges/config"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, LolChallengesV1GetAllChallengeConfigsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, LolChallengesV1GetAllChallengeConfigsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLolChallengesV1GetAllChallengeConfigsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LolChallengesV1GetAllChallengePercentiles invokes lol-challenges-v1.getAllChallengePercentiles operation.
//
// Map of level to percentile of players who have achieved it - keys: ChallengeId -> Season -> Level
// -> percentile of players who achieved it.
//
// GET /lol/challenges/v1/challenges/percentiles
func (c *Client) LolChallengesV1GetAllChallengePercentiles(ctx context.Context) (LolChallengesV1GetAllChallengePercentilesRes, error) {
	res, err := c.sendLolChallengesV1GetAllChallengePercentiles(ctx)
	return res, err
}

func (c *Client) sendLolChallengesV1GetAllChallengePercentiles(ctx context.Context) (res LolChallengesV1GetAllChallengePercentilesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("lol-challenges-v1.getAllChallengePercentiles"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/challenges/v1/challenges/percentiles"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LolChallengesV1GetAllChallengePercentilesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/lol/challenges/v1/challenges/percentiles"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, LolChallengesV1GetAllChallengePercentilesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, LolChallengesV1GetAllChallengePercentilesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLolChallengesV1GetAllChallengePercentilesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LolChallengesV1GetChallengeConfigs invokes lol-challenges-v1.getChallengeConfigs operation.
//
// Get challenge configuration (REST).
//
// GET /lol/challenges/v1/challenges/{challengeId}/config
func (c *Client) LolChallengesV1GetChallengeConfigs(ctx context.Context, params LolChallengesV1GetChallengeConfigsParams) (LolChallengesV1GetChallengeConfigsRes, error) {
	res, err := c.sendLolChallengesV1GetChallengeConfigs(ctx, params)
	return res, err
}

func (c *Client) sendLolChallengesV1GetChallengeConfigs(ctx context.Context, params LolChallengesV1GetChallengeConfigsParams) (res LolChallengesV1GetChallengeConfigsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("lol-challenges-v1.getChallengeConfigs"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/challenges/v1/challenges/{challengeId}/config"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LolChallengesV1GetChallengeConfigsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/lol/challenges/v1/challenges/"
	{
		// Encode "challengeId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "challengeId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int64ToString(params.ChallengeId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/config"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, LolChallengesV1GetChallengeConfigsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, LolChallengesV1GetChallengeConfigsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLolChallengesV1GetChallengeConfigsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LolChallengesV1GetChallengeLeaderboards invokes lol-challenges-v1.getChallengeLeaderboards operation.
//
// Return top players for each level. Level must be MASTER, GRANDMASTER or CHALLENGER.
//
// GET /lol/challenges/v1/challenges/{challengeId}/leaderboards/by-level/{level}
func (c *Client) LolChallengesV1GetChallengeLeaderboards(ctx context.Context, params LolChallengesV1GetChallengeLeaderboardsParams) (LolChallengesV1GetChallengeLeaderboardsRes, error) {
	res, err := c.sendLolChallengesV1GetChallengeLeaderboards(ctx, params)
	return res, err
}

func (c *Client) sendLolChallengesV1GetChallengeLeaderboards(ctx context.Context, params LolChallengesV1GetChallengeLeaderboardsParams) (res LolChallengesV1GetChallengeLeaderboardsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("lol-challenges-v1.getChallengeLeaderboards"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/challenges/v1/challenges/{challengeId}/leaderboards/by-level/{level}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LolChallengesV1GetChallengeLeaderboardsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/lol/challenges/v1/challenges/"
	{
		// Encode "challengeId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "challengeId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int64ToString(params.ChallengeId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/leaderboards/by-level/"
	{
		// Encode "level" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "level",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Level)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, LolChallengesV1GetChallengeLeaderboardsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, LolChallengesV1GetChallengeLeaderboardsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLolChallengesV1GetChallengeLeaderboardsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LolChallengesV1GetChallengePercentiles invokes lol-challenges-v1.getChallengePercentiles operation.
//
// Map of level to percentile of players who have achieved it.
//
// GET /lol/challenges/v1/challenges/{challengeId}/percentiles
func (c *Client) LolChallengesV1GetChallengePercentiles(ctx context.Context, params LolChallengesV1GetChallengePercentilesParams) (LolChallengesV1GetChallengePercentilesRes, error) {
	res, err := c.sendLolChallengesV1GetChallengePercentiles(ctx, params)
	return res, err
}

func (c *Client) sendLolChallengesV1GetChallengePercentiles(ctx context.Context, params LolChallengesV1GetChallengePercentilesParams) (res LolChallengesV1GetChallengePercentilesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("lol-challenges-v1.getChallengePercentiles"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/challenges/v1/challenges/{challengeId}/percentiles"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LolChallengesV1GetChallengePercentilesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/lol/challenges/v1/challenges/"
	{
		// Encode "challengeId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "challengeId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int64ToString(params.ChallengeId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/percentiles"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, LolChallengesV1GetChallengePercentilesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, LolChallengesV1GetChallengePercentilesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLolChallengesV1GetChallengePercentilesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LolChallengesV1GetPlayerData invokes lol-challenges-v1.getPlayerData operation.
//
// Returns player information with list of all progressed challenges (REST).
//
// GET /lol/challenges/v1/player-data/{puuid}
func (c *Client) LolChallengesV1GetPlayerData(ctx context.Context, params LolChallengesV1GetPlayerDataParams) (LolChallengesV1GetPlayerDataRes, error) {
	res, err := c.sendLolChallengesV1GetPlayerData(ctx, params)
	return res, err
}

func (c *Client) sendLolChallengesV1GetPlayerData(ctx context.Context, params LolChallengesV1GetPlayerDataParams) (res LolChallengesV1GetPlayerDataRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("lol-challenges-v1.getPlayerData"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/challenges/v1/player-data/{puuid}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LolChallengesV1GetPlayerDataOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lol/challenges/v1/player-data/"
	{
		// Encode "puuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "puuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Puuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, LolChallengesV1GetPlayerDataOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, LolChallengesV1GetPlayerDataOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLolChallengesV1GetPlayerDataResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LolRsoMatchV1GetMatch invokes lol-rso-match-v1.getMatch operation.
//
// Get a match by match id.
//
// GET /lol/rso-match/v1/matches/{matchId}
func (c *Client) LolRsoMatchV1GetMatch(ctx context.Context, params LolRsoMatchV1GetMatchParams) (LolRsoMatchV1GetMatchRes, error) {
	res, err := c.sendLolRsoMatchV1GetMatch(ctx, params)
	return res, err
}

func (c *Client) sendLolRsoMatchV1GetMatch(ctx context.Context, params LolRsoMatchV1GetMatchParams) (res LolRsoMatchV1GetMatchRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("lol-rso-match-v1.getMatch"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/rso-match/v1/matches/{matchId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LolRsoMatchV1GetMatchOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lol/rso-match/v1/matches/"
	{
		// Encode "matchId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "matchId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MatchId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Rso"
			switch err := c.securityRso(ctx, LolRsoMatchV1GetMatchOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Rso\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLolRsoMatchV1GetMatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LolRsoMatchV1GetMatchIds invokes lol-rso-match-v1.getMatchIds operation.
//
// Get a list of match ids by player access token - Includes custom matches.
//
// GET /lol/rso-match/v1/matches/ids
func (c *Client) LolRsoMatchV1GetMatchIds(ctx context.Context, params LolRsoMatchV1GetMatchIdsParams) (LolRsoMatchV1GetMatchIdsRes, error) {
	res, err := c.sendLolRsoMatchV1GetMatchIds(ctx, params)
	return res, err
}

func (c *Client) sendLolRsoMatchV1GetMatchIds(ctx context.Context, params LolRsoMatchV1GetMatchIdsParams) (res LolRsoMatchV1GetMatchIdsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("lol-rso-match-v1.getMatchIds"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/rso-match/v1/matches/ids"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LolRsoMatchV1GetMatchIdsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/lol/rso-match/v1/matches/ids"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "count" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Count.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Start.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "queue" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "queue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Queue.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "endTime" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "endTime",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EndTime.Get(); ok {
				return e.EncodeValue(conv.Int64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "startTime" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "startTime",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartTime.Get(); ok {
				return e.EncodeValue(conv.Int64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Rso"
			switch err := c.securityRso(ctx, LolRsoMatchV1GetMatchIdsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Rso\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLolRsoMatchV1GetMatchIdsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LolRsoMatchV1GetTimeline invokes lol-rso-match-v1.getTimeline operation.
//
// Get a match timeline by match id.
//
// GET /lol/rso-match/v1/matches/{matchId}/timeline
func (c *Client) LolRsoMatchV1GetTimeline(ctx context.Context, params LolRsoMatchV1GetTimelineParams) (LolRsoMatchV1GetTimelineRes, error) {
	res, err := c.sendLolRsoMatchV1GetTimeline(ctx, params)
	return res, err
}

func (c *Client) sendLolRsoMatchV1GetTimeline(ctx context.Context, params LolRsoMatchV1GetTimelineParams) (res LolRsoMatchV1GetTimelineRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("lol-rso-match-v1.getTimeline"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/rso-match/v1/matches/{matchId}/timeline"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LolRsoMatchV1GetTimelineOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/lol/rso-match/v1/matches/"
	{
		// Encode "matchId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "matchId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MatchId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/timeline"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Rso"
			switch err := c.securityRso(ctx, LolRsoMatchV1GetTimelineOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Rso\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLolRsoMatchV1GetTimelineResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LolStatusV4GetPlatformData invokes lol-status-v4.getPlatformData operation.
//
// Get League of Legends status for the given platform.
//
// GET /lol/status/v4/platform-data
func (c *Client) LolStatusV4GetPlatformData(ctx context.Context) (LolStatusV4GetPlatformDataRes, error) {
	res, err := c.sendLolStatusV4GetPlatformData(ctx)
	return res, err
}

func (c *Client) sendLolStatusV4GetPlatformData(ctx context.Context) (res LolStatusV4GetPlatformDataRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("lol-status-v4.getPlatformData"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/status/v4/platform-data"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LolStatusV4GetPlatformDataOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/lol/status/v4/platform-data"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, LolStatusV4GetPlatformDataOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, LolStatusV4GetPlatformDataOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLolStatusV4GetPlatformDataResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LorDeckV1CreateDeck invokes lor-deck-v1.createDeck operation.
//
// Create a new deck for the calling user.
//
// POST /lor/deck/v1/decks/me
func (c *Client) LorDeckV1CreateDeck(ctx context.Context, request *LorDeckV1NewDeckDto) (LorDeckV1CreateDeckRes, error) {
	res, err := c.sendLorDeckV1CreateDeck(ctx, request)
	return res, err
}

func (c *Client) sendLorDeckV1CreateDeck(ctx context.Context, request *LorDeckV1NewDeckDto) (res LorDeckV1CreateDeckRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("lor-deck-v1.createDeck"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/lor/deck/v1/decks/me"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LorDeckV1CreateDeckOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/lor/deck/v1/decks/me"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeLorDeckV1CreateDeckRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Rso"
			switch err := c.securityRso(ctx, LorDeckV1CreateDeckOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Rso\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLorDeckV1CreateDeckResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LorDeckV1GetDecks invokes lor-deck-v1.getDecks operation.
//
// Get a list of the calling user's decks.
//
// GET /lor/deck/v1/decks/me
func (c *Client) LorDeckV1GetDecks(ctx context.Context) (LorDeckV1GetDecksRes, error) {
	res, err := c.sendLorDeckV1GetDecks(ctx)
	return res, err
}

func (c *Client) sendLorDeckV1GetDecks(ctx context.Context) (res LorDeckV1GetDecksRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("lor-deck-v1.getDecks"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lor/deck/v1/decks/me"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LorDeckV1GetDecksOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/lor/deck/v1/decks/me"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Rso"
			switch err := c.securityRso(ctx, LorDeckV1GetDecksOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Rso\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLorDeckV1GetDecksResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LorInventoryV1GetCards invokes lor-inventory-v1.getCards operation.
//
// Return a list of cards owned by the calling user.
//
// GET /lor/inventory/v1/cards/me
func (c *Client) LorInventoryV1GetCards(ctx context.Context) (LorInventoryV1GetCardsRes, error) {
	res, err := c.sendLorInventoryV1GetCards(ctx)
	return res, err
}

func (c *Client) sendLorInventoryV1GetCards(ctx context.Context) (res LorInventoryV1GetCardsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("lor-inventory-v1.getCards"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lor/inventory/v1/cards/me"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LorInventoryV1GetCardsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/lor/inventory/v1/cards/me"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Rso"
			switch err := c.securityRso(ctx, LorInventoryV1GetCardsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Rso\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLorInventoryV1GetCardsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LorMatchV1GetMatch invokes lor-match-v1.getMatch operation.
//
// Get match by id.
//
// GET /lor/match/v1/matches/{matchId}
func (c *Client) LorMatchV1GetMatch(ctx context.Context, params LorMatchV1GetMatchParams) (LorMatchV1GetMatchRes, error) {
	res, err := c.sendLorMatchV1GetMatch(ctx, params)
	return res, err
}

func (c *Client) sendLorMatchV1GetMatch(ctx context.Context, params LorMatchV1GetMatchParams) (res LorMatchV1GetMatchRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("lor-match-v1.getMatch"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lor/match/v1/matches/{matchId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LorMatchV1GetMatchOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lor/match/v1/matches/"
	{
		// Encode "matchId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "matchId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MatchId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, LorMatchV1GetMatchOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, LorMatchV1GetMatchOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLorMatchV1GetMatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LorMatchV1GetMatchIdsByPUUID invokes lor-match-v1.getMatchIdsByPUUID operation.
//
// Get a list of match ids by PUUID.
//
// GET /lor/match/v1/matches/by-puuid/{puuid}/ids
func (c *Client) LorMatchV1GetMatchIdsByPUUID(ctx context.Context, params LorMatchV1GetMatchIdsByPUUIDParams) (LorMatchV1GetMatchIdsByPUUIDRes, error) {
	res, err := c.sendLorMatchV1GetMatchIdsByPUUID(ctx, params)
	return res, err
}

func (c *Client) sendLorMatchV1GetMatchIdsByPUUID(ctx context.Context, params LorMatchV1GetMatchIdsByPUUIDParams) (res LorMatchV1GetMatchIdsByPUUIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("lor-match-v1.getMatchIdsByPUUID"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lor/match/v1/matches/by-puuid/{puuid}/ids"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LorMatchV1GetMatchIdsByPUUIDOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/lor/match/v1/matches/by-puuid/"
	{
		// Encode "puuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "puuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Puuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/ids"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, LorMatchV1GetMatchIdsByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, LorMatchV1GetMatchIdsByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLorMatchV1GetMatchIdsByPUUIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LorRankedV1GetLeaderboards invokes lor-ranked-v1.getLeaderboards operation.
//
// Get the players in Master tier.
//
// GET /lor/ranked/v1/leaderboards
func (c *Client) LorRankedV1GetLeaderboards(ctx context.Context) (LorRankedV1GetLeaderboardsRes, error) {
	res, err := c.sendLorRankedV1GetLeaderboards(ctx)
	return res, err
}

func (c *Client) sendLorRankedV1GetLeaderboards(ctx context.Context) (res LorRankedV1GetLeaderboardsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("lor-ranked-v1.getLeaderboards"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lor/ranked/v1/leaderboards"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LorRankedV1GetLeaderboardsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/lor/ranked/v1/leaderboards"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, LorRankedV1GetLeaderboardsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, LorRankedV1GetLeaderboardsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLorRankedV1GetLeaderboardsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LorStatusV1GetPlatformData invokes lor-status-v1.getPlatformData operation.
//
// Get Legends of Runeterra status for the given platform.
//
// GET /lor/status/v1/platform-data
func (c *Client) LorStatusV1GetPlatformData(ctx context.Context) (LorStatusV1GetPlatformDataRes, error) {
	res, err := c.sendLorStatusV1GetPlatformData(ctx)
	return res, err
}

func (c *Client) sendLorStatusV1GetPlatformData(ctx context.Context) (res LorStatusV1GetPlatformDataRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("lor-status-v1.getPlatformData"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lor/status/v1/platform-data"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LorStatusV1GetPlatformDataOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/lor/status/v1/platform-data"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, LorStatusV1GetPlatformDataOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, LorStatusV1GetPlatformDataOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLorStatusV1GetPlatformDataResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MatchV5GetMatch invokes match-v5.getMatch operation.
//
// Get a match by match id.
//
// GET /lol/match/v5/matches/{matchId}
func (c *Client) MatchV5GetMatch(ctx context.Context, params MatchV5GetMatchParams) (MatchV5GetMatchRes, error) {
	res, err := c.sendMatchV5GetMatch(ctx, params)
	return res, err
}

func (c *Client) sendMatchV5GetMatch(ctx context.Context, params MatchV5GetMatchParams) (res MatchV5GetMatchRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("match-v5.getMatch"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/match/v5/matches/{matchId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, MatchV5GetMatchOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lol/match/v5/matches/"
	{
		// Encode "matchId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "matchId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MatchId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, MatchV5GetMatchOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, MatchV5GetMatchOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMatchV5GetMatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MatchV5GetMatchIdsByPUUID invokes match-v5.getMatchIdsByPUUID operation.
//
// Get a list of match ids by puuid.
//
// GET /lol/match/v5/matches/by-puuid/{puuid}/ids
func (c *Client) MatchV5GetMatchIdsByPUUID(ctx context.Context, params MatchV5GetMatchIdsByPUUIDParams) (MatchV5GetMatchIdsByPUUIDRes, error) {
	res, err := c.sendMatchV5GetMatchIdsByPUUID(ctx, params)
	return res, err
}

func (c *Client) sendMatchV5GetMatchIdsByPUUID(ctx context.Context, params MatchV5GetMatchIdsByPUUIDParams) (res MatchV5GetMatchIdsByPUUIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("match-v5.getMatchIdsByPUUID"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/match/v5/matches/by-puuid/{puuid}/ids"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, MatchV5GetMatchIdsByPUUIDOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/lol/match/v5/matches/by-puuid/"
	{
		// Encode "puuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "puuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Puuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/ids"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "startTime" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "startTime",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartTime.Get(); ok {
				return e.EncodeValue(conv.Int64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "endTime" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "endTime",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EndTime.Get(); ok {
				return e.EncodeValue(conv.Int64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "queue" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "queue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Queue.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Start.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "count" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Count.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, MatchV5GetMatchIdsByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, MatchV5GetMatchIdsByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMatchV5GetMatchIdsByPUUIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MatchV5GetTimeline invokes match-v5.getTimeline operation.
//
// Get a match timeline by match id.
//
// GET /lol/match/v5/matches/{matchId}/timeline
func (c *Client) MatchV5GetTimeline(ctx context.Context, params MatchV5GetTimelineParams) (MatchV5GetTimelineRes, error) {
	res, err := c.sendMatchV5GetTimeline(ctx, params)
	return res, err
}

func (c *Client) sendMatchV5GetTimeline(ctx context.Context, params MatchV5GetTimelineParams) (res MatchV5GetTimelineRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("match-v5.getTimeline"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/match/v5/matches/{matchId}/timeline"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, MatchV5GetTimelineOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/lol/match/v5/matches/"
	{
		// Encode "matchId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "matchId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MatchId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/timeline"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, MatchV5GetTimelineOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, MatchV5GetTimelineOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMatchV5GetTimelineResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SpectatorTftV5GetCurrentGameInfoByPuuid invokes spectator-tft-v5.getCurrentGameInfoByPuuid operation.
//
// Get current game information for the given puuid.
//
// GET /lol/spectator/tft/v5/active-games/by-puuid/{encryptedPUUID}
func (c *Client) SpectatorTftV5GetCurrentGameInfoByPuuid(ctx context.Context, params SpectatorTftV5GetCurrentGameInfoByPuuidParams) (SpectatorTftV5GetCurrentGameInfoByPuuidRes, error) {
	res, err := c.sendSpectatorTftV5GetCurrentGameInfoByPuuid(ctx, params)
	return res, err
}

func (c *Client) sendSpectatorTftV5GetCurrentGameInfoByPuuid(ctx context.Context, params SpectatorTftV5GetCurrentGameInfoByPuuidParams) (res SpectatorTftV5GetCurrentGameInfoByPuuidRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("spectator-tft-v5.getCurrentGameInfoByPuuid"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/spectator/tft/v5/active-games/by-puuid/{encryptedPUUID}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SpectatorTftV5GetCurrentGameInfoByPuuidOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lol/spectator/tft/v5/active-games/by-puuid/"
	{
		// Encode "encryptedPUUID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "encryptedPUUID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EncryptedPUUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, SpectatorTftV5GetCurrentGameInfoByPuuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, SpectatorTftV5GetCurrentGameInfoByPuuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSpectatorTftV5GetCurrentGameInfoByPuuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SpectatorTftV5GetFeaturedGames invokes spectator-tft-v5.getFeaturedGames operation.
//
// Get list of featured games.
//
// GET /lol/spectator/tft/v5/featured-games
func (c *Client) SpectatorTftV5GetFeaturedGames(ctx context.Context) (SpectatorTftV5GetFeaturedGamesRes, error) {
	res, err := c.sendSpectatorTftV5GetFeaturedGames(ctx)
	return res, err
}

func (c *Client) sendSpectatorTftV5GetFeaturedGames(ctx context.Context) (res SpectatorTftV5GetFeaturedGamesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("spectator-tft-v5.getFeaturedGames"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/spectator/tft/v5/featured-games"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SpectatorTftV5GetFeaturedGamesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/lol/spectator/tft/v5/featured-games"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, SpectatorTftV5GetFeaturedGamesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, SpectatorTftV5GetFeaturedGamesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSpectatorTftV5GetFeaturedGamesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SpectatorV5GetCurrentGameInfoByPuuid invokes spectator-v5.getCurrentGameInfoByPuuid operation.
//
// Get current game information for the given puuid.
//
// GET /lol/spectator/v5/active-games/by-summoner/{encryptedPUUID}
func (c *Client) SpectatorV5GetCurrentGameInfoByPuuid(ctx context.Context, params SpectatorV5GetCurrentGameInfoByPuuidParams) (SpectatorV5GetCurrentGameInfoByPuuidRes, error) {
	res, err := c.sendSpectatorV5GetCurrentGameInfoByPuuid(ctx, params)
	return res, err
}

func (c *Client) sendSpectatorV5GetCurrentGameInfoByPuuid(ctx context.Context, params SpectatorV5GetCurrentGameInfoByPuuidParams) (res SpectatorV5GetCurrentGameInfoByPuuidRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("spectator-v5.getCurrentGameInfoByPuuid"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/spectator/v5/active-games/by-summoner/{encryptedPUUID}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SpectatorV5GetCurrentGameInfoByPuuidOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lol/spectator/v5/active-games/by-summoner/"
	{
		// Encode "encryptedPUUID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "encryptedPUUID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EncryptedPUUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, SpectatorV5GetCurrentGameInfoByPuuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, SpectatorV5GetCurrentGameInfoByPuuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSpectatorV5GetCurrentGameInfoByPuuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SpectatorV5GetFeaturedGames invokes spectator-v5.getFeaturedGames operation.
//
// Get list of featured games.
//
// GET /lol/spectator/v5/featured-games
func (c *Client) SpectatorV5GetFeaturedGames(ctx context.Context) (SpectatorV5GetFeaturedGamesRes, error) {
	res, err := c.sendSpectatorV5GetFeaturedGames(ctx)
	return res, err
}

func (c *Client) sendSpectatorV5GetFeaturedGames(ctx context.Context) (res SpectatorV5GetFeaturedGamesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("spectator-v5.getFeaturedGames"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/spectator/v5/featured-games"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SpectatorV5GetFeaturedGamesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/lol/spectator/v5/featured-games"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, SpectatorV5GetFeaturedGamesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, SpectatorV5GetFeaturedGamesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSpectatorV5GetFeaturedGamesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SummonerV4GetByAccessToken invokes summoner-v4.getByAccessToken operation.
//
// Get a summoner by access token.
//
// GET /lol/summoner/v4/summoners/me
func (c *Client) SummonerV4GetByAccessToken(ctx context.Context) (SummonerV4GetByAccessTokenRes, error) {
	res, err := c.sendSummonerV4GetByAccessToken(ctx)
	return res, err
}

func (c *Client) sendSummonerV4GetByAccessToken(ctx context.Context) (res SummonerV4GetByAccessTokenRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("summoner-v4.getByAccessToken"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/summoner/v4/summoners/me"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SummonerV4GetByAccessTokenOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/lol/summoner/v4/summoners/me"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Rso"
			switch err := c.securityRso(ctx, SummonerV4GetByAccessTokenOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Rso\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSummonerV4GetByAccessTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SummonerV4GetByPUUID invokes summoner-v4.getByPUUID operation.
//
// Get a summoner by PUUID.
//
// GET /lol/summoner/v4/summoners/by-puuid/{encryptedPUUID}
func (c *Client) SummonerV4GetByPUUID(ctx context.Context, params SummonerV4GetByPUUIDParams) (SummonerV4GetByPUUIDRes, error) {
	res, err := c.sendSummonerV4GetByPUUID(ctx, params)
	return res, err
}

func (c *Client) sendSummonerV4GetByPUUID(ctx context.Context, params SummonerV4GetByPUUIDParams) (res SummonerV4GetByPUUIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("summoner-v4.getByPUUID"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/summoner/v4/summoners/by-puuid/{encryptedPUUID}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SummonerV4GetByPUUIDOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lol/summoner/v4/summoners/by-puuid/"
	{
		// Encode "encryptedPUUID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "encryptedPUUID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EncryptedPUUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, SummonerV4GetByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, SummonerV4GetByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSummonerV4GetByPUUIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TftLeagueV1GetChallengerLeague invokes tft-league-v1.getChallengerLeague operation.
//
// Get the challenger league.
//
// GET /tft/league/v1/challenger
func (c *Client) TftLeagueV1GetChallengerLeague(ctx context.Context, params TftLeagueV1GetChallengerLeagueParams) (TftLeagueV1GetChallengerLeagueRes, error) {
	res, err := c.sendTftLeagueV1GetChallengerLeague(ctx, params)
	return res, err
}

func (c *Client) sendTftLeagueV1GetChallengerLeague(ctx context.Context, params TftLeagueV1GetChallengerLeagueParams) (res TftLeagueV1GetChallengerLeagueRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tft-league-v1.getChallengerLeague"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/tft/league/v1/challenger"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TftLeagueV1GetChallengerLeagueOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tft/league/v1/challenger"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "queue" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "queue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Queue.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, TftLeagueV1GetChallengerLeagueOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, TftLeagueV1GetChallengerLeagueOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTftLeagueV1GetChallengerLeagueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TftLeagueV1GetGrandmasterLeague invokes tft-league-v1.getGrandmasterLeague operation.
//
// Get the grandmaster league.
//
// GET /tft/league/v1/grandmaster
func (c *Client) TftLeagueV1GetGrandmasterLeague(ctx context.Context, params TftLeagueV1GetGrandmasterLeagueParams) (TftLeagueV1GetGrandmasterLeagueRes, error) {
	res, err := c.sendTftLeagueV1GetGrandmasterLeague(ctx, params)
	return res, err
}

func (c *Client) sendTftLeagueV1GetGrandmasterLeague(ctx context.Context, params TftLeagueV1GetGrandmasterLeagueParams) (res TftLeagueV1GetGrandmasterLeagueRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tft-league-v1.getGrandmasterLeague"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/tft/league/v1/grandmaster"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TftLeagueV1GetGrandmasterLeagueOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tft/league/v1/grandmaster"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "queue" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "queue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Queue.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, TftLeagueV1GetGrandmasterLeagueOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, TftLeagueV1GetGrandmasterLeagueOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTftLeagueV1GetGrandmasterLeagueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TftLeagueV1GetLeagueById invokes tft-league-v1.getLeagueById operation.
//
// Get league with given ID, including inactive entries.
//
// GET /tft/league/v1/leagues/{leagueId}
func (c *Client) TftLeagueV1GetLeagueById(ctx context.Context, params TftLeagueV1GetLeagueByIdParams) (TftLeagueV1GetLeagueByIdRes, error) {
	res, err := c.sendTftLeagueV1GetLeagueById(ctx, params)
	return res, err
}

func (c *Client) sendTftLeagueV1GetLeagueById(ctx context.Context, params TftLeagueV1GetLeagueByIdParams) (res TftLeagueV1GetLeagueByIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tft-league-v1.getLeagueById"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/tft/league/v1/leagues/{leagueId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TftLeagueV1GetLeagueByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/tft/league/v1/leagues/"
	{
		// Encode "leagueId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "leagueId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.LeagueId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, TftLeagueV1GetLeagueByIdOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, TftLeagueV1GetLeagueByIdOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTftLeagueV1GetLeagueByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TftLeagueV1GetLeagueEntries invokes tft-league-v1.getLeagueEntries operation.
//
// Get all the league entries.
//
// GET /tft/league/v1/entries/{tier}/{division}
func (c *Client) TftLeagueV1GetLeagueEntries(ctx context.Context, params TftLeagueV1GetLeagueEntriesParams) (TftLeagueV1GetLeagueEntriesRes, error) {
	res, err := c.sendTftLeagueV1GetLeagueEntries(ctx, params)
	return res, err
}

func (c *Client) sendTftLeagueV1GetLeagueEntries(ctx context.Context, params TftLeagueV1GetLeagueEntriesParams) (res TftLeagueV1GetLeagueEntriesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tft-league-v1.getLeagueEntries"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/tft/league/v1/entries/{tier}/{division}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TftLeagueV1GetLeagueEntriesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/tft/league/v1/entries/"
	{
		// Encode "tier" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tier",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Tier)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "division" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "division",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Division)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "queue" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "queue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Queue.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, TftLeagueV1GetLeagueEntriesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, TftLeagueV1GetLeagueEntriesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTftLeagueV1GetLeagueEntriesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TftLeagueV1GetLeagueEntriesByPUUID invokes tft-league-v1.getLeagueEntriesByPUUID operation.
//
// Get league entries in all queues for a given puuid.
//
// GET /tft/league/v1/by-puuid/{puuid}
func (c *Client) TftLeagueV1GetLeagueEntriesByPUUID(ctx context.Context, params TftLeagueV1GetLeagueEntriesByPUUIDParams) (TftLeagueV1GetLeagueEntriesByPUUIDRes, error) {
	res, err := c.sendTftLeagueV1GetLeagueEntriesByPUUID(ctx, params)
	return res, err
}

func (c *Client) sendTftLeagueV1GetLeagueEntriesByPUUID(ctx context.Context, params TftLeagueV1GetLeagueEntriesByPUUIDParams) (res TftLeagueV1GetLeagueEntriesByPUUIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tft-league-v1.getLeagueEntriesByPUUID"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/tft/league/v1/by-puuid/{puuid}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TftLeagueV1GetLeagueEntriesByPUUIDOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/tft/league/v1/by-puuid/"
	{
		// Encode "puuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "puuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Puuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, TftLeagueV1GetLeagueEntriesByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, TftLeagueV1GetLeagueEntriesByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTftLeagueV1GetLeagueEntriesByPUUIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TftLeagueV1GetMasterLeague invokes tft-league-v1.getMasterLeague operation.
//
// Get the master league.
//
// GET /tft/league/v1/master
func (c *Client) TftLeagueV1GetMasterLeague(ctx context.Context, params TftLeagueV1GetMasterLeagueParams) (TftLeagueV1GetMasterLeagueRes, error) {
	res, err := c.sendTftLeagueV1GetMasterLeague(ctx, params)
	return res, err
}

func (c *Client) sendTftLeagueV1GetMasterLeague(ctx context.Context, params TftLeagueV1GetMasterLeagueParams) (res TftLeagueV1GetMasterLeagueRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tft-league-v1.getMasterLeague"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/tft/league/v1/master"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TftLeagueV1GetMasterLeagueOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tft/league/v1/master"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "queue" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "queue",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Queue.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, TftLeagueV1GetMasterLeagueOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, TftLeagueV1GetMasterLeagueOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTftLeagueV1GetMasterLeagueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TftLeagueV1GetTopRatedLadder invokes tft-league-v1.getTopRatedLadder operation.
//
// Get the top rated ladder for given queue.
//
// GET /tft/league/v1/rated-ladders/{queue}/top
func (c *Client) TftLeagueV1GetTopRatedLadder(ctx context.Context, params TftLeagueV1GetTopRatedLadderParams) (TftLeagueV1GetTopRatedLadderRes, error) {
	res, err := c.sendTftLeagueV1GetTopRatedLadder(ctx, params)
	return res, err
}

func (c *Client) sendTftLeagueV1GetTopRatedLadder(ctx context.Context, params TftLeagueV1GetTopRatedLadderParams) (res TftLeagueV1GetTopRatedLadderRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tft-league-v1.getTopRatedLadder"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/tft/league/v1/rated-ladders/{queue}/top"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TftLeagueV1GetTopRatedLadderOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/tft/league/v1/rated-ladders/"
	{
		// Encode "queue" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "queue",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Queue)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/top"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, TftLeagueV1GetTopRatedLadderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, TftLeagueV1GetTopRatedLadderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTftLeagueV1GetTopRatedLadderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TftMatchV1GetMatch invokes tft-match-v1.getMatch operation.
//
// Get a match by match id.
//
// GET /tft/match/v1/matches/{matchId}
func (c *Client) TftMatchV1GetMatch(ctx context.Context, params TftMatchV1GetMatchParams) (TftMatchV1GetMatchRes, error) {
	res, err := c.sendTftMatchV1GetMatch(ctx, params)
	return res, err
}

func (c *Client) sendTftMatchV1GetMatch(ctx context.Context, params TftMatchV1GetMatchParams) (res TftMatchV1GetMatchRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tft-match-v1.getMatch"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/tft/match/v1/matches/{matchId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TftMatchV1GetMatchOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/tft/match/v1/matches/"
	{
		// Encode "matchId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "matchId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MatchId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, TftMatchV1GetMatchOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, TftMatchV1GetMatchOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTftMatchV1GetMatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TftMatchV1GetMatchIdsByPUUID invokes tft-match-v1.getMatchIdsByPUUID operation.
//
// Get a list of match ids by PUUID.
//
// GET /tft/match/v1/matches/by-puuid/{puuid}/ids
func (c *Client) TftMatchV1GetMatchIdsByPUUID(ctx context.Context, params TftMatchV1GetMatchIdsByPUUIDParams) (TftMatchV1GetMatchIdsByPUUIDRes, error) {
	res, err := c.sendTftMatchV1GetMatchIdsByPUUID(ctx, params)
	return res, err
}

func (c *Client) sendTftMatchV1GetMatchIdsByPUUID(ctx context.Context, params TftMatchV1GetMatchIdsByPUUIDParams) (res TftMatchV1GetMatchIdsByPUUIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tft-match-v1.getMatchIdsByPUUID"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/tft/match/v1/matches/by-puuid/{puuid}/ids"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TftMatchV1GetMatchIdsByPUUIDOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/tft/match/v1/matches/by-puuid/"
	{
		// Encode "puuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "puuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Puuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/ids"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Start.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "endTime" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "endTime",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EndTime.Get(); ok {
				return e.EncodeValue(conv.Int64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "startTime" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "startTime",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartTime.Get(); ok {
				return e.EncodeValue(conv.Int64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "count" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Count.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, TftMatchV1GetMatchIdsByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, TftMatchV1GetMatchIdsByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTftMatchV1GetMatchIdsByPUUIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TftStatusV1GetPlatformData invokes tft-status-v1.getPlatformData operation.
//
// Get Teamfight Tactics status for the given platform.
//
// GET /tft/status/v1/platform-data
func (c *Client) TftStatusV1GetPlatformData(ctx context.Context) (TftStatusV1GetPlatformDataRes, error) {
	res, err := c.sendTftStatusV1GetPlatformData(ctx)
	return res, err
}

func (c *Client) sendTftStatusV1GetPlatformData(ctx context.Context) (res TftStatusV1GetPlatformDataRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tft-status-v1.getPlatformData"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/tft/status/v1/platform-data"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TftStatusV1GetPlatformDataOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tft/status/v1/platform-data"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, TftStatusV1GetPlatformDataOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, TftStatusV1GetPlatformDataOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTftStatusV1GetPlatformDataResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TftSummonerV1GetByAccessToken invokes tft-summoner-v1.getByAccessToken operation.
//
// Get a summoner by access token.
//
// GET /tft/summoner/v1/summoners/me
func (c *Client) TftSummonerV1GetByAccessToken(ctx context.Context) (TftSummonerV1GetByAccessTokenRes, error) {
	res, err := c.sendTftSummonerV1GetByAccessToken(ctx)
	return res, err
}

func (c *Client) sendTftSummonerV1GetByAccessToken(ctx context.Context) (res TftSummonerV1GetByAccessTokenRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tft-summoner-v1.getByAccessToken"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/tft/summoner/v1/summoners/me"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TftSummonerV1GetByAccessTokenOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tft/summoner/v1/summoners/me"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Rso"
			switch err := c.securityRso(ctx, TftSummonerV1GetByAccessTokenOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Rso\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTftSummonerV1GetByAccessTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TftSummonerV1GetByPUUID invokes tft-summoner-v1.getByPUUID operation.
//
// Get a summoner by PUUID.
//
// GET /tft/summoner/v1/summoners/by-puuid/{encryptedPUUID}
func (c *Client) TftSummonerV1GetByPUUID(ctx context.Context, params TftSummonerV1GetByPUUIDParams) (TftSummonerV1GetByPUUIDRes, error) {
	res, err := c.sendTftSummonerV1GetByPUUID(ctx, params)
	return res, err
}

func (c *Client) sendTftSummonerV1GetByPUUID(ctx context.Context, params TftSummonerV1GetByPUUIDParams) (res TftSummonerV1GetByPUUIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tft-summoner-v1.getByPUUID"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/tft/summoner/v1/summoners/by-puuid/{encryptedPUUID}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TftSummonerV1GetByPUUIDOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/tft/summoner/v1/summoners/by-puuid/"
	{
		// Encode "encryptedPUUID" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "encryptedPUUID",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EncryptedPUUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, TftSummonerV1GetByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, TftSummonerV1GetByPUUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTftSummonerV1GetByPUUIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TournamentStubV5CreateTournamentCode invokes tournament-stub-v5.createTournamentCode operation.
//
// Create a tournament code for the given tournament - Stub method.
//
// POST /lol/tournament-stub/v5/codes
func (c *Client) TournamentStubV5CreateTournamentCode(ctx context.Context, request *TournamentStubV5TournamentCodeParametersV5, params TournamentStubV5CreateTournamentCodeParams) (TournamentStubV5CreateTournamentCodeRes, error) {
	res, err := c.sendTournamentStubV5CreateTournamentCode(ctx, request, params)
	return res, err
}

func (c *Client) sendTournamentStubV5CreateTournamentCode(ctx context.Context, request *TournamentStubV5TournamentCodeParametersV5, params TournamentStubV5CreateTournamentCodeParams) (res TournamentStubV5CreateTournamentCodeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tournament-stub-v5.createTournamentCode"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/lol/tournament-stub/v5/codes"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TournamentStubV5CreateTournamentCodeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/lol/tournament-stub/v5/codes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "count" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Count.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tournamentId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tournamentId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.Int64ToString(params.TournamentId))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTournamentStubV5CreateTournamentCodeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, TournamentStubV5CreateTournamentCodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, TournamentStubV5CreateTournamentCodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTournamentStubV5CreateTournamentCodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TournamentStubV5GetLobbyEventsByCode invokes tournament-stub-v5.getLobbyEventsByCode operation.
//
// Gets a list of lobby events by tournament code - Stub method.
//
// GET /lol/tournament-stub/v5/lobby-events/by-code/{tournamentCode}
func (c *Client) TournamentStubV5GetLobbyEventsByCode(ctx context.Context, params TournamentStubV5GetLobbyEventsByCodeParams) (TournamentStubV5GetLobbyEventsByCodeRes, error) {
	res, err := c.sendTournamentStubV5GetLobbyEventsByCode(ctx, params)
	return res, err
}

func (c *Client) sendTournamentStubV5GetLobbyEventsByCode(ctx context.Context, params TournamentStubV5GetLobbyEventsByCodeParams) (res TournamentStubV5GetLobbyEventsByCodeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tournament-stub-v5.getLobbyEventsByCode"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/tournament-stub/v5/lobby-events/by-code/{tournamentCode}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TournamentStubV5GetLobbyEventsByCodeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lol/tournament-stub/v5/lobby-events/by-code/"
	{
		// Encode "tournamentCode" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tournamentCode",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TournamentCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, TournamentStubV5GetLobbyEventsByCodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, TournamentStubV5GetLobbyEventsByCodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTournamentStubV5GetLobbyEventsByCodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TournamentStubV5GetTournamentCode invokes tournament-stub-v5.getTournamentCode operation.
//
// Returns the tournament code DTO associated with a tournament code string - Stub Method.
//
// GET /lol/tournament-stub/v5/codes/{tournamentCode}
func (c *Client) TournamentStubV5GetTournamentCode(ctx context.Context, params TournamentStubV5GetTournamentCodeParams) (TournamentStubV5GetTournamentCodeRes, error) {
	res, err := c.sendTournamentStubV5GetTournamentCode(ctx, params)
	return res, err
}

func (c *Client) sendTournamentStubV5GetTournamentCode(ctx context.Context, params TournamentStubV5GetTournamentCodeParams) (res TournamentStubV5GetTournamentCodeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tournament-stub-v5.getTournamentCode"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/tournament-stub/v5/codes/{tournamentCode}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TournamentStubV5GetTournamentCodeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lol/tournament-stub/v5/codes/"
	{
		// Encode "tournamentCode" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tournamentCode",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TournamentCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, TournamentStubV5GetTournamentCodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, TournamentStubV5GetTournamentCodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTournamentStubV5GetTournamentCodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TournamentStubV5RegisterProviderData invokes tournament-stub-v5.registerProviderData operation.
//
// Creates a tournament provider and returns its ID - Stub method
// ## Implementation Notes
// Providers will need to call this endpoint first to register their callback URL and their API key
// with the tournament system before any other tournament provider endpoints will work.
//
// POST /lol/tournament-stub/v5/providers
func (c *Client) TournamentStubV5RegisterProviderData(ctx context.Context, request *TournamentStubV5ProviderRegistrationParametersV5) (TournamentStubV5RegisterProviderDataRes, error) {
	res, err := c.sendTournamentStubV5RegisterProviderData(ctx, request)
	return res, err
}

func (c *Client) sendTournamentStubV5RegisterProviderData(ctx context.Context, request *TournamentStubV5ProviderRegistrationParametersV5) (res TournamentStubV5RegisterProviderDataRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tournament-stub-v5.registerProviderData"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/lol/tournament-stub/v5/providers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TournamentStubV5RegisterProviderDataOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/lol/tournament-stub/v5/providers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTournamentStubV5RegisterProviderDataRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, TournamentStubV5RegisterProviderDataOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, TournamentStubV5RegisterProviderDataOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTournamentStubV5RegisterProviderDataResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TournamentStubV5RegisterTournament invokes tournament-stub-v5.registerTournament operation.
//
// Creates a tournament and returns its ID - Stub method.
//
// POST /lol/tournament-stub/v5/tournaments
func (c *Client) TournamentStubV5RegisterTournament(ctx context.Context, request *TournamentStubV5TournamentRegistrationParametersV5) (TournamentStubV5RegisterTournamentRes, error) {
	res, err := c.sendTournamentStubV5RegisterTournament(ctx, request)
	return res, err
}

func (c *Client) sendTournamentStubV5RegisterTournament(ctx context.Context, request *TournamentStubV5TournamentRegistrationParametersV5) (res TournamentStubV5RegisterTournamentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tournament-stub-v5.registerTournament"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/lol/tournament-stub/v5/tournaments"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TournamentStubV5RegisterTournamentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/lol/tournament-stub/v5/tournaments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTournamentStubV5RegisterTournamentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, TournamentStubV5RegisterTournamentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, TournamentStubV5RegisterTournamentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTournamentStubV5RegisterTournamentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TournamentV5CreateTournamentCode invokes tournament-v5.createTournamentCode operation.
//
// Create a tournament code for the given tournament.
//
// POST /lol/tournament/v5/codes
func (c *Client) TournamentV5CreateTournamentCode(ctx context.Context, request *TournamentV5TournamentCodeParametersV5, params TournamentV5CreateTournamentCodeParams) (TournamentV5CreateTournamentCodeRes, error) {
	res, err := c.sendTournamentV5CreateTournamentCode(ctx, request, params)
	return res, err
}

func (c *Client) sendTournamentV5CreateTournamentCode(ctx context.Context, request *TournamentV5TournamentCodeParametersV5, params TournamentV5CreateTournamentCodeParams) (res TournamentV5CreateTournamentCodeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tournament-v5.createTournamentCode"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/lol/tournament/v5/codes"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TournamentV5CreateTournamentCodeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/lol/tournament/v5/codes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "tournamentId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tournamentId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.Int64ToString(params.TournamentId))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "count" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Count.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTournamentV5CreateTournamentCodeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, TournamentV5CreateTournamentCodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, TournamentV5CreateTournamentCodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTournamentV5CreateTournamentCodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TournamentV5GetGames invokes tournament-v5.getGames operation.
//
// Get games details
// ## Implementation Notes
// Additional endpoint to get tournament games. From this endpoint, you are able to get participants
// PUUID (the callback doesn't contain this info).
// You can also use it to check if the game was recorded and validate callbacks. If the endpoint
// returns the game, it means a callback was attempted.
// This will only work for tournament codes created after November 10, 2023.
//
// GET /lol/tournament/v5/games/by-code/{tournamentCode}
func (c *Client) TournamentV5GetGames(ctx context.Context, params TournamentV5GetGamesParams) (TournamentV5GetGamesRes, error) {
	res, err := c.sendTournamentV5GetGames(ctx, params)
	return res, err
}

func (c *Client) sendTournamentV5GetGames(ctx context.Context, params TournamentV5GetGamesParams) (res TournamentV5GetGamesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tournament-v5.getGames"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/tournament/v5/games/by-code/{tournamentCode}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TournamentV5GetGamesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lol/tournament/v5/games/by-code/"
	{
		// Encode "tournamentCode" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tournamentCode",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TournamentCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, TournamentV5GetGamesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, TournamentV5GetGamesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTournamentV5GetGamesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TournamentV5GetLobbyEventsByCode invokes tournament-v5.getLobbyEventsByCode operation.
//
// Gets a list of lobby events by tournament code.
//
// GET /lol/tournament/v5/lobby-events/by-code/{tournamentCode}
func (c *Client) TournamentV5GetLobbyEventsByCode(ctx context.Context, params TournamentV5GetLobbyEventsByCodeParams) (TournamentV5GetLobbyEventsByCodeRes, error) {
	res, err := c.sendTournamentV5GetLobbyEventsByCode(ctx, params)
	return res, err
}

func (c *Client) sendTournamentV5GetLobbyEventsByCode(ctx context.Context, params TournamentV5GetLobbyEventsByCodeParams) (res TournamentV5GetLobbyEventsByCodeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tournament-v5.getLobbyEventsByCode"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/tournament/v5/lobby-events/by-code/{tournamentCode}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TournamentV5GetLobbyEventsByCodeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lol/tournament/v5/lobby-events/by-code/"
	{
		// Encode "tournamentCode" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tournamentCode",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TournamentCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, TournamentV5GetLobbyEventsByCodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, TournamentV5GetLobbyEventsByCodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTournamentV5GetLobbyEventsByCodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TournamentV5GetTournamentCode invokes tournament-v5.getTournamentCode operation.
//
// Returns the tournament code DTO associated with a tournament code string.
//
// GET /lol/tournament/v5/codes/{tournamentCode}
func (c *Client) TournamentV5GetTournamentCode(ctx context.Context, params TournamentV5GetTournamentCodeParams) (TournamentV5GetTournamentCodeRes, error) {
	res, err := c.sendTournamentV5GetTournamentCode(ctx, params)
	return res, err
}

func (c *Client) sendTournamentV5GetTournamentCode(ctx context.Context, params TournamentV5GetTournamentCodeParams) (res TournamentV5GetTournamentCodeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tournament-v5.getTournamentCode"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/lol/tournament/v5/codes/{tournamentCode}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TournamentV5GetTournamentCodeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lol/tournament/v5/codes/"
	{
		// Encode "tournamentCode" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tournamentCode",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TournamentCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, TournamentV5GetTournamentCodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, TournamentV5GetTournamentCodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTournamentV5GetTournamentCodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TournamentV5RegisterProviderData invokes tournament-v5.registerProviderData operation.
//
// Creates a tournament provider and returns its ID.
// ## Implementation Notes
// Providers will need to call this endpoint first to register their callback URL and their API key
// with the tournament system before any other tournament provider endpoints will work.
//
// POST /lol/tournament/v5/providers
func (c *Client) TournamentV5RegisterProviderData(ctx context.Context, request *TournamentV5ProviderRegistrationParametersV5) (TournamentV5RegisterProviderDataRes, error) {
	res, err := c.sendTournamentV5RegisterProviderData(ctx, request)
	return res, err
}

func (c *Client) sendTournamentV5RegisterProviderData(ctx context.Context, request *TournamentV5ProviderRegistrationParametersV5) (res TournamentV5RegisterProviderDataRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tournament-v5.registerProviderData"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/lol/tournament/v5/providers"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TournamentV5RegisterProviderDataOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/lol/tournament/v5/providers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTournamentV5RegisterProviderDataRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, TournamentV5RegisterProviderDataOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, TournamentV5RegisterProviderDataOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTournamentV5RegisterProviderDataResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TournamentV5RegisterTournament invokes tournament-v5.registerTournament operation.
//
// Creates a tournament and returns its ID.
//
// POST /lol/tournament/v5/tournaments
func (c *Client) TournamentV5RegisterTournament(ctx context.Context, request *TournamentV5TournamentRegistrationParametersV5) (TournamentV5RegisterTournamentRes, error) {
	res, err := c.sendTournamentV5RegisterTournament(ctx, request)
	return res, err
}

func (c *Client) sendTournamentV5RegisterTournament(ctx context.Context, request *TournamentV5TournamentRegistrationParametersV5) (res TournamentV5RegisterTournamentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tournament-v5.registerTournament"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/lol/tournament/v5/tournaments"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TournamentV5RegisterTournamentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/lol/tournament/v5/tournaments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTournamentV5RegisterTournamentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, TournamentV5RegisterTournamentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, TournamentV5RegisterTournamentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTournamentV5RegisterTournamentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TournamentV5UpdateCode invokes tournament-v5.updateCode operation.
//
// Update the pick type, map, spectator type, or allowed puuids for a code.
//
// PUT /lol/tournament/v5/codes/{tournamentCode}
func (c *Client) TournamentV5UpdateCode(ctx context.Context, request OptTournamentV5TournamentCodeUpdateParametersV5, params TournamentV5UpdateCodeParams) (TournamentV5UpdateCodeRes, error) {
	res, err := c.sendTournamentV5UpdateCode(ctx, request, params)
	return res, err
}

func (c *Client) sendTournamentV5UpdateCode(ctx context.Context, request OptTournamentV5TournamentCodeUpdateParametersV5, params TournamentV5UpdateCodeParams) (res TournamentV5UpdateCodeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("tournament-v5.updateCode"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/lol/tournament/v5/codes/{tournamentCode}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TournamentV5UpdateCodeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/lol/tournament/v5/codes/"
	{
		// Encode "tournamentCode" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tournamentCode",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TournamentCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTournamentV5UpdateCodeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, TournamentV5UpdateCodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, TournamentV5UpdateCodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTournamentV5UpdateCodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValConsoleMatchV1GetMatch invokes val-console-match-v1.getMatch operation.
//
// Get match by id.
//
// GET /val/match/console/v1/matches/{matchId}
func (c *Client) ValConsoleMatchV1GetMatch(ctx context.Context, params ValConsoleMatchV1GetMatchParams) (ValConsoleMatchV1GetMatchRes, error) {
	res, err := c.sendValConsoleMatchV1GetMatch(ctx, params)
	return res, err
}

func (c *Client) sendValConsoleMatchV1GetMatch(ctx context.Context, params ValConsoleMatchV1GetMatchParams) (res ValConsoleMatchV1GetMatchRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("val-console-match-v1.getMatch"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/val/match/console/v1/matches/{matchId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ValConsoleMatchV1GetMatchOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/val/match/console/v1/matches/"
	{
		// Encode "matchId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "matchId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MatchId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, ValConsoleMatchV1GetMatchOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, ValConsoleMatchV1GetMatchOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeValConsoleMatchV1GetMatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValConsoleMatchV1GetMatchlist invokes val-console-match-v1.getMatchlist operation.
//
// Get matchlist for games played by puuid and platform type.
//
// GET /val/match/console/v1/matchlists/by-puuid/{puuid}
func (c *Client) ValConsoleMatchV1GetMatchlist(ctx context.Context, params ValConsoleMatchV1GetMatchlistParams) (ValConsoleMatchV1GetMatchlistRes, error) {
	res, err := c.sendValConsoleMatchV1GetMatchlist(ctx, params)
	return res, err
}

func (c *Client) sendValConsoleMatchV1GetMatchlist(ctx context.Context, params ValConsoleMatchV1GetMatchlistParams) (res ValConsoleMatchV1GetMatchlistRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("val-console-match-v1.getMatchlist"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/val/match/console/v1/matchlists/by-puuid/{puuid}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ValConsoleMatchV1GetMatchlistOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/val/match/console/v1/matchlists/by-puuid/"
	{
		// Encode "puuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "puuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Puuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "platformType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "platformType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.PlatformType)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, ValConsoleMatchV1GetMatchlistOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, ValConsoleMatchV1GetMatchlistOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeValConsoleMatchV1GetMatchlistResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValConsoleMatchV1GetRecent invokes val-console-match-v1.getRecent operation.
//
// Get recent matches
// ## Implementation Notes
// Returns a list of match ids that have completed in the last 10 minutes for live regions and 12
// hours for the esports routing value. NA/LATAM/BR share a match history deployment. As such, recent
// matches will return a combined list of matches from those three regions. Requests are load
// balanced so you may see some inconsistencies as matches are added/removed from the list.
//
// GET /val/match/console/v1/recent-matches/by-queue/{queue}
func (c *Client) ValConsoleMatchV1GetRecent(ctx context.Context, params ValConsoleMatchV1GetRecentParams) (ValConsoleMatchV1GetRecentRes, error) {
	res, err := c.sendValConsoleMatchV1GetRecent(ctx, params)
	return res, err
}

func (c *Client) sendValConsoleMatchV1GetRecent(ctx context.Context, params ValConsoleMatchV1GetRecentParams) (res ValConsoleMatchV1GetRecentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("val-console-match-v1.getRecent"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/val/match/console/v1/recent-matches/by-queue/{queue}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ValConsoleMatchV1GetRecentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/val/match/console/v1/recent-matches/by-queue/"
	{
		// Encode "queue" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "queue",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Queue)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, ValConsoleMatchV1GetRecentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, ValConsoleMatchV1GetRecentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeValConsoleMatchV1GetRecentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValConsoleRankedV1GetLeaderboard invokes val-console-ranked-v1.getLeaderboard operation.
//
// Get leaderboard for the competitive queue.
//
// GET /val/console/ranked/v1/leaderboards/by-act/{actId}
func (c *Client) ValConsoleRankedV1GetLeaderboard(ctx context.Context, params ValConsoleRankedV1GetLeaderboardParams) (ValConsoleRankedV1GetLeaderboardRes, error) {
	res, err := c.sendValConsoleRankedV1GetLeaderboard(ctx, params)
	return res, err
}

func (c *Client) sendValConsoleRankedV1GetLeaderboard(ctx context.Context, params ValConsoleRankedV1GetLeaderboardParams) (res ValConsoleRankedV1GetLeaderboardRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("val-console-ranked-v1.getLeaderboard"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/val/console/ranked/v1/leaderboards/by-act/{actId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ValConsoleRankedV1GetLeaderboardOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/val/console/ranked/v1/leaderboards/by-act/"
	{
		// Encode "actId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "actId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ActId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "platformType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "platformType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.PlatformType)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "startIndex" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "startIndex",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartIndex.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, ValConsoleRankedV1GetLeaderboardOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, ValConsoleRankedV1GetLeaderboardOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeValConsoleRankedV1GetLeaderboardResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValContentV1GetContent invokes val-content-v1.getContent operation.
//
// Get content optionally filtered by locale.
//
// GET /val/content/v1/contents
func (c *Client) ValContentV1GetContent(ctx context.Context, params ValContentV1GetContentParams) (ValContentV1GetContentRes, error) {
	res, err := c.sendValContentV1GetContent(ctx, params)
	return res, err
}

func (c *Client) sendValContentV1GetContent(ctx context.Context, params ValContentV1GetContentParams) (res ValContentV1GetContentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("val-content-v1.getContent"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/val/content/v1/contents"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ValContentV1GetContentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/val/content/v1/contents"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "locale" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "locale",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Locale.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, ValContentV1GetContentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, ValContentV1GetContentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeValContentV1GetContentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValMatchV1GetMatch invokes val-match-v1.getMatch operation.
//
// Get match by id.
//
// GET /val/match/v1/matches/{matchId}
func (c *Client) ValMatchV1GetMatch(ctx context.Context, params ValMatchV1GetMatchParams) (ValMatchV1GetMatchRes, error) {
	res, err := c.sendValMatchV1GetMatch(ctx, params)
	return res, err
}

func (c *Client) sendValMatchV1GetMatch(ctx context.Context, params ValMatchV1GetMatchParams) (res ValMatchV1GetMatchRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("val-match-v1.getMatch"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/val/match/v1/matches/{matchId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ValMatchV1GetMatchOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/val/match/v1/matches/"
	{
		// Encode "matchId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "matchId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MatchId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, ValMatchV1GetMatchOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, ValMatchV1GetMatchOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeValMatchV1GetMatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValMatchV1GetMatchlist invokes val-match-v1.getMatchlist operation.
//
// Get matchlist for games played by puuid.
//
// GET /val/match/v1/matchlists/by-puuid/{puuid}
func (c *Client) ValMatchV1GetMatchlist(ctx context.Context, params ValMatchV1GetMatchlistParams) (ValMatchV1GetMatchlistRes, error) {
	res, err := c.sendValMatchV1GetMatchlist(ctx, params)
	return res, err
}

func (c *Client) sendValMatchV1GetMatchlist(ctx context.Context, params ValMatchV1GetMatchlistParams) (res ValMatchV1GetMatchlistRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("val-match-v1.getMatchlist"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/val/match/v1/matchlists/by-puuid/{puuid}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ValMatchV1GetMatchlistOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/val/match/v1/matchlists/by-puuid/"
	{
		// Encode "puuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "puuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Puuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, ValMatchV1GetMatchlistOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, ValMatchV1GetMatchlistOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeValMatchV1GetMatchlistResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValMatchV1GetRecent invokes val-match-v1.getRecent operation.
//
// Get recent matches
// ## Implementation Notes
// Returns a list of match ids that have completed in the last 10 minutes for live regions and 12
// hours for the esports routing value. NA/LATAM/BR share a match history deployment. As such, recent
// matches will return a combined list of matches from those three regions. Requests are load
// balanced so you may see some inconsistencies as matches are added/removed from the list.
//
// GET /val/match/v1/recent-matches/by-queue/{queue}
func (c *Client) ValMatchV1GetRecent(ctx context.Context, params ValMatchV1GetRecentParams) (ValMatchV1GetRecentRes, error) {
	res, err := c.sendValMatchV1GetRecent(ctx, params)
	return res, err
}

func (c *Client) sendValMatchV1GetRecent(ctx context.Context, params ValMatchV1GetRecentParams) (res ValMatchV1GetRecentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("val-match-v1.getRecent"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/val/match/v1/recent-matches/by-queue/{queue}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ValMatchV1GetRecentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/val/match/v1/recent-matches/by-queue/"
	{
		// Encode "queue" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "queue",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Queue)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, ValMatchV1GetRecentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, ValMatchV1GetRecentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeValMatchV1GetRecentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValRankedV1GetLeaderboard invokes val-ranked-v1.getLeaderboard operation.
//
// Get leaderboard for the competitive queue.
//
// GET /val/ranked/v1/leaderboards/by-act/{actId}
func (c *Client) ValRankedV1GetLeaderboard(ctx context.Context, params ValRankedV1GetLeaderboardParams) (ValRankedV1GetLeaderboardRes, error) {
	res, err := c.sendValRankedV1GetLeaderboard(ctx, params)
	return res, err
}

func (c *Client) sendValRankedV1GetLeaderboard(ctx context.Context, params ValRankedV1GetLeaderboardParams) (res ValRankedV1GetLeaderboardRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("val-ranked-v1.getLeaderboard"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/val/ranked/v1/leaderboards/by-act/{actId}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ValRankedV1GetLeaderboardOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/val/ranked/v1/leaderboards/by-act/"
	{
		// Encode "actId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "actId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ActId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "startIndex" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "startIndex",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartIndex.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, ValRankedV1GetLeaderboardOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, ValRankedV1GetLeaderboardOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeValRankedV1GetLeaderboardResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValStatusV1GetPlatformData invokes val-status-v1.getPlatformData operation.
//
// Get VALORANT status for the given platform.
//
// GET /val/status/v1/platform-data
func (c *Client) ValStatusV1GetPlatformData(ctx context.Context) (ValStatusV1GetPlatformDataRes, error) {
	res, err := c.sendValStatusV1GetPlatformData(ctx)
	return res, err
}

func (c *Client) sendValStatusV1GetPlatformData(ctx context.Context) (res ValStatusV1GetPlatformDataRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("val-status-v1.getPlatformData"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/val/status/v1/platform-data"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ValStatusV1GetPlatformDataOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/val/status/v1/platform-data"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:APIKey"
			switch err := c.securityAPIKey(ctx, ValStatusV1GetPlatformDataOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"APIKey\"")
			}
		}
		{
			stage = "Security:XRiotToken"
			switch err := c.securityXRiotToken(ctx, ValStatusV1GetPlatformDataOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"XRiotToken\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeValStatusV1GetPlatformDataResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
